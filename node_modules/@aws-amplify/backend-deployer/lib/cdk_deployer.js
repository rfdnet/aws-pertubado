import process from 'node:process';
import { AmplifyError, AmplifyFault, CDKContextKey, } from '@aws-amplify/platform-core';
import path from 'path';
import { HotswapMode, StackSelectionStrategy, } from '@aws-cdk/toolkit-lib';
import { tsImport } from 'tsx/esm/api';
import { CloudAssembly } from 'aws-cdk-lib/cx-api';
import { pathToFileURL } from 'url';
import { AssetStaging } from 'aws-cdk-lib/core';
import { Worker } from 'node:worker_threads';
/**
 * Invokes CDK command via execa
 */
export class CDKDeployer {
    cdkErrorMapper;
    backendLocator;
    packageManagerController;
    cdkToolkit;
    ioHost;
    absoluteCloudAssemblyLocation = path.resolve(process.cwd(), '.amplify/artifacts/cdk.out');
    /**
     * Instantiates instance of CDKDeployer
     */
    constructor(cdkErrorMapper, backendLocator, packageManagerController, cdkToolkit, ioHost) {
        this.cdkErrorMapper = cdkErrorMapper;
        this.backendLocator = backendLocator;
        this.packageManagerController = packageManagerController;
        this.cdkToolkit = cdkToolkit;
        this.ioHost = ioHost;
    }
    /**
     * Invokes cdk deploy API
     */
    deploy = async (backendId, deployProps) => {
        // Hack?? CDK uses global asset cache that is not cleared if assets are
        // changing within the same process (which now happens with CDK Toolkit APIs)
        // See https://github.com/aws/aws-cdk-cli/issues/236
        AssetStaging.clearAssetHashCache();
        const cx = await this.getCdkCloudAssembly(backendId, deployProps?.secretLastUpdated?.getTime());
        // Initiate synth for the cloud executable and send a message for display.
        const synthStartTime = Date.now();
        let synthAssembly, synthError = undefined;
        await this.ioHost.notify({
            message: `Backend synthesis started`,
            code: 'SYNTH_STARTED',
            action: 'amplify',
            time: new Date(),
            level: 'info',
            data: undefined,
        });
        try {
            synthAssembly = await this.cdkToolkit.synth(cx, {
                stacks: {
                    strategy: StackSelectionStrategy.ALL_STACKS,
                },
            });
        }
        catch (error) {
            synthError = error;
        }
        const synthTimeSeconds = Math.floor((Date.now() - synthStartTime) / 10) / 100;
        await this.ioHost.notify({
            message: `Backend synthesized in ${synthTimeSeconds} seconds`,
            code: 'SYNTH_FINISHED',
            action: 'amplify',
            time: new Date(),
            level: 'result',
            data: undefined,
        });
        // Typescript compilation. For type related errors, we prefer to show errors from TS to customers rather than synth
        const typeCheckStartTime = Date.now();
        await this.ioHost.notify({
            message: `Backend type checks started`,
            code: 'TS_STARTED',
            action: 'amplify',
            time: new Date(),
            level: 'info',
            data: undefined,
        });
        if (deployProps?.validateAppSources) {
            try {
                await this.compileProject(path.dirname(this.backendLocator.locate()));
            }
            catch (typeError) {
                if (synthError &&
                    AmplifyError.isAmplifyError(typeError) &&
                    typeError.name === 'FunctionEnvVarFileNotGeneratedError') {
                    // synth has failed and we don't have auto generated function environment definition files. This
                    // resulted in the exception caught here, which is not very useful for the customers.
                    // We instead throw the synth error for customers to fix what caused the synth to fail.
                    throw this.cdkErrorMapper.getAmplifyError(synthError, backendId.type);
                }
                throw typeError;
            }
            finally {
                const typeCheckTimeSeconds = Math.floor((Date.now() - typeCheckStartTime) / 10) / 100;
                await this.ioHost.notify({
                    message: `Type checks completed in ${typeCheckTimeSeconds} seconds`,
                    code: 'TS_FINISHED',
                    action: 'amplify',
                    time: new Date(),
                    level: 'result',
                    data: undefined,
                });
            }
        }
        // If typescript compilation was successful but synth had failed, we throw synth error
        if (synthError) {
            throw this.cdkErrorMapper.getAmplifyError(synthError, backendId.type);
        }
        // Perform actual deployment. CFN or hotswap
        const deployStartTime = Date.now();
        try {
            await this.cdkToolkit.deploy(synthAssembly, {
                stacks: {
                    strategy: StackSelectionStrategy.ALL_STACKS,
                },
                hotswap: backendId.type === 'sandbox'
                    ? HotswapMode.FALL_BACK
                    : HotswapMode.FULL_DEPLOYMENT,
            });
        }
        catch (error) {
            await this.ioHost.notify({
                message: 'Deployment failed',
                code: 'DEPLOY_FAILED',
                action: 'amplify',
                time: new Date(),
                level: 'error',
                data: undefined,
            });
            throw this.cdkErrorMapper.getAmplifyError(error, backendId.type);
        }
        finally {
            await synthAssembly?.dispose();
        }
        return {
            deploymentTimes: {
                synthesisTime: synthTimeSeconds,
                totalTime: synthTimeSeconds +
                    Math.floor((Date.now() - deployStartTime) / 10) / 100,
            },
        };
    };
    /**
     * Invokes cdk destroy API
     */
    destroy = async (backendId) => {
        const deploymentStartTime = Date.now();
        try {
            await this.cdkToolkit.destroy(await this.getCdkCloudAssembly(backendId), {
                stacks: {
                    strategy: StackSelectionStrategy.ALL_STACKS,
                },
            });
            return {
                deploymentTimes: {
                    totalTime: Math.floor((Date.now() - deploymentStartTime) / 10) / 100,
                },
            };
        }
        catch (error) {
            throw this.cdkErrorMapper.getAmplifyError(error, backendId.type);
        }
    };
    compileProject = (projectDirectory) => {
        return new Promise((resolve, reject) => {
            const worker = new Worker(new URL('ts_compiler.js', import.meta.url), {
                workerData: { projectDirectory },
            });
            worker.on('message', () => {
                // do nothing
            });
            worker.on('error', reject);
            worker.on('exit', (code) => {
                if (code !== 0) {
                    reject(new AmplifyFault('TSCompilerWorkerFault', {
                        message: `Worker stopped with exit code ${code}`,
                    }));
                }
                resolve();
            });
        });
    };
    /**
     * Build cloud executable from dynamically importing the cdk ts file, i.e. backend.ts
     */
    getCdkCloudAssembly = (backendId, secretLastUpdated) => {
        const contextParams = {};
        if (backendId.type === 'sandbox') {
            if (secretLastUpdated) {
                contextParams['secretLastUpdated'] = secretLastUpdated;
            }
        }
        contextParams[CDKContextKey.BACKEND_NAMESPACE] = backendId.namespace;
        contextParams[CDKContextKey.BACKEND_NAME] = backendId.name;
        contextParams[CDKContextKey.DEPLOYMENT_TYPE] = backendId.type;
        return this.cdkToolkit.fromAssemblyBuilder(async () => {
            await tsImport(pathToFileURL(this.backendLocator.locate()).toString(), import.meta.url);
            /**
              By not having a child process with toolkit lib, the `process.on('beforeExit')` does not execute
              on the CDK side resulting in the app not getting synthesized properly. So we send a signal/message
              to the same process and catch it in backend package where App is initialized to explicitly perform synth
             */
            process.emit('message', 'amplifySynth', undefined);
            return new CloudAssembly(this.absoluteCloudAssemblyLocation);
        }, { context: contextParams, outdir: this.absoluteCloudAssemblyLocation });
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrX2RlcGxveWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nka19kZXBsb3llci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFZbkMsT0FBTyxFQUNMLFlBQVksRUFDWixZQUFZLEVBRVosYUFBYSxHQUNkLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFDTCxXQUFXLEVBQ1gsc0JBQXNCLEdBRXZCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN2QyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUNwQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRTdDOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUFVSDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBYkYsNkJBQTZCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FDM0QsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUNiLDRCQUE0QixDQUM3QixDQUFDO0lBRUY7O09BRUc7SUFDSCxZQUNtQixjQUE4QixFQUM5QixjQUE4QixFQUM5Qix3QkFBa0QsRUFDbEQsVUFBbUIsRUFDbkIsTUFBcUI7UUFKckIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5Qiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBQ2xELGVBQVUsR0FBVixVQUFVLENBQVM7UUFDbkIsV0FBTSxHQUFOLE1BQU0sQ0FBZTtJQUNyQyxDQUFDO0lBRUo7O09BRUc7SUFDSCxNQUFNLEdBQUcsS0FB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aUJBQWlCLENBQUM7WUFDekQsQ0FBQztRQUNILENBQUM7UUFFRCxhQUFhLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQztRQUNyRSxhQUFhLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDM0QsYUFBYSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQzlELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FDeEMsS0FBSyxJQUFJLEVBQUU7WUFDVCxNQUFNLFFBQVEsQ0FDWixhQUFhLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUN0RCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FDaEIsQ0FBQztZQUNGOzs7O2VBSUc7WUFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkQsT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUMvRCxDQUFDLEVBQ0QsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsNkJBQTZCLEVBQUUsQ0FDdkUsQ0FBQztJQUNKLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcblxuaW1wb3J0IHtcbiAgQmFja2VuZERlcGxveWVyLFxuICBEZXBsb3lQcm9wcyxcbn0gZnJvbSAnLi9jZGtfZGVwbG95ZXJfc2luZ2xldG9uX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgQ2RrRXJyb3JNYXBwZXIgfSBmcm9tICcuL2Nka19lcnJvcl9tYXBwZXIuanMnO1xuaW1wb3J0IHtcbiAgQW1wbGlmeUlPSG9zdCxcbiAgQmFja2VuZElkZW50aWZpZXIsXG4gIHR5cGUgUGFja2FnZU1hbmFnZXJDb250cm9sbGVyLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeUZhdWx0LFxuICBCYWNrZW5kTG9jYXRvcixcbiAgQ0RLQ29udGV4dEtleSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge1xuICBIb3Rzd2FwTW9kZSxcbiAgU3RhY2tTZWxlY3Rpb25TdHJhdGVneSxcbiAgVG9vbGtpdCxcbn0gZnJvbSAnQGF3cy1jZGsvdG9vbGtpdC1saWInO1xuaW1wb3J0IHsgdHNJbXBvcnQgfSBmcm9tICd0c3gvZXNtL2FwaSc7XG5pbXBvcnQgeyBDbG91ZEFzc2VtYmx5IH0gZnJvbSAnYXdzLWNkay1saWIvY3gtYXBpJztcbmltcG9ydCB7IHBhdGhUb0ZpbGVVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgQXNzZXRTdGFnaW5nIH0gZnJvbSAnYXdzLWNkay1saWIvY29yZSc7XG5pbXBvcnQgeyBXb3JrZXIgfSBmcm9tICdub2RlOndvcmtlcl90aHJlYWRzJztcblxuLyoqXG4gKiBJbnZva2VzIENESyBjb21tYW5kIHZpYSBleGVjYVxuICovXG5leHBvcnQgY2xhc3MgQ0RLRGVwbG95ZXIgaW1wbGVtZW50cyBCYWNrZW5kRGVwbG95ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGFic29sdXRlQ2xvdWRBc3NlbWJseUxvY2F0aW9uID0gcGF0aC5yZXNvbHZlKFxuICAgIHByb2Nlc3MuY3dkKCksXG4gICAgJy5hbXBsaWZ5L2FydGlmYWN0cy9jZGsub3V0JyxcbiAgKTtcblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGluc3RhbmNlIG9mIENES0RlcGxveWVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNka0Vycm9yTWFwcGVyOiBDZGtFcnJvck1hcHBlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRMb2NhdG9yOiBCYWNrZW5kTG9jYXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhY2thZ2VNYW5hZ2VyQ29udHJvbGxlcjogUGFja2FnZU1hbmFnZXJDb250cm9sbGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RrVG9vbGtpdDogVG9vbGtpdCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlvSG9zdDogQW1wbGlmeUlPSG9zdCxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXBsb3kgQVBJXG4gICAqL1xuICBkZXBsb3kgPSBhc3luYyAoYmFja2VuZElkOiBCYWNrZW5kSWRlbnRpZmllciwgZGVwbG95UHJvcHM/OiBEZXBsb3lQcm9wcykgPT4ge1xuICAgIC8vIEhhY2s/PyBDREsgdXNlcyBnbG9iYWwgYXNzZXQgY2FjaGUgdGhhdCBpcyBub3QgY2xlYXJlZCBpZiBhc3NldHMgYXJlXG4gICAgLy8gY2hhbmdpbmcgd2l0aGluIHRoZSBzYW1lIHByb2Nlc3MgKHdoaWNoIG5vdyBoYXBwZW5zIHdpdGggQ0RLIFRvb2xraXQgQVBJcylcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrLWNsaS9pc3N1ZXMvMjM2XG4gICAgQXNzZXRTdGFnaW5nLmNsZWFyQXNzZXRIYXNoQ2FjaGUoKTtcblxuICAgIGNvbnN0IGN4ID0gYXdhaXQgdGhpcy5nZXRDZGtDbG91ZEFzc2VtYmx5KFxuICAgICAgYmFja2VuZElkLFxuICAgICAgZGVwbG95UHJvcHM/LnNlY3JldExhc3RVcGRhdGVkPy5nZXRUaW1lKCksXG4gICAgKTtcbiAgICAvLyBJbml0aWF0ZSBzeW50aCBmb3IgdGhlIGNsb3VkIGV4ZWN1dGFibGUgYW5kIHNlbmQgYSBtZXNzYWdlIGZvciBkaXNwbGF5LlxuICAgIGNvbnN0IHN5bnRoU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3ludGhBc3NlbWJseSxcbiAgICAgIHN5bnRoRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGF3YWl0IHRoaXMuaW9Ib3N0Lm5vdGlmeSh7XG4gICAgICBtZXNzYWdlOiBgQmFja2VuZCBzeW50aGVzaXMgc3RhcnRlZGAsXG4gICAgICBjb2RlOiAnU1lOVEhfU1RBUlRFRCcsXG4gICAgICBhY3Rpb246ICdhbXBsaWZ5JyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCksXG4gICAgICBsZXZlbDogJ2luZm8nLFxuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN5bnRoQXNzZW1ibHkgPSBhd2FpdCB0aGlzLmNka1Rvb2xraXQuc3ludGgoY3gsIHtcbiAgICAgICAgc3RhY2tzOiB7XG4gICAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuQUxMX1NUQUNLUyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzeW50aEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ludGhUaW1lU2Vjb25kcyA9XG4gICAgICBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gc3ludGhTdGFydFRpbWUpIC8gMTApIC8gMTAwO1xuXG4gICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHtcbiAgICAgIG1lc3NhZ2U6IGBCYWNrZW5kIHN5bnRoZXNpemVkIGluICR7c3ludGhUaW1lU2Vjb25kc30gc2Vjb25kc2AsXG4gICAgICBjb2RlOiAnU1lOVEhfRklOSVNIRUQnLFxuICAgICAgYWN0aW9uOiAnYW1wbGlmeScsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgbGV2ZWw6ICdyZXN1bHQnLFxuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgLy8gVHlwZXNjcmlwdCBjb21waWxhdGlvbi4gRm9yIHR5cGUgcmVsYXRlZCBlcnJvcnMsIHdlIHByZWZlciB0byBzaG93IGVycm9ycyBmcm9tIFRTIHRvIGN1c3RvbWVycyByYXRoZXIgdGhhbiBzeW50aFxuICAgIGNvbnN0IHR5cGVDaGVja1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHtcbiAgICAgIG1lc3NhZ2U6IGBCYWNrZW5kIHR5cGUgY2hlY2tzIHN0YXJ0ZWRgLFxuICAgICAgY29kZTogJ1RTX1NUQVJURUQnLFxuICAgICAgYWN0aW9uOiAnYW1wbGlmeScsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIGlmIChkZXBsb3lQcm9wcz8udmFsaWRhdGVBcHBTb3VyY2VzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbXBpbGVQcm9qZWN0KHBhdGguZGlybmFtZSh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKSk7XG4gICAgICB9IGNhdGNoICh0eXBlRXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN5bnRoRXJyb3IgJiZcbiAgICAgICAgICBBbXBsaWZ5RXJyb3IuaXNBbXBsaWZ5RXJyb3IodHlwZUVycm9yKSAmJlxuICAgICAgICAgIHR5cGVFcnJvci5uYW1lID09PSAnRnVuY3Rpb25FbnZWYXJGaWxlTm90R2VuZXJhdGVkRXJyb3InXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHN5bnRoIGhhcyBmYWlsZWQgYW5kIHdlIGRvbid0IGhhdmUgYXV0byBnZW5lcmF0ZWQgZnVuY3Rpb24gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBmaWxlcy4gVGhpc1xuICAgICAgICAgIC8vIHJlc3VsdGVkIGluIHRoZSBleGNlcHRpb24gY2F1Z2h0IGhlcmUsIHdoaWNoIGlzIG5vdCB2ZXJ5IHVzZWZ1bCBmb3IgdGhlIGN1c3RvbWVycy5cbiAgICAgICAgICAvLyBXZSBpbnN0ZWFkIHRocm93IHRoZSBzeW50aCBlcnJvciBmb3IgY3VzdG9tZXJzIHRvIGZpeCB3aGF0IGNhdXNlZCB0aGUgc3ludGggdG8gZmFpbC5cbiAgICAgICAgICB0aHJvdyB0aGlzLmNka0Vycm9yTWFwcGVyLmdldEFtcGxpZnlFcnJvcihzeW50aEVycm9yLCBiYWNrZW5kSWQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdHlwZUVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgdHlwZUNoZWNrVGltZVNlY29uZHMgPVxuICAgICAgICAgIE1hdGguZmxvb3IoKERhdGUubm93KCkgLSB0eXBlQ2hlY2tTdGFydFRpbWUpIC8gMTApIC8gMTAwO1xuICAgICAgICBhd2FpdCB0aGlzLmlvSG9zdC5ub3RpZnkoe1xuICAgICAgICAgIG1lc3NhZ2U6IGBUeXBlIGNoZWNrcyBjb21wbGV0ZWQgaW4gJHt0eXBlQ2hlY2tUaW1lU2Vjb25kc30gc2Vjb25kc2AsXG4gICAgICAgICAgY29kZTogJ1RTX0ZJTklTSEVEJyxcbiAgICAgICAgICBhY3Rpb246ICdhbXBsaWZ5JyxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGxldmVsOiAncmVzdWx0JyxcbiAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHR5cGVzY3JpcHQgY29tcGlsYXRpb24gd2FzIHN1Y2Nlc3NmdWwgYnV0IHN5bnRoIGhhZCBmYWlsZWQsIHdlIHRocm93IHN5bnRoIGVycm9yXG4gICAgaWYgKHN5bnRoRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuY2RrRXJyb3JNYXBwZXIuZ2V0QW1wbGlmeUVycm9yKHN5bnRoRXJyb3IsIGJhY2tlbmRJZC50eXBlKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGFjdHVhbCBkZXBsb3ltZW50LiBDRk4gb3IgaG90c3dhcFxuICAgIGNvbnN0IGRlcGxveVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2RrVG9vbGtpdC5kZXBsb3koc3ludGhBc3NlbWJseSEsIHtcbiAgICAgICAgc3RhY2tzOiB7XG4gICAgICAgICAgc3RyYXRlZ3k6IFN0YWNrU2VsZWN0aW9uU3RyYXRlZ3kuQUxMX1NUQUNLUyxcbiAgICAgICAgfSxcbiAgICAgICAgaG90c3dhcDpcbiAgICAgICAgICBiYWNrZW5kSWQudHlwZSA9PT0gJ3NhbmRib3gnXG4gICAgICAgICAgICA/IEhvdHN3YXBNb2RlLkZBTExfQkFDS1xuICAgICAgICAgICAgOiBIb3Rzd2FwTW9kZS5GVUxMX0RFUExPWU1FTlQsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgdGhpcy5pb0hvc3Qubm90aWZ5KHtcbiAgICAgICAgbWVzc2FnZTogJ0RlcGxveW1lbnQgZmFpbGVkJyxcbiAgICAgICAgY29kZTogJ0RFUExPWV9GQUlMRUQnLFxuICAgICAgICBhY3Rpb246ICdhbXBsaWZ5JyxcbiAgICAgICAgdGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgdGhpcy5jZGtFcnJvck1hcHBlci5nZXRBbXBsaWZ5RXJyb3IoZXJyb3IgYXMgRXJyb3IsIGJhY2tlbmRJZC50eXBlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgc3ludGhBc3NlbWJseT8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkZXBsb3ltZW50VGltZXM6IHtcbiAgICAgICAgc3ludGhlc2lzVGltZTogc3ludGhUaW1lU2Vjb25kcyxcbiAgICAgICAgdG90YWxUaW1lOlxuICAgICAgICAgIHN5bnRoVGltZVNlY29uZHMgK1xuICAgICAgICAgIE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBkZXBsb3lTdGFydFRpbWUpIC8gMTApIC8gMTAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIGNkayBkZXN0cm95IEFQSVxuICAgKi9cbiAgZGVzdHJveSA9IGFzeW5jIChiYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyKSA9PiB7XG4gICAgY29uc3QgZGVwbG95bWVudFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2RrVG9vbGtpdC5kZXN0cm95KGF3YWl0IHRoaXMuZ2V0Q2RrQ2xvdWRBc3NlbWJseShiYWNrZW5kSWQpLCB7XG4gICAgICAgIHN0YWNrczoge1xuICAgICAgICAgIHN0cmF0ZWd5OiBTdGFja1NlbGVjdGlvblN0cmF0ZWd5LkFMTF9TVEFDS1MsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlcGxveW1lbnRUaW1lczoge1xuICAgICAgICAgIHRvdGFsVGltZTogTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGRlcGxveW1lbnRTdGFydFRpbWUpIC8gMTApIC8gMTAwLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5jZGtFcnJvck1hcHBlci5nZXRBbXBsaWZ5RXJyb3IoZXJyb3IgYXMgRXJyb3IsIGJhY2tlbmRJZC50eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgY29tcGlsZVByb2plY3QgPSAocHJvamVjdERpcmVjdG9yeTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgndHNfY29tcGlsZXIuanMnLCBpbXBvcnQubWV0YS51cmwpLCB7XG4gICAgICAgIHdvcmtlckRhdGE6IHsgcHJvamVjdERpcmVjdG9yeSB9LFxuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCAoKSA9PiB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIH0pO1xuICAgICAgd29ya2VyLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB3b3JrZXIub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBBbXBsaWZ5RmF1bHQoJ1RTQ29tcGlsZXJXb3JrZXJGYXVsdCcsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFdvcmtlciBzdG9wcGVkIHdpdGggZXhpdCBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGQgY2xvdWQgZXhlY3V0YWJsZSBmcm9tIGR5bmFtaWNhbGx5IGltcG9ydGluZyB0aGUgY2RrIHRzIGZpbGUsIGkuZS4gYmFja2VuZC50c1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRDZGtDbG91ZEFzc2VtYmx5ID0gKFxuICAgIGJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgc2VjcmV0TGFzdFVwZGF0ZWQ/OiBudW1iZXIsXG4gICkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHRQYXJhbXM6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG4gICAgfSA9IHt9O1xuXG4gICAgaWYgKGJhY2tlbmRJZC50eXBlID09PSAnc2FuZGJveCcpIHtcbiAgICAgIGlmIChzZWNyZXRMYXN0VXBkYXRlZCkge1xuICAgICAgICBjb250ZXh0UGFyYW1zWydzZWNyZXRMYXN0VXBkYXRlZCddID0gc2VjcmV0TGFzdFVwZGF0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dFBhcmFtc1tDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRVNQQUNFXSA9IGJhY2tlbmRJZC5uYW1lc3BhY2U7XG4gICAgY29udGV4dFBhcmFtc1tDREtDb250ZXh0S2V5LkJBQ0tFTkRfTkFNRV0gPSBiYWNrZW5kSWQubmFtZTtcbiAgICBjb250ZXh0UGFyYW1zW0NES0NvbnRleHRLZXkuREVQTE9ZTUVOVF9UWVBFXSA9IGJhY2tlbmRJZC50eXBlO1xuICAgIHJldHVybiB0aGlzLmNka1Rvb2xraXQuZnJvbUFzc2VtYmx5QnVpbGRlcihcbiAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdHNJbXBvcnQoXG4gICAgICAgICAgcGF0aFRvRmlsZVVSTCh0aGlzLmJhY2tlbmRMb2NhdG9yLmxvY2F0ZSgpKS50b1N0cmluZygpLFxuICAgICAgICAgIGltcG9ydC5tZXRhLnVybCxcbiAgICAgICAgKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAgQnkgbm90IGhhdmluZyBhIGNoaWxkIHByb2Nlc3Mgd2l0aCB0b29sa2l0IGxpYiwgdGhlIGBwcm9jZXNzLm9uKCdiZWZvcmVFeGl0JylgIGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICBvbiB0aGUgQ0RLIHNpZGUgcmVzdWx0aW5nIGluIHRoZSBhcHAgbm90IGdldHRpbmcgc3ludGhlc2l6ZWQgcHJvcGVybHkuIFNvIHdlIHNlbmQgYSBzaWduYWwvbWVzc2FnZVxuICAgICAgICAgIHRvIHRoZSBzYW1lIHByb2Nlc3MgYW5kIGNhdGNoIGl0IGluIGJhY2tlbmQgcGFja2FnZSB3aGVyZSBBcHAgaXMgaW5pdGlhbGl6ZWQgdG8gZXhwbGljaXRseSBwZXJmb3JtIHN5bnRoXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzLmVtaXQoJ21lc3NhZ2UnLCAnYW1wbGlmeVN5bnRoJywgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDbG91ZEFzc2VtYmx5KHRoaXMuYWJzb2x1dGVDbG91ZEFzc2VtYmx5TG9jYXRpb24pO1xuICAgICAgfSxcbiAgICAgIHsgY29udGV4dDogY29udGV4dFBhcmFtcywgb3V0ZGlyOiB0aGlzLmFic29sdXRlQ2xvdWRBc3NlbWJseUxvY2F0aW9uIH0sXG4gICAgKTtcbiAgfTtcbn1cbiJdfQ==