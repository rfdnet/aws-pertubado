"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationMessageHistoryRetriever = void 0;
const graphql_request_executor_1 = require("./graphql_request_executor");
const user_agent_provider_1 = require("./user_agent_provider");
/**
 * These are all properties we have to pull.
 * Unfortunately, GQL doesn't support wildcards.
 * https://github.com/graphql/graphql-spec/issues/127
 */
const messageItemSelectionSet = `
                id
                conversationId
                associatedUserMessageId
                aiContext
                role
                content {
                  text
                  document {
                    source {
                      bytes
                    }
                    format
                    name
                  }
                  image {
                    format
                    source {
                      bytes
                    }
                  }
                  toolResult {
                    content {
                      document {
                        format
                        name
                        source {
                          bytes
                        }
                      }
                      image {
                        format
                        source {
                          bytes
                        }
                      }
                      json
                      text
                    }
                    status
                    toolUseId
                  }
                  toolUse {
                    input
                    name
                    toolUseId
                  }
                }
`;
/**
 * This class is responsible for retrieving message history that belongs to conversation turn event.
 * It queries AppSync to list messages that belong to conversation.
 * Additionally, it looks up a current message in case it's missing in the list due to eventual consistency.
 */
class ConversationMessageHistoryRetriever {
    /**
     * Creates conversation message history retriever.
     */
    constructor(event, graphqlRequestExecutor = new graphql_request_executor_1.GraphqlRequestExecutor(event.graphqlApiEndpoint, event.request.headers.authorization, new user_agent_provider_1.UserAgentProvider(event))) {
        this.event = event;
        this.graphqlRequestExecutor = graphqlRequestExecutor;
        this.getMessageHistory = async () => {
            const messages = await this.listMessages();
            let currentMessage = messages.find((m) => m.id === this.event.currentMessageId);
            // This is a fallback in case current message is not available in the message list.
            // I.e. in a situation when freshly written message is not yet visible in
            // eventually consistent reads.
            if (!currentMessage) {
                currentMessage = await this.getCurrentMessage();
                messages.push(currentMessage);
            }
            // Index assistant messages by corresponding user message.
            const assistantMessageByUserMessageId = new Map();
            messages.forEach((message) => {
                if (message.role === 'assistant' && message.associatedUserMessageId) {
                    assistantMessageByUserMessageId.set(message.associatedUserMessageId, message);
                }
            });
            // Reconcile history and inject aiContext
            const orderedMessages = messages.reduce((acc, current) => {
                // Bedrock expects that message history is user->assistant->user->assistant->... and so on.
                // The chronological order doesn't assure this ordering if there were any concurrent messages sent.
                // Therefore, conversation is ordered by user's messages only and corresponding assistant messages are inserted
                // into right place regardless of their createdAt value.
                // This algorithm assumes that GQL query returns messages sorted by createdAt.
                if (current.role === 'assistant') {
                    // Initially, skip assistant messages, these might be out of chronological order.
                    return acc;
                }
                if (current.role === 'user' &&
                    !assistantMessageByUserMessageId.has(current.id) &&
                    current.id !== this.event.currentMessageId) {
                    // Skip user messages that didn't get answer from assistant yet.
                    // These might be still "in-flight", i.e. assistant is still working on them in separate invocation.
                    // Except current message, we want to process that one.
                    return acc;
                }
                const aiContext = current.aiContext;
                const content = aiContext
                    ? [...current.content, { text: JSON.stringify(aiContext) }]
                    : current.content;
                acc.push({ role: current.role, content });
                // Find and insert corresponding assistant message.
                const correspondingAssistantMessage = assistantMessageByUserMessageId.get(current.id);
                if (correspondingAssistantMessage) {
                    acc.push({
                        role: correspondingAssistantMessage.role,
                        content: correspondingAssistantMessage.content,
                    });
                }
                return acc;
            }, []);
            // Remove tool usage from non-current turn and squash messages.
            return this.squashNonCurrentTurns(orderedMessages);
        };
        /**
         * This function removes tool usage from non-current turns.
         * The tool usage and result blocks don't matter after a turn is completed,
         * but do cost extra tokens to process.
         * The algorithm is as follows:
         * 1. Find where current turn begins. I.e. last user message that isn't tool block.
         * 2. Remove toolUse and toolResult blocks before current turn.
         * 3. Squash continuous sequences of messages that belong to same 'message.role'.
         */
        this.squashNonCurrentTurns = (messages) => {
            const isNonToolBlockPredicate = (contentBlock) => !contentBlock.toolUse && !contentBlock.toolResult;
            // find where current turn begins. I.e. last user message that is not related to tools
            const lastNonToolUseUserMessageIndex = messages.findLastIndex((message) => {
                return (message.role === 'user' && message.content.find(isNonToolBlockPredicate));
            });
            // No non-current turns, don't transform.
            if (lastNonToolUseUserMessageIndex <= 0) {
                return messages;
            }
            const squashedMessages = [];
            // Define a "buffer". I.e. a message we keep around and squash content on.
            let currentSquashedMessage = undefined;
            // Process messages before current turn begins
            // Remove tool usage blocks.
            // Combine content for consecutive message that have same role.
            for (let i = 0; i < lastNonToolUseUserMessageIndex; i++) {
                const currentMessage = messages[i];
                const currentMessageRole = currentMessage.role;
                const currentMessageNonToolContent = currentMessage.content.filter(isNonToolBlockPredicate);
                if (currentMessageNonToolContent.length === 0) {
                    // Tool only message. Nothing to squash, skip;
                    continue;
                }
                if (!currentSquashedMessage) {
                    // Nothing squashed yet, initialize the buffer.
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
                else if (currentSquashedMessage.role === currentMessageRole) {
                    // if role is same append content.
                    currentSquashedMessage.content.push(...currentMessageNonToolContent);
                }
                else {
                    // if role flips push current squashed message and re-initialize the buffer.
                    squashedMessages.push(currentSquashedMessage);
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
            }
            // flush the last buffer.
            if (currentSquashedMessage) {
                squashedMessages.push(currentSquashedMessage);
            }
            // Append current turn as is.
            squashedMessages.push(...messages.slice(lastNonToolUseUserMessageIndex));
            return squashedMessages;
        };
        this.getCurrentMessage = async () => {
            const query = `
        query GetMessage($id: ${this.event.messageHistoryQuery.getQueryInputTypeName}!) {
            ${this.event.messageHistoryQuery.getQueryName}(id: $id) {
              ${messageItemSelectionSet}
            }
        }
    `;
            const variables = {
                id: this.event.currentMessageId,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            return response.data[this.event.messageHistoryQuery.getQueryName];
        };
        this.listMessages = async () => {
            var _a;
            const query = `
        query ListMessages($filter: ${this.event.messageHistoryQuery.listQueryInputTypeName}!, $limit: Int) {
            ${this.event.messageHistoryQuery.listQueryName}(filter: $filter, limit: $limit) {
              items {
                ${messageItemSelectionSet}
              }
            }
        }
    `;
            const variables = {
                filter: {
                    conversationId: {
                        eq: this.event.conversationId,
                    },
                },
                limit: (_a = this.event.messageHistoryQuery.listQueryLimit) !== null && _a !== void 0 ? _a : 1000,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            const items = response.data[this.event.messageHistoryQuery.listQueryName].items;
            items.forEach((item) => {
                var _a;
                (_a = item.content) === null || _a === void 0 ? void 0 : _a.forEach((contentBlock) => {
                    var _a, _b;
                    let property;
                    for (property in contentBlock) {
                        // Deserialization of GraphQl query result sets these properties to 'null'
                        // This can trigger Bedrock SDK validation as it expects 'undefined' if properties are not set.
                        // We can't fix how GraphQl response is deserialized.
                        // Therefore, we apply this transformation to fix the data.
                        if (contentBlock[property] === null) {
                            contentBlock[property] = undefined;
                        }
                    }
                    if (typeof ((_a = contentBlock.toolUse) === null || _a === void 0 ? void 0 : _a.input) === 'string') {
                        // toolUse.input may come as serialized JSON for Client Tools.
                        // Parse it in that case.
                        contentBlock.toolUse.input = JSON.parse(contentBlock.toolUse.input);
                    }
                    if ((_b = contentBlock.toolResult) === null || _b === void 0 ? void 0 : _b.content) {
                        contentBlock.toolResult.content.forEach((toolResultContentBlock) => {
                            if (typeof toolResultContentBlock.json === 'string') {
                                // toolResult.content[].json may come as serialized JSON for Client Tools.
                                // Parse it in that case.
                                toolResultContentBlock.json = JSON.parse(toolResultContentBlock.json);
                            }
                        });
                    }
                });
            });
            return items;
        };
    }
}
exports.ConversationMessageHistoryRetriever = ConversationMessageHistoryRetriever;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udmVyc2F0aW9uL3J1bnRpbWUvY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBS0EseUVBQW9FO0FBQ3BFLCtEQUEwRDtBQW1DMUQ7Ozs7R0FJRztBQUNILE1BQU0sdUJBQXVCLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdEL0IsQ0FBQztBQUVGOzs7O0dBSUc7QUFDSCxNQUFhLG1DQUFtQztJQUM5Qzs7T0FFRztJQUNILFlBQ21CLEtBQTRCLEVBQzVCLHlCQUF5QixJQUFJLGlEQUFzQixDQUNsRSxLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFDbkMsSUFBSSx1Q0FBaUIsQ0FBQyxLQUFLLENBQUMsQ0FDN0I7UUFMZ0IsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFDNUIsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUl0QztRQUdILHNCQUFpQixHQUFHLEtBQUssSUFBeUMsRUFBRTtZQUNsRSxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUUzQyxJQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUNoQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUM1QyxDQUFDO1lBRUYsbUZBQW1GO1lBQ25GLHlFQUF5RTtZQUN6RSwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDbkIsY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7Z0JBQ2hELFFBQVEsQ0FB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LElBQUksT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO2dDQUNuRCwwRUFBMEU7Z0NBQzFFLHlCQUF5QjtnQ0FDekIsc0JBQXNCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ3RDLHNCQUFzQixDQUFDLElBQUksQ0FDNUIsQ0FBQzs2QkFDSDt3QkFDSCxDQUFDLENBQUMsQ0FBQztxQkFDSjtnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUM7SUE3T0MsQ0FBQztDQThPTDtBQXpQRCxrRkF5UEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb252ZXJzYXRpb25NZXNzYWdlLFxuICBDb252ZXJzYXRpb25NZXNzYWdlQ29udGVudEJsb2NrLFxuICBDb252ZXJzYXRpb25UdXJuRXZlbnQsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgR3JhcGhxbFJlcXVlc3RFeGVjdXRvciB9IGZyb20gJy4vZ3JhcGhxbF9yZXF1ZXN0X2V4ZWN1dG9yJztcbmltcG9ydCB7IFVzZXJBZ2VudFByb3ZpZGVyIH0gZnJvbSAnLi91c2VyX2FnZW50X3Byb3ZpZGVyJztcblxuZXhwb3J0IHR5cGUgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtID0gQ29udmVyc2F0aW9uTWVzc2FnZSAmIHtcbiAgaWQ6IHN0cmluZztcbiAgY29udmVyc2F0aW9uSWQ6IHN0cmluZztcbiAgYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQ/OiBzdHJpbmc7XG4gIGFpQ29udGV4dD86IHVua25vd247XG59O1xuXG5leHBvcnQgdHlwZSBHZXRRdWVyeUlucHV0ID0ge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgR2V0UXVlcnlPdXRwdXQgPSB7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIENvbnZlcnNhdGlvbkhpc3RvcnlNZXNzYWdlSXRlbT47XG59O1xuXG5leHBvcnQgdHlwZSBMaXN0UXVlcnlJbnB1dCA9IHtcbiAgZmlsdGVyOiB7XG4gICAgY29udmVyc2F0aW9uSWQ6IHtcbiAgICAgIGVxOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgbGltaXQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIExpc3RRdWVyeU91dHB1dCA9IHtcbiAgZGF0YTogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7XG4gICAgICBpdGVtczogQXJyYXk8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPjtcbiAgICB9XG4gID47XG59O1xuXG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgcHJvcGVydGllcyB3ZSBoYXZlIHRvIHB1bGwuXG4gKiBVbmZvcnR1bmF0ZWx5LCBHUUwgZG9lc24ndCBzdXBwb3J0IHdpbGRjYXJkcy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtc3BlYy9pc3N1ZXMvMTI3XG4gKi9cbmNvbnN0IG1lc3NhZ2VJdGVtU2VsZWN0aW9uU2V0ID0gYFxuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uSWRcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGVkVXNlck1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIGFpQ29udGV4dFxuICAgICAgICAgICAgICAgIHJvbGVcbiAgICAgICAgICAgICAgICBjb250ZW50IHtcbiAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBieXRlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbWFnZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHQge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50IHtcbiAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAganNvblxuICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgdG9vbFVzZUlkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0b29sVXNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5gO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHJldHJpZXZpbmcgbWVzc2FnZSBoaXN0b3J5IHRoYXQgYmVsb25ncyB0byBjb252ZXJzYXRpb24gdHVybiBldmVudC5cbiAqIEl0IHF1ZXJpZXMgQXBwU3luYyB0byBsaXN0IG1lc3NhZ2VzIHRoYXQgYmVsb25nIHRvIGNvbnZlcnNhdGlvbi5cbiAqIEFkZGl0aW9uYWxseSwgaXQgbG9va3MgdXAgYSBjdXJyZW50IG1lc3NhZ2UgaW4gY2FzZSBpdCdzIG1pc3NpbmcgaW4gdGhlIGxpc3QgZHVlIHRvIGV2ZW50dWFsIGNvbnNpc3RlbmN5LlxuICovXG5leHBvcnQgY2xhc3MgQ29udmVyc2F0aW9uTWVzc2FnZUhpc3RvcnlSZXRyaWV2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBjb252ZXJzYXRpb24gbWVzc2FnZSBoaXN0b3J5IHJldHJpZXZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnQ6IENvbnZlcnNhdGlvblR1cm5FdmVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyYXBocWxSZXF1ZXN0RXhlY3V0b3IgPSBuZXcgR3JhcGhxbFJlcXVlc3RFeGVjdXRvcihcbiAgICAgIGV2ZW50LmdyYXBocWxBcGlFbmRwb2ludCxcbiAgICAgIGV2ZW50LnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uLFxuICAgICAgbmV3IFVzZXJBZ2VudFByb3ZpZGVyKGV2ZW50KSxcbiAgICApLFxuICApIHt9XG5cbiAgZ2V0TWVzc2FnZUhpc3RvcnkgPSBhc3luYyAoKTogUHJvbWlzZTxBcnJheTxDb252ZXJzYXRpb25NZXNzYWdlPj4gPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdGhpcy5saXN0TWVzc2FnZXMoKTtcblxuICAgIGxldCBjdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2VzLmZpbmQoXG4gICAgICAobSkgPT4gbS5pZCA9PT0gdGhpcy5ldmVudC5jdXJyZW50TWVzc2FnZUlkLFxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2sgaW4gY2FzZSBjdXJyZW50IG1lc3NhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgbWVzc2FnZSBsaXN0LlxuICAgIC8vIEkuZS4gaW4gYSBzaXR1YXRpb24gd2hlbiBmcmVzaGx5IHdyaXR0ZW4gbWVzc2FnZSBpcyBub3QgeWV0IHZpc2libGUgaW5cbiAgICAvLyBldmVudHVhbGx5IGNvbnNpc3RlbnQgcmVhZHMuXG4gICAgaWYgKCFjdXJyZW50TWVzc2FnZSkge1xuICAgICAgY3VycmVudE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRNZXNzYWdlKCk7XG4gICAgICBtZXNzYWdlcy5wdXNoKGN1cnJlbnRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyBJbmRleCBhc3Npc3RhbnQgbWVzc2FnZXMgYnkgY29ycmVzcG9uZGluZyB1c2VyIG1lc3NhZ2UuXG4gICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZDogTWFwPFxuICAgICAgc3RyaW5nLFxuICAgICAgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtXG4gICAgPiA9IG5ldyBNYXAoKTtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBtZXNzYWdlLmFzc29jaWF0ZWRVc2VyTWVzc2FnZUlkKSB7XG4gICAgICAgIGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuc2V0KFxuICAgICAgICAgIG1lc3NhZ2UuYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlY29uY2lsZSBoaXN0b3J5IGFuZCBpbmplY3QgYWlDb250ZXh0XG4gICAgY29uc3Qgb3JkZXJlZE1lc3NhZ2VzID0gbWVzc2FnZXMucmVkdWNlKChhY2MsIGN1cnJlbnQpID0+IHtcbiAgICAgIC8vIEJlZHJvY2sgZXhwZWN0cyB0aGF0IG1lc3NhZ2UgaGlzdG9yeSBpcyB1c2VyLT5hc3Npc3RhbnQtPnVzZXItPmFzc2lzdGFudC0+Li4uIGFuZCBzbyBvbi5cbiAgICAgIC8vIFRoZSBjaHJvbm9sb2dpY2FsIG9yZGVyIGRvZXNuJ3QgYXNzdXJlIHRoaXMgb3JkZXJpbmcgaWYgdGhlcmUgd2VyZSBhbnkgY29uY3VycmVudCBtZXNzYWdlcyBzZW50LlxuICAgICAgLy8gVGhlcmVmb3JlLCBjb252ZXJzYXRpb24gaXMgb3JkZXJlZCBieSB1c2VyJ3MgbWVzc2FnZXMgb25seSBhbmQgY29ycmVzcG9uZGluZyBhc3Npc3RhbnQgbWVzc2FnZXMgYXJlIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHJpZ2h0IHBsYWNlIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgY3JlYXRlZEF0IHZhbHVlLlxuICAgICAgLy8gVGhpcyBhbGdvcml0aG0gYXNzdW1lcyB0aGF0IEdRTCBxdWVyeSByZXR1cm5zIG1lc3NhZ2VzIHNvcnRlZCBieSBjcmVhdGVkQXQuXG4gICAgICBpZiAoY3VycmVudC5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICAvLyBJbml0aWFsbHksIHNraXAgYXNzaXN0YW50IG1lc3NhZ2VzLCB0aGVzZSBtaWdodCBiZSBvdXQgb2YgY2hyb25vbG9naWNhbCBvcmRlci5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudC5yb2xlID09PSAndXNlcicgJiZcbiAgICAgICAgIWFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuaGFzKGN1cnJlbnQuaWQpICYmXG4gICAgICAgIGN1cnJlbnQuaWQgIT09IHRoaXMuZXZlbnQuY3VycmVudE1lc3NhZ2VJZFxuICAgICAgKSB7XG4gICAgICAgIC8vIFNraXAgdXNlciBtZXNzYWdlcyB0aGF0IGRpZG4ndCBnZXQgYW5zd2VyIGZyb20gYXNzaXN0YW50IHlldC5cbiAgICAgICAgLy8gVGhlc2UgbWlnaHQgYmUgc3RpbGwgXCJpbi1mbGlnaHRcIiwgaS5lLiBhc3Npc3RhbnQgaXMgc3RpbGwgd29ya2luZyBvbiB0aGVtIGluIHNlcGFyYXRlIGludm9jYXRpb24uXG4gICAgICAgIC8vIEV4Y2VwdCBjdXJyZW50IG1lc3NhZ2UsIHdlIHdhbnQgdG8gcHJvY2VzcyB0aGF0IG9uZS5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFpQ29udGV4dCA9IGN1cnJlbnQuYWlDb250ZXh0O1xuICAgICAgY29uc3QgY29udGVudCA9IGFpQ29udGV4dFxuICAgICAgICA/IFsuLi5jdXJyZW50LmNvbnRlbnQsIHsgdGV4dDogSlNPTi5zdHJpbmdpZnkoYWlDb250ZXh0KSB9XVxuICAgICAgICA6IGN1cnJlbnQuY29udGVudDtcblxuICAgICAgYWNjLnB1c2goeyByb2xlOiBjdXJyZW50LnJvbGUsIGNvbnRlbnQgfSk7XG5cbiAgICAgIC8vIEZpbmQgYW5kIGluc2VydCBjb3JyZXNwb25kaW5nIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgICAgY29uc3QgY29ycmVzcG9uZGluZ0Fzc2lzdGFudE1lc3NhZ2UgPSBhc3Npc3RhbnRNZXNzYWdlQnlVc2VyTWVzc2FnZUlkLmdldChcbiAgICAgICAgY3VycmVudC5pZCxcbiAgICAgICk7XG4gICAgICBpZiAoY29ycmVzcG9uZGluZ0Fzc2lzdGFudE1lc3NhZ2UpIHtcbiAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgIHJvbGU6IGNvcnJlc3BvbmRpbmdBc3Npc3RhbnRNZXNzYWdlLnJvbGUsXG4gICAgICAgICAgY29udGVudDogY29ycmVzcG9uZGluZ0Fzc2lzdGFudE1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdIGFzIEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+KTtcblxuICAgIC8vIFJlbW92ZSB0b29sIHVzYWdlIGZyb20gbm9uLWN1cnJlbnQgdHVybiBhbmQgc3F1YXNoIG1lc3NhZ2VzLlxuICAgIHJldHVybiB0aGlzLnNxdWFzaE5vbkN1cnJlbnRUdXJucyhvcmRlcmVkTWVzc2FnZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdG9vbCB1c2FnZSBmcm9tIG5vbi1jdXJyZW50IHR1cm5zLlxuICAgKiBUaGUgdG9vbCB1c2FnZSBhbmQgcmVzdWx0IGJsb2NrcyBkb24ndCBtYXR0ZXIgYWZ0ZXIgYSB0dXJuIGlzIGNvbXBsZXRlZCxcbiAgICogYnV0IGRvIGNvc3QgZXh0cmEgdG9rZW5zIHRvIHByb2Nlc3MuXG4gICAqIFRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAgICogMS4gRmluZCB3aGVyZSBjdXJyZW50IHR1cm4gYmVnaW5zLiBJLmUuIGxhc3QgdXNlciBtZXNzYWdlIHRoYXQgaXNuJ3QgdG9vbCBibG9jay5cbiAgICogMi4gUmVtb3ZlIHRvb2xVc2UgYW5kIHRvb2xSZXN1bHQgYmxvY2tzIGJlZm9yZSBjdXJyZW50IHR1cm4uXG4gICAqIDMuIFNxdWFzaCBjb250aW51b3VzIHNlcXVlbmNlcyBvZiBtZXNzYWdlcyB0aGF0IGJlbG9uZyB0byBzYW1lICdtZXNzYWdlLnJvbGUnLlxuICAgKi9cbiAgcHJpdmF0ZSBzcXVhc2hOb25DdXJyZW50VHVybnMgPSAobWVzc2FnZXM6IEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+KSA9PiB7XG4gICAgY29uc3QgaXNOb25Ub29sQmxvY2tQcmVkaWNhdGUgPSAoXG4gICAgICBjb250ZW50QmxvY2s6IENvbnZlcnNhdGlvbk1lc3NhZ2VDb250ZW50QmxvY2ssXG4gICAgKSA9PiAhY29udGVudEJsb2NrLnRvb2xVc2UgJiYgIWNvbnRlbnRCbG9jay50b29sUmVzdWx0O1xuXG4gICAgLy8gZmluZCB3aGVyZSBjdXJyZW50IHR1cm4gYmVnaW5zLiBJLmUuIGxhc3QgdXNlciBtZXNzYWdlIHRoYXQgaXMgbm90IHJlbGF0ZWQgdG8gdG9vbHNcbiAgICBjb25zdCBsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPSBtZXNzYWdlcy5maW5kTGFzdEluZGV4KChtZXNzYWdlKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJyAmJiBtZXNzYWdlLmNvbnRlbnQuZmluZChpc05vblRvb2xCbG9ja1ByZWRpY2F0ZSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyBObyBub24tY3VycmVudCB0dXJucywgZG9uJ3QgdHJhbnNmb3JtLlxuICAgIGlmIChsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cblxuICAgIGNvbnN0IHNxdWFzaGVkTWVzc2FnZXM6IEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+ID0gW107XG5cbiAgICAvLyBEZWZpbmUgYSBcImJ1ZmZlclwiLiBJLmUuIGEgbWVzc2FnZSB3ZSBrZWVwIGFyb3VuZCBhbmQgc3F1YXNoIGNvbnRlbnQgb24uXG4gICAgbGV0IGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2U6IENvbnZlcnNhdGlvbk1lc3NhZ2UgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLy8gUHJvY2VzcyBtZXNzYWdlcyBiZWZvcmUgY3VycmVudCB0dXJuIGJlZ2luc1xuICAgIC8vIFJlbW92ZSB0b29sIHVzYWdlIGJsb2Nrcy5cbiAgICAvLyBDb21iaW5lIGNvbnRlbnQgZm9yIGNvbnNlY3V0aXZlIG1lc3NhZ2UgdGhhdCBoYXZlIHNhbWUgcm9sZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VSb2xlID0gY3VycmVudE1lc3NhZ2Uucm9sZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQgPSBjdXJyZW50TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgaXNOb25Ub29sQmxvY2tQcmVkaWNhdGUsXG4gICAgICApO1xuICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRvb2wgb25seSBtZXNzYWdlLiBOb3RoaW5nIHRvIHNxdWFzaCwgc2tpcDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudFNxdWFzaGVkTWVzc2FnZSkge1xuICAgICAgICAvLyBOb3RoaW5nIHNxdWFzaGVkIHlldCwgaW5pdGlhbGl6ZSB0aGUgYnVmZmVyLlxuICAgICAgICBjdXJyZW50U3F1YXNoZWRNZXNzYWdlID0ge1xuICAgICAgICAgIHJvbGU6IGN1cnJlbnRNZXNzYWdlUm9sZSxcbiAgICAgICAgICBjb250ZW50OiBjdXJyZW50TWVzc2FnZU5vblRvb2xDb250ZW50LFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3F1YXNoZWRNZXNzYWdlLnJvbGUgPT09IGN1cnJlbnRNZXNzYWdlUm9sZSkge1xuICAgICAgICAvLyBpZiByb2xlIGlzIHNhbWUgYXBwZW5kIGNvbnRlbnQuXG4gICAgICAgIGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UuY29udGVudC5wdXNoKC4uLmN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcm9sZSBmbGlwcyBwdXNoIGN1cnJlbnQgc3F1YXNoZWQgbWVzc2FnZSBhbmQgcmUtaW5pdGlhbGl6ZSB0aGUgYnVmZmVyLlxuICAgICAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goY3VycmVudFNxdWFzaGVkTWVzc2FnZSk7XG4gICAgICAgIGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgcm9sZTogY3VycmVudE1lc3NhZ2VSb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZsdXNoIHRoZSBsYXN0IGJ1ZmZlci5cbiAgICBpZiAoY3VycmVudFNxdWFzaGVkTWVzc2FnZSkge1xuICAgICAgc3F1YXNoZWRNZXNzYWdlcy5wdXNoKGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCBjdXJyZW50IHR1cm4gYXMgaXMuXG4gICAgc3F1YXNoZWRNZXNzYWdlcy5wdXNoKC4uLm1lc3NhZ2VzLnNsaWNlKGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleCkpO1xuICAgIHJldHVybiBzcXVhc2hlZE1lc3NhZ2VzO1xuICB9O1xuXG4gIHByaXZhdGUgZ2V0Q3VycmVudE1lc3NhZ2UgPVxuICAgIGFzeW5jICgpOiBQcm9taXNlPENvbnZlcnNhdGlvbkhpc3RvcnlNZXNzYWdlSXRlbT4gPT4ge1xuICAgICAgY29uc3QgcXVlcnkgPSBgXG4gICAgICAgIHF1ZXJ5IEdldE1lc3NhZ2UoJGlkOiAke3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeUlucHV0VHlwZU5hbWV9ISkge1xuICAgICAgICAgICAgJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkuZ2V0UXVlcnlOYW1lfShpZDogJGlkKSB7XG4gICAgICAgICAgICAgICR7bWVzc2FnZUl0ZW1TZWxlY3Rpb25TZXR9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBgO1xuICAgICAgY29uc3QgdmFyaWFibGVzOiBHZXRRdWVyeUlucHV0ID0ge1xuICAgICAgICBpZDogdGhpcy5ldmVudC5jdXJyZW50TWVzc2FnZUlkLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdyYXBocWxSZXF1ZXN0RXhlY3V0b3IuZXhlY3V0ZUdyYXBocWw8XG4gICAgICAgIEdldFF1ZXJ5SW5wdXQsXG4gICAgICAgIEdldFF1ZXJ5T3V0cHV0XG4gICAgICA+KHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHZhcmlhYmxlcyxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkuZ2V0UXVlcnlOYW1lXTtcbiAgICB9O1xuXG4gIHByaXZhdGUgbGlzdE1lc3NhZ2VzID0gYXN5bmMgKCk6IFByb21pc2U8XG4gICAgQXJyYXk8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPlxuICA+ID0+IHtcbiAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgcXVlcnkgTGlzdE1lc3NhZ2VzKCRmaWx0ZXI6ICR7dGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeUlucHV0VHlwZU5hbWV9ISwgJGxpbWl0OiBJbnQpIHtcbiAgICAgICAgICAgICR7dGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeU5hbWV9KGZpbHRlcjogJGZpbHRlciwgbGltaXQ6ICRsaW1pdCkge1xuICAgICAgICAgICAgICBpdGVtcyB7XG4gICAgICAgICAgICAgICAgJHttZXNzYWdlSXRlbVNlbGVjdGlvblNldH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgYDtcbiAgICBjb25zdCB2YXJpYWJsZXM6IExpc3RRdWVyeUlucHV0ID0ge1xuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIGNvbnZlcnNhdGlvbklkOiB7XG4gICAgICAgICAgZXE6IHRoaXMuZXZlbnQuY29udmVyc2F0aW9uSWQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgbGltaXQ6IHRoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5saXN0UXVlcnlMaW1pdCA/PyAxMDAwLFxuICAgIH07XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ3JhcGhxbFJlcXVlc3RFeGVjdXRvci5leGVjdXRlR3JhcGhxbDxcbiAgICAgIExpc3RRdWVyeUlucHV0LFxuICAgICAgTGlzdFF1ZXJ5T3V0cHV0XG4gICAgPih7XG4gICAgICBxdWVyeSxcbiAgICAgIHZhcmlhYmxlcyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGl0ZW1zID1cbiAgICAgIHJlc3BvbnNlLmRhdGFbdGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeU5hbWVdLml0ZW1zO1xuXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5jb250ZW50Py5mb3JFYWNoKChjb250ZW50QmxvY2spID0+IHtcbiAgICAgICAgbGV0IHByb3BlcnR5OiBrZXlvZiB0eXBlb2YgY29udGVudEJsb2NrO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIGNvbnRlbnRCbG9jaykge1xuICAgICAgICAgIC8vIERlc2VyaWFsaXphdGlvbiBvZiBHcmFwaFFsIHF1ZXJ5IHJlc3VsdCBzZXRzIHRoZXNlIHByb3BlcnRpZXMgdG8gJ251bGwnXG4gICAgICAgICAgLy8gVGhpcyBjYW4gdHJpZ2dlciBCZWRyb2NrIFNESyB2YWxpZGF0aW9uIGFzIGl0IGV4cGVjdHMgJ3VuZGVmaW5lZCcgaWYgcHJvcGVydGllcyBhcmUgbm90IHNldC5cbiAgICAgICAgICAvLyBXZSBjYW4ndCBmaXggaG93IEdyYXBoUWwgcmVzcG9uc2UgaXMgZGVzZXJpYWxpemVkLlxuICAgICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgYXBwbHkgdGhpcyB0cmFuc2Zvcm1hdGlvbiB0byBmaXggdGhlIGRhdGEuXG4gICAgICAgICAgaWYgKGNvbnRlbnRCbG9ja1twcm9wZXJ0eV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRlbnRCbG9ja1twcm9wZXJ0eV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50QmxvY2sudG9vbFVzZT8uaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gdG9vbFVzZS5pbnB1dCBtYXkgY29tZSBhcyBzZXJpYWxpemVkIEpTT04gZm9yIENsaWVudCBUb29scy5cbiAgICAgICAgICAvLyBQYXJzZSBpdCBpbiB0aGF0IGNhc2UuXG4gICAgICAgICAgY29udGVudEJsb2NrLnRvb2xVc2UuaW5wdXQgPSBKU09OLnBhcnNlKGNvbnRlbnRCbG9jay50b29sVXNlLmlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudEJsb2NrLnRvb2xSZXN1bHQ/LmNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50QmxvY2sudG9vbFJlc3VsdC5jb250ZW50LmZvckVhY2goKHRvb2xSZXN1bHRDb250ZW50QmxvY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbFJlc3VsdENvbnRlbnRCbG9jay5qc29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyB0b29sUmVzdWx0LmNvbnRlbnRbXS5qc29uIG1heSBjb21lIGFzIHNlcmlhbGl6ZWQgSlNPTiBmb3IgQ2xpZW50IFRvb2xzLlxuICAgICAgICAgICAgICAvLyBQYXJzZSBpdCBpbiB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgIHRvb2xSZXN1bHRDb250ZW50QmxvY2suanNvbiA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdENvbnRlbnRCbG9jay5qc29uLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcbn1cbiJdfQ==