{
  "version": 3,
  "sources": ["util.ts", "../../../tmp-toolkit-helpers/src/util/archive.ts", "../../../tmp-toolkit-helpers/src/util/format-error.ts", "../../../tmp-toolkit-helpers/src/util/arrays.ts", "../../../tmp-toolkit-helpers/src/util/bool.ts", "../../../tmp-toolkit-helpers/src/util/bytes.ts", "../../../tmp-toolkit-helpers/src/util/cloudformation.ts", "../../../tmp-toolkit-helpers/src/util/content-hash.ts", "../../../tmp-toolkit-helpers/src/util/directories.ts", "../../../tmp-toolkit-helpers/src/api/toolkit-error.ts", "../../../tmp-toolkit-helpers/src/util/json.ts", "../../../tmp-toolkit-helpers/src/util/types.ts", "../../../tmp-toolkit-helpers/src/util/objects.ts", "../../../tmp-toolkit-helpers/src/util/parallel.ts", "../../../tmp-toolkit-helpers/src/util/package-info.ts", "../../../tmp-toolkit-helpers/src/util/serialize.ts", "../../../tmp-toolkit-helpers/src/util/yaml-cfn.ts", "../../../tmp-toolkit-helpers/src/util/string-manipulation.ts", "../../../tmp-toolkit-helpers/src/util/type-brands.ts", "../../../tmp-toolkit-helpers/src/util/version-range.ts"],
  "sourcesContent": ["/* eslint-disable import/no-restricted-paths */\n\nexport * from '../../../tmp-toolkit-helpers/src/util';\n", "import { error } from 'console';\nimport { createWriteStream, promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as glob from 'glob';\nimport { formatErrorMessage } from './format-error';\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst archiver = require('archiver');\n\n// Adapted from cdk-assets\nexport async function zipDirectory(directory: string, outputFile: string): Promise<void> {\n  // We write to a temporary file and rename at the last moment. This is so that if we are\n  // interrupted during this process, we don't leave a half-finished file in the target location.\n  const temporaryOutputFile = `${outputFile}.${randomString()}._tmp`;\n  await writeZipFile(directory, temporaryOutputFile);\n  await moveIntoPlace(temporaryOutputFile, outputFile);\n}\n\nfunction writeZipFile(directory: string, outputFile: string): Promise<void> {\n  return new Promise(async (ok, fail) => {\n    // The below options are needed to support following symlinks when building zip files:\n    // - nodir: This will prevent symlinks themselves from being copied into the zip.\n    // - follow: This will follow symlinks and copy the files within.\n    const globOptions = {\n      dot: true,\n      nodir: true,\n      follow: true,\n      cwd: directory,\n    };\n    const files = glob.sync('**', globOptions); // The output here is already sorted\n\n    const output = createWriteStream(outputFile);\n\n    const archive = archiver('zip');\n    archive.on('warning', fail);\n    archive.on('error', fail);\n\n    // archive has been finalized and the output file descriptor has closed, resolve promise\n    // this has to be done before calling `finalize` since the events may fire immediately after.\n    // see https://www.npmjs.com/package/archiver\n    output.once('close', ok);\n\n    archive.pipe(output);\n\n    // Append files serially to ensure file order\n    for (const file of files) {\n      const fullPath = path.resolve(directory, file);\n      // Exactly 2 promises\n      // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism\n      const [data, stat] = await Promise.all([fs.readFile(fullPath), fs.stat(fullPath)]);\n      archive.append(data, {\n        name: file,\n        mode: stat.mode,\n      });\n    }\n\n    await archive.finalize();\n  });\n}\n\n/**\n * Rename the file to the target location, taking into account:\n *\n * - That we may see EPERM on Windows while an Antivirus scanner still has the\n *   file open, so retry a couple of times.\n * - This same function may be called in parallel and be interrupted at any point.\n */\nasync function moveIntoPlace(source: string, target: string) {\n  let delay = 100;\n  let attempts = 5;\n  while (true) {\n    try {\n      // 'rename' is guaranteed to overwrite an existing target, as long as it is a file (not a directory)\n      await fs.rename(source, target);\n      return;\n    } catch (e: any) {\n      if (e.code !== 'EPERM' || attempts-- <= 0) {\n        throw e;\n      }\n      error(formatErrorMessage(e));\n      await sleep(Math.floor(Math.random() * delay));\n      delay *= 2;\n    }\n  }\n}\n\nfunction sleep(ms: number) {\n  return new Promise(ok => setTimeout(ok, ms));\n}\n\nfunction randomString() {\n  return Math.random().toString(36).replace(/[^a-z0-9]+/g, '');\n}\n", "/**\n * Takes in an error and returns a correctly formatted string of its error message.\n * If it is an AggregateError, it will return a string with all the inner errors\n * formatted and separated by a newline.\n *\n * @param error The error to format\n * @returns A string with the error message(s) of the error\n */\nexport function formatErrorMessage(error: any): string {\n  if (error && Array.isArray(error.errors)) {\n    const innerMessages = error.errors\n      .map((innerError: { message: any; toString: () => any }) => (innerError?.message || innerError?.toString()))\n      .join('\\n');\n    return `AggregateError: ${innerMessages}`;\n  }\n\n  // Fallback for regular Error or other types\n  return error?.message || error?.toString() || 'Unknown error';\n}\n", "/**\n * Map a function over an array and concatenate the results\n */\nexport function flatMap<T, U>(xs: T[], fn: ((x: T, i: number) => U[])): U[] {\n  return flatten(xs.map(fn));\n}\n\n/**\n * Flatten a list of lists into a list of elements\n */\nexport function flatten<T>(xs: T[][]): T[] {\n  return Array.prototype.concat.apply([], xs);\n}\n\n/**\n * Partition a collection by removing and returning all elements that match a predicate\n *\n * Note: the input collection is modified in-place!\n */\nexport function partition<T>(collection: T[], pred: (x: T) => boolean): T[] {\n  const ret: T[] = [];\n  let i = 0;\n  while (i < collection.length) {\n    if (pred(collection[i])) {\n      ret.push(collection.splice(i, 1)[0]);\n    } else {\n      i++;\n    }\n  }\n  return ret;\n}\n", "/**\n * Converts a boolean into a number.\n *\n * @param bool input boolean\n * @returns 1 if bool is true, and 0 if false\n */\nexport function numberFromBool(bool: boolean): number {\n  return +bool;\n}\n", "/**\n * Format bytes as a human readable string\n *\n * @param bytes Number of bytes to format\n * @param decimals Number of decimal places to show (default 2)\n * @returns Formatted string with appropriate unit suffix\n */\nexport function formatBytes(bytes: number, decimals: number = 2): string {\n  decimals = decimals < 0 ? 0 : decimals;\n\n  if (bytes === 0) {\n    return '0 Bytes';\n  }\n\n  const k = 1024;\n  const sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;\n}\n", "/**\n * Validate SNS topic arn\n */\nexport function validateSnsTopicArn(arn: string): boolean {\n  return /^arn:aws:sns:[a-z0-9\\-]+:[0-9]+:[a-z0-9\\-\\_]+$/i.test(arn);\n}\n\n/**\n * Does a Stack Event have an error message based on the status.\n */\nexport function stackEventHasErrorMessage(status: string): boolean {\n  return status.endsWith('_FAILED') || status === 'ROLLBACK_IN_PROGRESS' || status === 'UPDATE_ROLLBACK_IN_PROGRESS';\n}\n\n/**\n * Calculate the maximal length of all resource types for a given template.\n *\n * @param template the stack template to analyze\n * @param startWidth the initial width to start with. Defaults to the length of 'AWS::CloudFormation::Stack'.\n * @returns the determined width\n */\nexport function maxResourceTypeLength(template: any, startWidth = 'AWS::CloudFormation::Stack'.length): number {\n  const resources = (template && template.Resources) || {};\n  let maxWidth = startWidth;\n  for (const id of Object.keys(resources)) {\n    const type = resources[id].Type || '';\n    if (type.length > maxWidth) {\n      maxWidth = type.length;\n    }\n  }\n  return maxWidth;\n}\n", "import * as crypto from 'crypto';\n\nexport function contentHash(data: string | Buffer | DataView) {\n  return crypto.createHash('sha256').update(data).digest('hex');\n}\n\n/**\n * A stably sorted hash of an arbitrary JS object\n */\nexport function contentHashAny(value: unknown) {\n  const ret = crypto.createHash('sha256');\n  recurse(value);\n  return ret.digest('hex');\n\n  function recurse(x: unknown) {\n    if (typeof x === 'string') {\n      ret.update(x);\n      return;\n    }\n\n    if (Array.isArray(x)) {\n      ret.update('[');\n      for (const e of x) {\n        recurse(e);\n        ret.update('||');\n      }\n      ret.update(']');\n      return;\n    }\n\n    if (x && typeof x === 'object') {\n      ret.update('{');\n      for (const key of Object.keys(x).sort()) {\n        ret.update(key);\n        ret.update(':');\n        recurse((x as any)[key]);\n      }\n      ret.update('}');\n      return;\n    }\n\n    ret.update(`${x}${typeof x}`); // typeof to make sure hash('123') !== hash(123)\n  }\n}\n", "import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { ToolkitError } from '../api/toolkit-error';\n\n/**\n * Return a location that will be used as the CDK home directory.\n * Currently the only thing that is placed here is the cache.\n *\n * First try to use the users home directory (i.e. /home/someuser/),\n * but if that directory does not exist for some reason create a tmp directory.\n *\n * Typically it wouldn't make sense to create a one time use tmp directory for\n * the purpose of creating a cache, but since this only applies to users that do\n * not have a home directory (some CI systems?) this should be fine.\n */\nexport function cdkHomeDir() {\n  const tmpDir = fs.realpathSync(os.tmpdir());\n  let home;\n  try {\n    let userInfoHome: string | undefined = os.userInfo().homedir;\n    // Node returns this if the user doesn't have a home directory\n    /* c8 ignore start */ // will not happen in normal setups\n    if (userInfoHome == '/var/empty') {\n      userInfoHome = undefined;\n    }\n    /* c8 ignore stop */\n    home = path.join((userInfoHome ?? os.homedir()).trim(), '.cdk');\n  } catch {\n  }\n  return process.env.CDK_HOME\n    ? path.resolve(process.env.CDK_HOME)\n    : home || fs.mkdtempSync(path.join(tmpDir, '.cdk')).trim();\n}\n\nexport function cdkCacheDir() {\n  return path.join(cdkHomeDir(), 'cache');\n}\n\n/**\n * From the start location, find the directory that contains the bundled package's package.json\n *\n * You must assume the caller of this function will be bundled and the package root dir\n * is not going to be the same as the package the caller currently lives in.\n */\nexport function bundledPackageRootDir(start: string): string;\nexport function bundledPackageRootDir(start: string, fail: true): string;\nexport function bundledPackageRootDir(start: string, fail: false): string | undefined;\nexport function bundledPackageRootDir(start: string, fail?: boolean) {\n  function _rootDir(dirname: string): string | undefined {\n    const manifestPath = path.join(dirname, 'package.json');\n    if (fs.existsSync(manifestPath)) {\n      return dirname;\n    }\n    if (path.dirname(dirname) === dirname) {\n      if (fail ?? true) {\n        throw new ToolkitError('Unable to find package manifest');\n      }\n      return undefined;\n    }\n    return _rootDir(path.dirname(dirname));\n  }\n\n  return _rootDir(start);\n}\n", "import type * as cxapi from '@aws-cdk/cx-api';\n\nconst TOOLKIT_ERROR_SYMBOL = Symbol.for('@aws-cdk/toolkit-lib.ToolkitError');\nconst AUTHENTICATION_ERROR_SYMBOL = Symbol.for('@aws-cdk/toolkit-lib.AuthenticationError');\nconst ASSEMBLY_ERROR_SYMBOL = Symbol.for('@aws-cdk/toolkit-lib.AssemblyError');\nconst CONTEXT_PROVIDER_ERROR_SYMBOL = Symbol.for('@aws-cdk/toolkit-lib.ContextProviderError');\n\n/**\n * Represents a general toolkit error in the AWS CDK Toolkit.\n */\nexport class ToolkitError extends Error {\n  /**\n   * Determines if a given error is an instance of ToolkitError.\n   */\n  public static isToolkitError(x: any): x is ToolkitError {\n    return x !== null && typeof(x) === 'object' && TOOLKIT_ERROR_SYMBOL in x;\n  }\n\n  /**\n   * Determines if a given error is an instance of AuthenticationError.\n   */\n  public static isAuthenticationError(x: any): x is AuthenticationError {\n    return this.isToolkitError(x) && AUTHENTICATION_ERROR_SYMBOL in x;\n  }\n\n  /**\n   * Determines if a given error is an instance of AssemblyError.\n   */\n  public static isAssemblyError(x: any): x is AssemblyError {\n    return this.isToolkitError(x) && ASSEMBLY_ERROR_SYMBOL in x;\n  }\n\n  /**\n   * Determines if a given error is an instance of AssemblyError.\n   */\n  public static isContextProviderError(x: any): x is ContextProviderError {\n    return this.isToolkitError(x) && CONTEXT_PROVIDER_ERROR_SYMBOL in x;\n  }\n\n  /**\n   * An AssemblyError with an original error as cause\n   */\n  public static withCause(message: string, error: unknown): ToolkitError {\n    return new ToolkitError(message, 'toolkit', error);\n  }\n\n  /**\n   * The type of the error, defaults to \"toolkit\".\n   */\n  public readonly type: string;\n\n  /**\n   * Denotes the source of the error as the toolkit.\n   */\n  public readonly source: 'toolkit' | 'user';\n\n  /**\n   * The specific original cause of the error, if available\n   */\n  public readonly cause?: unknown;\n\n  constructor(message: string, type: string = 'toolkit', cause?: unknown) {\n    super(message);\n    Object.setPrototypeOf(this, ToolkitError.prototype);\n    Object.defineProperty(this, TOOLKIT_ERROR_SYMBOL, { value: true });\n    this.name = new.target.name;\n    this.type = type;\n    this.source = 'toolkit';\n    this.cause = cause;\n  }\n}\n\n/**\n * Represents an authentication-specific error in the AWS CDK Toolkit.\n */\nexport class AuthenticationError extends ToolkitError {\n  /**\n   * Denotes the source of the error as user.\n   */\n  public readonly source = 'user';\n\n  constructor(message: string) {\n    super(message, 'authentication');\n    Object.setPrototypeOf(this, AuthenticationError.prototype);\n    Object.defineProperty(this, AUTHENTICATION_ERROR_SYMBOL, { value: true });\n  }\n}\n\n/**\n * Represents an error causes by cloud assembly synthesis\n *\n * This includes errors thrown during app execution, as well as failing annotations.\n */\nexport class AssemblyError extends ToolkitError {\n  /**\n   * An AssemblyError with an original error as cause\n   */\n  public static withCause(message: string, error: unknown): AssemblyError {\n    return new AssemblyError(message, undefined, error);\n  }\n\n  /**\n   * An AssemblyError with a list of stacks as cause\n   */\n  public static withStacks(message: string, stacks?: cxapi.CloudFormationStackArtifact[]): AssemblyError {\n    return new AssemblyError(message, stacks);\n  }\n\n  /**\n   * Denotes the source of the error as user.\n   */\n  public readonly source = 'user';\n\n  /**\n   * The stacks that caused the error, if available\n   *\n   * The `messages` property of each `cxapi.CloudFormationStackArtifact` will contain the respective errors.\n   * Absence indicates synthesis didn't fully complete.\n   */\n  public readonly stacks?: cxapi.CloudFormationStackArtifact[];\n\n  private constructor(message: string, stacks?: cxapi.CloudFormationStackArtifact[], cause?: unknown) {\n    super(message, 'assembly', cause);\n    Object.setPrototypeOf(this, AssemblyError.prototype);\n    Object.defineProperty(this, ASSEMBLY_ERROR_SYMBOL, { value: true });\n    this.stacks = stacks;\n  }\n}\n\n/**\n * Represents an error originating from a Context Provider\n */\nexport class ContextProviderError extends ToolkitError {\n  /**\n   * Denotes the source of the error as user.\n   */\n  public readonly source = 'user';\n\n  constructor(message: string) {\n    super(message, 'context-provider');\n    Object.setPrototypeOf(this, ContextProviderError.prototype);\n    Object.defineProperty(this, CONTEXT_PROVIDER_ERROR_SYMBOL, { value: true });\n  }\n}\n", "/**\n * This gets the values of the jsonObject at the paths specified in propertiesToReturn.\n *\n * For example, jsonObject = {\n *   key1: 'abc',\n *   key2: {\n *     foo: 'qwerty',\n *     bar: 'data',\n *   }\n * }\n *\n * propertiesToReturn = ['key1', 'key2.foo'];\n *\n * The returned object is:\n *\n * ```\n * {\n *   key1: 'abc',\n *   'key2.foo': 'qwerty',\n *   Identifier: identifier\n * }\n * ```\n */\nexport function getResultObj(jsonObject: any, identifier: string, propertiesToReturn: string[]): {[key: string]: any} {\n  const propsObj = {};\n  propertiesToReturn.forEach((propName) => {\n    Object.assign(propsObj, { [propName]: findJsonValue(jsonObject, propName) });\n  });\n  Object.assign(propsObj, { ['Identifier']: identifier });\n  return propsObj;\n}\n\n/**\n * This finds the value of the jsonObject at the path.  Path is delimited by '.'.\n *\n * For example, jsonObject = {\n *   key1: 'abc',\n *   key2: {\n *     foo: 'qwerty',\n *     bar: 'data',\n *   }\n * }\n *\n * If path is 'key1', then it will return 'abc'.\n * If path is 'key2.foo', then it will return 'qwerty'.\n * If path is 'key2', then it will return the object:\n * {\n *   foo: 'qwerty',\n *   bar: 'data',\n * }\n *\n * If the path is not found, an Error will be thrown stating which token is missing.\n */\nexport function findJsonValue(jsonObject: any, path: string): any {\n  const paths = path.split('.');\n  let obj = jsonObject;\n  paths.forEach(p => {\n    obj = obj[p];\n    if (obj === undefined) {\n      throw new TypeError(`Cannot read field ${path}. ${p} is not found.`);\n    }\n  });\n  return obj;\n}\n", "/**\n * Type of a map mapping strings to some arbitrary type\n *\n * Name is not ideal, but:\n *\n * - Cannot call it Object, that already means something.\n * - Cannot call it Dict or Dictionary, since in other languages\n *   those also allow specifying the key type.\n */\nexport type Obj<T> = {[key: string]: T};\n\n/**\n * Return whether the given value is an object\n *\n * Even though arrays technically are objects, we usually want to treat them differently,\n * so we return false in those cases.\n */\nexport function isObject(x: any): x is Obj<any> {\n  return x !== null && typeof x === 'object' && !isArray(x);\n}\n\n/**\n * Return whether the given value is an array\n */\nexport const isArray = Array.isArray;\n\n/**\n * Return the value of the first argument if it's not undefined, otherwise the default\n */\nexport function ifDefined<T>(x: T | undefined, def: T): T {\n  return typeof x !== 'undefined' ? x : def;\n}\n", "import type { Obj } from './types';\nimport { isArray, isObject } from './types';\nimport { ToolkitError } from '../api/toolkit-error';\n\n/**\n * Return a new object by adding missing keys into another object\n */\nexport function applyDefaults(hash: any, defaults: any) {\n  const result: any = { };\n\n  Object.keys(hash).forEach(k => result[k] = hash[k]);\n\n  Object.keys(defaults)\n    .filter(k => !(k in result))\n    .forEach(k => result[k] = defaults[k]);\n\n  return result;\n}\n\n/**\n * Return whether the given parameter is an empty object or empty list.\n */\nexport function isEmpty(x: any) {\n  if (x == null) {\n    return false;\n  }\n  if (isArray(x)) {\n    return x.length === 0;\n  }\n  return Object.keys(x).length === 0;\n}\n\n/**\n * Deep clone a tree of objects, lists or scalars\n *\n * Does not support cycles.\n */\nexport function deepClone(x: any): any {\n  if (typeof x === 'undefined') {\n    return undefined;\n  }\n  if (x === null) {\n    return null;\n  }\n  if (isArray(x)) {\n    return x.map(deepClone);\n  }\n  if (isObject(x)) {\n    return makeObject(mapObject(x, (k, v) => [k, deepClone(v)] as [string, any]));\n  }\n  return x;\n}\n\n/**\n * Map over an object, treating it as a dictionary\n */\nexport function mapObject<T, U>(x: Obj<T>, fn: (key: string, value: T) => U): U[] {\n  const ret: U[] = [];\n  Object.keys(x).forEach(key => {\n    ret.push(fn(key, x[key]));\n  });\n  return ret;\n}\n\n/**\n * Construct an object from a list of (k, v) pairs\n */\nexport function makeObject<T>(pairs: Array<[string, T]>): Obj<T> {\n  const ret: Obj<T> = {};\n  for (const pair of pairs) {\n    ret[pair[0]] = pair[1];\n  }\n  return ret;\n}\n\n/**\n * Deep get a value from a tree of nested objects\n *\n * Returns undefined if any part of the path was unset or\n * not an object.\n */\nexport function deepGet(x: any, path: string[]): any {\n  path = path.slice();\n\n  while (path.length > 0 && isObject(x)) {\n    const key = path.shift()!;\n    x = x[key];\n  }\n  return path.length === 0 ? x : undefined;\n}\n\n/**\n * Deep set a value in a tree of nested objects\n *\n * Throws an error if any part of the path is not an object.\n */\nexport function deepSet(x: any, path: string[], value: any) {\n  path = path.slice();\n\n  if (path.length === 0) {\n    throw new ToolkitError('Path may not be empty');\n  }\n\n  while (path.length > 1 && isObject(x)) {\n    const key = path.shift()!;\n\n    if (isPrototypePollutingKey(key)) {\n      continue;\n    }\n\n    if (!(key in x)) {\n      x[key] = {};\n    }\n    x = x[key];\n  }\n\n  if (!isObject(x)) {\n    throw new ToolkitError(`Expected an object, got '${x}'`);\n  }\n\n  const finalKey = path[0];\n\n  if (isPrototypePollutingKey(finalKey)) {\n    return;\n  }\n\n  if (value !== undefined) {\n    x[finalKey] = value;\n  } else {\n    delete x[finalKey];\n  }\n}\n\n/**\n * Helper to detect prototype polluting keys\n *\n * A key matching this, MUST NOT be used in an assignment.\n * Use this to check user-input.\n */\nfunction isPrototypePollutingKey(key: string) {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n}\n\n/**\n * Recursively merge objects together\n *\n * The leftmost object is mutated and returned. Arrays are not merged\n * but overwritten just like scalars.\n *\n * If an object is merged into a non-object, the non-object is lost.\n */\nexport function deepMerge(...objects: Array<Obj<any> | undefined>) {\n  function mergeOne(target: Obj<any>, source: Obj<any>) {\n    for (const key of Object.keys(source)) {\n      if (isPrototypePollutingKey(key)) {\n        continue;\n      }\n\n      const value = source[key];\n\n      if (isObject(value)) {\n        if (!isObject(target[key])) {\n          target[key] = {};\n        } // Overwrite on purpose\n        mergeOne(target[key], value);\n      } else if (typeof value !== 'undefined') {\n        target[key] = value;\n      }\n    }\n  }\n\n  const others = objects.filter(x => x != null) as Array<Obj<any>>;\n\n  if (others.length === 0) {\n    return {};\n  }\n  const into = others.splice(0, 1)[0];\n\n  others.forEach(other => mergeOne(into, other));\n  return into;\n}\n\n/**\n * Splits the given object into two, such that:\n *\n * 1. The size of the first object (after stringified in UTF-8) is less than or equal to the provided size limit.\n * 2. Merging the two objects results in the original one.\n */\nexport function splitBySize(data: any, maxSizeBytes: number): [any, any] {\n  if (maxSizeBytes < 2) {\n    // It's impossible to fit anything in the first object\n    return [undefined, data];\n  }\n  const entries = Object.entries(data);\n  return recurse(0, 0);\n\n  function recurse(index: number, runningTotalSize: number): [any, any] {\n    if (index >= entries.length) {\n      // Everything fits in the first object\n      return [data, undefined];\n    }\n\n    const size = runningTotalSize + entrySize(entries[index]);\n    return (size > maxSizeBytes) ? cutAt(index) : recurse(index + 1, size);\n  }\n\n  function entrySize(entry: [string, unknown]) {\n    return Buffer.byteLength(JSON.stringify(Object.fromEntries([entry])));\n  }\n\n  function cutAt(index: number): [any, any] {\n    return [\n      Object.fromEntries(entries.slice(0, index)),\n      Object.fromEntries(entries.slice(index)),\n    ];\n  }\n}\n\ntype Exclude = { [key: string]: Exclude | true };\n\n/**\n * This function transforms all keys (recursively) in the provided `val` object.\n *\n * @param val The object whose keys need to be transformed.\n * @param transform The function that will be applied to each key.\n * @param exclude The keys that will not be transformed and copied to output directly\n * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.\n */\nexport function transformObjectKeys(val: any, transform: (str: string) => string, exclude: Exclude = {}): any {\n  if (val == null || typeof val !== 'object') {\n    return val;\n  }\n  if (Array.isArray(val)) {\n    // For arrays we just pass parent's exclude object directly\n    // since it makes no sense to specify different exclude options for each array element\n    return val.map((input: any) => transformObjectKeys(input, transform, exclude));\n  }\n  const ret: { [k: string]: any } = {};\n  for (const [k, v] of Object.entries(val)) {\n    const childExclude = exclude[k];\n    if (childExclude === true) {\n      // we don't transform this object if the key is specified in exclude\n      ret[transform(k)] = v;\n    } else {\n      ret[transform(k)] = transformObjectKeys(v, transform, childExclude);\n    }\n  }\n  return ret;\n}\n", "/**\n * Run a number of promise generators with max parallelism\n *\n * Order is not maintained between the input and output.\n */\nexport async function parallelPromises<A>(n: number, promises: Array<() => Promise<A>>): Promise<Array<A>> {\n  const ret = new Array<A>();\n  let count = 0;\n  let error: Error | undefined;\n  const queue = [...promises];\n\n  return new Promise((ok, ko) => {\n    tick();\n\n    function tick() {\n      if (count === 0 && error) {\n        ko(error);\n        return;\n      }\n      if (count === 0 && queue.length === 0) {\n        ok(ret);\n        return;\n      }\n\n      while (count < n && queue.length > 0 && !error) {\n        const next = queue.shift();\n        if (next !== undefined) {\n          start(next);\n        }\n      }\n    }\n\n    function start(fn: () => Promise<A>) {\n      count += 1;\n      fn()\n        .then((result) => {\n          ret.push(result);\n        })\n        .catch((e) => {\n          error = e;\n        })\n        .finally(() => {\n          count -= 1;\n          tick();\n        });\n    }\n  });\n}\n", "import * as path from 'path';\nimport { bundledPackageRootDir } from './directories';\n\nexport function displayVersion() {\n  return `${versionNumber()} (build ${commit()})`;\n}\n\nexport function isDeveloperBuild(): boolean {\n  return versionNumber() === '0.0.0';\n}\n\nexport function versionNumber(): string {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  return require(path.join(bundledPackageRootDir(__dirname), 'package.json')).version.replace(/\\+[0-9a-f]+$/, '');\n}\n\nfunction commit(): string {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  return require(path.join(bundledPackageRootDir(__dirname), 'build-info.json')).commit;\n}\n", "import * as fs from 'fs/promises';\nimport { formatBytes } from './bytes';\nimport * as yaml_cfn from './yaml-cfn';\n\n/**\n * Stringify to YAML\n */\nexport function toYAML(obj: any): string {\n  return yaml_cfn.serialize(obj);\n}\n\n/**\n * Parse either YAML or JSON\n */\nexport function deserializeStructure(str: string): any {\n  return yaml_cfn.deserialize(str);\n}\n\n/**\n * Serialize to either YAML or JSON\n */\nexport function serializeStructure(object: any, json: boolean) {\n  if (json) {\n    return JSON.stringify(object, undefined, 2);\n  } else {\n    return toYAML(object);\n  }\n}\n\n/**\n * Load a YAML or JSON file from disk\n */\nexport async function loadStructuredFile(fileName: string) {\n  const contents = await fs.readFile(fileName, { encoding: 'utf-8' });\n  return deserializeStructure(contents);\n}\n\n/**\n * Remove any template elements that we don't want to show users.\n */\nexport function obscureTemplate(template: any = {}) {\n  if (template.Rules) {\n    // see https://github.com/aws/aws-cdk/issues/17942\n    if (template.Rules.CheckBootstrapVersion) {\n      if (Object.keys(template.Rules).length > 1) {\n        delete template.Rules.CheckBootstrapVersion;\n      } else {\n        delete template.Rules;\n      }\n    }\n  }\n\n  return template;\n}\n\n/**\n * Detects a buffer that has been converted to a JSON-like object\n * In Node, `Buffer`s have `toJSON()` method that converts the buffer\n * into a JS object that can be JSON stringified.\n * Unfortunately this conversion happens before the replacer is called,\n * so normal means of detecting a `Buffer` objet don't work anymore.\n * @see https://github.com/nodejs/node-v0.x-archive/issues/5110\n */\nfunction isJsonBuffer(value: any): value is {\n  type: 'Buffer';\n  data: number[];\n} {\n  return typeof value === 'object'\n    && 'type' in value\n    && value.type === 'Buffer'\n    && 'data' in value\n    && Array.isArray(value.data);\n}\n\n/**\n * A JSON.stringify() replacer that converts Buffers into a string with information\n * Use this if you plan to print out JSON stringified objects that may contain a Buffer.\n * Without this, large buffers (think: Megabytes) will completely fill up the output\n * and even crash the system.\n */\nexport function replacerBufferWithInfo(_key: any, value: any): any {\n  if (isJsonBuffer(value)) {\n    return `<Buffer: ${formatBytes(value.data.length)}>`;\n  }\n  return value;\n}\n", "import * as yaml from 'yaml';\nimport type * as yaml_cst from 'yaml/parse-cst';\nimport * as yaml_types from 'yaml/types';\n\n/**\n * Serializes the given data structure into valid YAML.\n *\n * @param obj the data structure to serialize\n * @returns a string containing the YAML representation of {@param obj}\n */\nexport function serialize(obj: any): string {\n  const oldFold = yaml_types.strOptions.fold.lineWidth;\n  try {\n    yaml_types.strOptions.fold.lineWidth = 0;\n    return yaml.stringify(obj, { schema: 'yaml-1.1' });\n  } finally {\n    yaml_types.strOptions.fold.lineWidth = oldFold;\n  }\n}\n\n/**\n * Deserialize the YAML into the appropriate data structure.\n *\n * @param str the string containing YAML\n * @returns the data structure the YAML represents\n *   (most often in case of CloudFormation, an object)\n */\nexport function deserialize(str: string): any {\n  return parseYamlStrWithCfnTags(str);\n}\n\nfunction makeTagForCfnIntrinsic(intrinsicName: string, addFnPrefix: boolean): yaml_types.Schema.CustomTag {\n  return {\n    identify(value: any) {\n      return typeof value === 'string';\n    },\n    tag: `!${intrinsicName}`,\n    resolve: (_doc: yaml.Document, cstNode: yaml_cst.CST.Node) => {\n      const ret: any = {};\n      ret[addFnPrefix ? `Fn::${intrinsicName}` : intrinsicName] =\n        // the +1 is to account for the ! the short form begins with\n        parseYamlStrWithCfnTags(cstNode.toString().substring(intrinsicName.length + 1));\n      return ret;\n    },\n  };\n}\n\nconst shortForms: yaml_types.Schema.CustomTag[] = [\n  'Base64', 'Cidr', 'FindInMap', 'GetAZs', 'ImportValue', 'Join', 'Sub',\n  'Select', 'Split', 'Transform', 'And', 'Equals', 'If', 'Not', 'Or', 'GetAtt',\n].map(name => makeTagForCfnIntrinsic(name, true)).concat(\n  makeTagForCfnIntrinsic('Ref', false),\n  makeTagForCfnIntrinsic('Condition', false),\n);\n\nfunction parseYamlStrWithCfnTags(text: string): any {\n  return yaml.parse(text, {\n    customTags: shortForms,\n    schema: 'core',\n  });\n}\n", "/**\n * Pad 's' on the left with 'char' until it is n characters wide\n */\nexport function padLeft(n: number, x: string, char: string = ' '): string {\n  return char.repeat(Math.max(0, n - x.length)) + x;\n}\n\n/**\n * Pad 's' on the right with 'char' until it is n characters wide\n */\nexport function padRight(n: number, x: string, char: string = ' '): string {\n  return x + char.repeat(Math.max(0, n - x.length));\n}\n\n/**\n * Formats time in milliseconds (which we get from 'Date.getTime()')\n * to a human-readable time; returns time in seconds rounded to 2\n * decimal places.\n */\nexport function formatTime(num: number): number {\n  return roundPercentage(millisecondsToSeconds(num));\n}\n\n/**\n * Rounds a decimal number to two decimal points.\n * The function is useful for fractions that need to be outputted as percentages.\n */\nfunction roundPercentage(num: number): number {\n  return Math.round(100 * num) / 100;\n}\n\n/**\n * Given a time in milliseconds, return an equivalent amount in seconds.\n */\nfunction millisecondsToSeconds(num: number): number {\n  return num / 1000;\n}\n\n/**\n * This function lower cases the first character of the string provided.\n */\nexport function lowerCaseFirstCharacter(str: string): string {\n  return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;\n}\n", "/**\n * Type branding\n *\n * This allows marking certain types as having gone through particular operations.\n *\n * Branded types can be used anywhere the base type is expected, but the base type\n * cannot be used where a branded type is expected; the values have to go through\n * a type assertion operation to confirm their brand.\n *\n * Usage:\n *\n * ```\n * type ValidatedString = Branded<string, 'PassedMyValidation'>;\n *\n * function validate(x: string): asserts x is ValidatedString {\n *   // ... throw an error if not\n * }\n *\n * function isValid(x: string): x is ValidatedString {\n *   // ... throw an error if not\n * }\n * ```\n */\n\n// This construct purely happens at type checking time. There is no run-time impact.\n// Hence, we never even have to construct values of this type.\ndeclare const __brand: unique symbol;\n\nexport type Brand<B> = { [__brand]: B };\nexport type Branded<T, B> = T & Brand<B>;\n\n/**\n * Marks a value as being branded a certain way.\n *\n * You should in general avoid calling this, and use validation or\n * asserting functions instead. However, this can be useful to produce\n * values which are branded by construction (really just an elaborate\n * way to write 'as').\n */\n/* c8 ignore start */\nexport function createBranded<A extends Branded<any, any>>(value: TypeUnderlyingBrand<A>): A {\n  return value as A;\n}\n/* c8 ignore stop */\n\ntype TypeUnderlyingBrand<A> = A extends Branded<infer T, any> ? T : never;\n", "import * as semver from 'semver';\nimport { ToolkitError } from '../api/toolkit-error';\n\n// bracket - https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN401\n// pep - https://www.python.org/dev/peps/pep-0440/#version-specifiers\nexport type RangeType = 'bracket' | 'pep'\n\nexport function rangeFromSemver(ver: string, targetType: RangeType) {\n  const re = ver.match(/^([^\\d]*)([\\d.]*)$/);\n  if (!re || !semver.valid(re[2])) {\n    throw new ToolkitError('not a semver or unsupported range syntax');\n  }\n  const prefixPart = re[1];\n  const verPart = re[2];\n\n  switch (targetType) {\n    case 'bracket':\n      switch (prefixPart) {\n        case '':\n          // if there's no prefix and the remaining is a valid semver, there's no range specified\n          return ver;\n        case '^':\n          return `[${verPart},${semver.major(verPart)+1}.0.0)`;\n        default:\n          throw new ToolkitError(`unsupported range syntax - ${prefixPart}`);\n      }\n    case 'pep':\n      switch (prefixPart) {\n        case '':\n          // if there's no prefix and the remaining is a valid semver, there's no range specified\n          return `==${ver}`;\n        case '^':\n          return `>=${verPart},<${semver.major(verPart)+1}.0.0`;\n        default:\n          throw new ToolkitError(`unsupported range syntax - ${prefixPart}`);\n      }\n  }\n}\n"],
  "mappings": "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",
  "names": ["error", "fs", "fs", "path", "error", "dirname", "path", "path", "error", "path", "fs"]
}
