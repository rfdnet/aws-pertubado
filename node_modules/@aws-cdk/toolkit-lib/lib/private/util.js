"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/private/util.ts
var util_exports = {};
__export(util_exports, {
  applyDefaults: () => applyDefaults,
  bundledPackageRootDir: () => bundledPackageRootDir,
  cdkCacheDir: () => cdkCacheDir,
  cdkHomeDir: () => cdkHomeDir,
  contentHash: () => contentHash,
  contentHashAny: () => contentHashAny,
  createBranded: () => createBranded,
  deepClone: () => deepClone,
  deepGet: () => deepGet,
  deepMerge: () => deepMerge,
  deepSet: () => deepSet,
  deserialize: () => deserialize,
  deserializeStructure: () => deserializeStructure,
  displayVersion: () => displayVersion,
  findJsonValue: () => findJsonValue,
  flatMap: () => flatMap,
  flatten: () => flatten,
  formatBytes: () => formatBytes,
  formatErrorMessage: () => formatErrorMessage,
  formatTime: () => formatTime,
  getResultObj: () => getResultObj,
  ifDefined: () => ifDefined,
  isArray: () => isArray,
  isDeveloperBuild: () => isDeveloperBuild,
  isEmpty: () => isEmpty,
  isObject: () => isObject,
  loadStructuredFile: () => loadStructuredFile,
  lowerCaseFirstCharacter: () => lowerCaseFirstCharacter,
  makeObject: () => makeObject,
  mapObject: () => mapObject,
  maxResourceTypeLength: () => maxResourceTypeLength,
  numberFromBool: () => numberFromBool,
  obscureTemplate: () => obscureTemplate,
  padLeft: () => padLeft,
  padRight: () => padRight,
  parallelPromises: () => parallelPromises,
  partition: () => partition,
  rangeFromSemver: () => rangeFromSemver,
  replacerBufferWithInfo: () => replacerBufferWithInfo,
  serialize: () => serialize,
  serializeStructure: () => serializeStructure,
  splitBySize: () => splitBySize,
  stackEventHasErrorMessage: () => stackEventHasErrorMessage,
  toYAML: () => toYAML,
  transformObjectKeys: () => transformObjectKeys,
  validateSnsTopicArn: () => validateSnsTopicArn,
  versionNumber: () => versionNumber,
  zipDirectory: () => zipDirectory
});
module.exports = __toCommonJS(util_exports);

// ../tmp-toolkit-helpers/src/util/archive.ts
var import_console = require("console");
var import_fs = require("fs");
var path = __toESM(require("path"));
var glob = __toESM(require("glob"));

// ../tmp-toolkit-helpers/src/util/format-error.ts
function formatErrorMessage(error2) {
  if (error2 && Array.isArray(error2.errors)) {
    const innerMessages = error2.errors.map((innerError) => innerError?.message || innerError?.toString()).join("\n");
    return `AggregateError: ${innerMessages}`;
  }
  return error2?.message || error2?.toString() || "Unknown error";
}

// ../tmp-toolkit-helpers/src/util/archive.ts
var archiver = require("archiver");
async function zipDirectory(directory, outputFile) {
  const temporaryOutputFile = `${outputFile}.${randomString()}._tmp`;
  await writeZipFile(directory, temporaryOutputFile);
  await moveIntoPlace(temporaryOutputFile, outputFile);
}
function writeZipFile(directory, outputFile) {
  return new Promise(async (ok, fail) => {
    const globOptions = {
      dot: true,
      nodir: true,
      follow: true,
      cwd: directory
    };
    const files = glob.sync("**", globOptions);
    const output = (0, import_fs.createWriteStream)(outputFile);
    const archive = archiver("zip");
    archive.on("warning", fail);
    archive.on("error", fail);
    output.once("close", ok);
    archive.pipe(output);
    for (const file of files) {
      const fullPath = path.resolve(directory, file);
      const [data, stat] = await Promise.all([import_fs.promises.readFile(fullPath), import_fs.promises.stat(fullPath)]);
      archive.append(data, {
        name: file,
        mode: stat.mode
      });
    }
    await archive.finalize();
  });
}
async function moveIntoPlace(source, target) {
  let delay = 100;
  let attempts = 5;
  while (true) {
    try {
      await import_fs.promises.rename(source, target);
      return;
    } catch (e) {
      if (e.code !== "EPERM" || attempts-- <= 0) {
        throw e;
      }
      (0, import_console.error)(formatErrorMessage(e));
      await sleep(Math.floor(Math.random() * delay));
      delay *= 2;
    }
  }
}
function sleep(ms) {
  return new Promise((ok) => setTimeout(ok, ms));
}
function randomString() {
  return Math.random().toString(36).replace(/[^a-z0-9]+/g, "");
}

// ../tmp-toolkit-helpers/src/util/arrays.ts
function flatMap(xs, fn) {
  return flatten(xs.map(fn));
}
function flatten(xs) {
  return Array.prototype.concat.apply([], xs);
}
function partition(collection, pred) {
  const ret = [];
  let i = 0;
  while (i < collection.length) {
    if (pred(collection[i])) {
      ret.push(collection.splice(i, 1)[0]);
    } else {
      i++;
    }
  }
  return ret;
}

// ../tmp-toolkit-helpers/src/util/bool.ts
function numberFromBool(bool) {
  return +bool;
}

// ../tmp-toolkit-helpers/src/util/bytes.ts
function formatBytes(bytes, decimals = 2) {
  decimals = decimals < 0 ? 0 : decimals;
  if (bytes === 0) {
    return "0 Bytes";
  }
  const k = 1024;
  const sizes = ["Bytes", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;
}

// ../tmp-toolkit-helpers/src/util/cloudformation.ts
function validateSnsTopicArn(arn) {
  return /^arn:aws:sns:[a-z0-9\-]+:[0-9]+:[a-z0-9\-\_]+$/i.test(arn);
}
function stackEventHasErrorMessage(status) {
  return status.endsWith("_FAILED") || status === "ROLLBACK_IN_PROGRESS" || status === "UPDATE_ROLLBACK_IN_PROGRESS";
}
function maxResourceTypeLength(template, startWidth = "AWS::CloudFormation::Stack".length) {
  const resources = template && template.Resources || {};
  let maxWidth = startWidth;
  for (const id of Object.keys(resources)) {
    const type = resources[id].Type || "";
    if (type.length > maxWidth) {
      maxWidth = type.length;
    }
  }
  return maxWidth;
}

// ../tmp-toolkit-helpers/src/util/content-hash.ts
var crypto = __toESM(require("crypto"));
function contentHash(data) {
  return crypto.createHash("sha256").update(data).digest("hex");
}
function contentHashAny(value) {
  const ret = crypto.createHash("sha256");
  recurse(value);
  return ret.digest("hex");
  function recurse(x) {
    if (typeof x === "string") {
      ret.update(x);
      return;
    }
    if (Array.isArray(x)) {
      ret.update("[");
      for (const e of x) {
        recurse(e);
        ret.update("||");
      }
      ret.update("]");
      return;
    }
    if (x && typeof x === "object") {
      ret.update("{");
      for (const key of Object.keys(x).sort()) {
        ret.update(key);
        ret.update(":");
        recurse(x[key]);
      }
      ret.update("}");
      return;
    }
    ret.update(`${x}${typeof x}`);
  }
}

// ../tmp-toolkit-helpers/src/util/directories.ts
var fs2 = __toESM(require("fs"));
var os = __toESM(require("os"));
var path2 = __toESM(require("path"));

// ../tmp-toolkit-helpers/src/api/toolkit-error.ts
var TOOLKIT_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ToolkitError");
var AUTHENTICATION_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AuthenticationError");
var ASSEMBLY_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AssemblyError");
var CONTEXT_PROVIDER_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ContextProviderError");
var ToolkitError = class _ToolkitError extends Error {
  /**
   * Determines if a given error is an instance of ToolkitError.
   */
  static isToolkitError(x) {
    return x !== null && typeof x === "object" && TOOLKIT_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AuthenticationError.
   */
  static isAuthenticationError(x) {
    return this.isToolkitError(x) && AUTHENTICATION_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isAssemblyError(x) {
    return this.isToolkitError(x) && ASSEMBLY_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isContextProviderError(x) {
    return this.isToolkitError(x) && CONTEXT_PROVIDER_ERROR_SYMBOL in x;
  }
  /**
   * An AssemblyError with an original error as cause
   */
  static withCause(message, error2) {
    return new _ToolkitError(message, "toolkit", error2);
  }
  /**
   * The type of the error, defaults to "toolkit".
   */
  type;
  /**
   * Denotes the source of the error as the toolkit.
   */
  source;
  /**
   * The specific original cause of the error, if available
   */
  cause;
  constructor(message, type = "toolkit", cause) {
    super(message);
    Object.setPrototypeOf(this, _ToolkitError.prototype);
    Object.defineProperty(this, TOOLKIT_ERROR_SYMBOL, { value: true });
    this.name = new.target.name;
    this.type = type;
    this.source = "toolkit";
    this.cause = cause;
  }
};

// ../tmp-toolkit-helpers/src/util/directories.ts
function cdkHomeDir() {
  const tmpDir = fs2.realpathSync(os.tmpdir());
  let home;
  try {
    let userInfoHome = os.userInfo().homedir;
    if (userInfoHome == "/var/empty") {
      userInfoHome = void 0;
    }
    home = path2.join((userInfoHome ?? os.homedir()).trim(), ".cdk");
  } catch {
  }
  return process.env.CDK_HOME ? path2.resolve(process.env.CDK_HOME) : home || fs2.mkdtempSync(path2.join(tmpDir, ".cdk")).trim();
}
function cdkCacheDir() {
  return path2.join(cdkHomeDir(), "cache");
}
function bundledPackageRootDir(start, fail) {
  function _rootDir(dirname2) {
    const manifestPath = path2.join(dirname2, "package.json");
    if (fs2.existsSync(manifestPath)) {
      return dirname2;
    }
    if (path2.dirname(dirname2) === dirname2) {
      if (fail ?? true) {
        throw new ToolkitError("Unable to find package manifest");
      }
      return void 0;
    }
    return _rootDir(path2.dirname(dirname2));
  }
  return _rootDir(start);
}

// ../tmp-toolkit-helpers/src/util/json.ts
function getResultObj(jsonObject, identifier, propertiesToReturn) {
  const propsObj = {};
  propertiesToReturn.forEach((propName) => {
    Object.assign(propsObj, { [propName]: findJsonValue(jsonObject, propName) });
  });
  Object.assign(propsObj, { ["Identifier"]: identifier });
  return propsObj;
}
function findJsonValue(jsonObject, path4) {
  const paths = path4.split(".");
  let obj = jsonObject;
  paths.forEach((p) => {
    obj = obj[p];
    if (obj === void 0) {
      throw new TypeError(`Cannot read field ${path4}. ${p} is not found.`);
    }
  });
  return obj;
}

// ../tmp-toolkit-helpers/src/util/types.ts
function isObject(x) {
  return x !== null && typeof x === "object" && !isArray(x);
}
var isArray = Array.isArray;
function ifDefined(x, def) {
  return typeof x !== "undefined" ? x : def;
}

// ../tmp-toolkit-helpers/src/util/objects.ts
function applyDefaults(hash, defaults) {
  const result = {};
  Object.keys(hash).forEach((k) => result[k] = hash[k]);
  Object.keys(defaults).filter((k) => !(k in result)).forEach((k) => result[k] = defaults[k]);
  return result;
}
function isEmpty(x) {
  if (x == null) {
    return false;
  }
  if (isArray(x)) {
    return x.length === 0;
  }
  return Object.keys(x).length === 0;
}
function deepClone(x) {
  if (typeof x === "undefined") {
    return void 0;
  }
  if (x === null) {
    return null;
  }
  if (isArray(x)) {
    return x.map(deepClone);
  }
  if (isObject(x)) {
    return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
  }
  return x;
}
function mapObject(x, fn) {
  const ret = [];
  Object.keys(x).forEach((key) => {
    ret.push(fn(key, x[key]));
  });
  return ret;
}
function makeObject(pairs) {
  const ret = {};
  for (const pair of pairs) {
    ret[pair[0]] = pair[1];
  }
  return ret;
}
function deepGet(x, path4) {
  path4 = path4.slice();
  while (path4.length > 0 && isObject(x)) {
    const key = path4.shift();
    x = x[key];
  }
  return path4.length === 0 ? x : void 0;
}
function deepSet(x, path4, value) {
  path4 = path4.slice();
  if (path4.length === 0) {
    throw new ToolkitError("Path may not be empty");
  }
  while (path4.length > 1 && isObject(x)) {
    const key = path4.shift();
    if (isPrototypePollutingKey(key)) {
      continue;
    }
    if (!(key in x)) {
      x[key] = {};
    }
    x = x[key];
  }
  if (!isObject(x)) {
    throw new ToolkitError(`Expected an object, got '${x}'`);
  }
  const finalKey = path4[0];
  if (isPrototypePollutingKey(finalKey)) {
    return;
  }
  if (value !== void 0) {
    x[finalKey] = value;
  } else {
    delete x[finalKey];
  }
}
function isPrototypePollutingKey(key) {
  return key === "__proto__" || key === "constructor" || key === "prototype";
}
function deepMerge(...objects) {
  function mergeOne(target, source) {
    for (const key of Object.keys(source)) {
      if (isPrototypePollutingKey(key)) {
        continue;
      }
      const value = source[key];
      if (isObject(value)) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        mergeOne(target[key], value);
      } else if (typeof value !== "undefined") {
        target[key] = value;
      }
    }
  }
  const others = objects.filter((x) => x != null);
  if (others.length === 0) {
    return {};
  }
  const into = others.splice(0, 1)[0];
  others.forEach((other) => mergeOne(into, other));
  return into;
}
function splitBySize(data, maxSizeBytes) {
  if (maxSizeBytes < 2) {
    return [void 0, data];
  }
  const entries = Object.entries(data);
  return recurse(0, 0);
  function recurse(index, runningTotalSize) {
    if (index >= entries.length) {
      return [data, void 0];
    }
    const size = runningTotalSize + entrySize(entries[index]);
    return size > maxSizeBytes ? cutAt(index) : recurse(index + 1, size);
  }
  function entrySize(entry) {
    return Buffer.byteLength(JSON.stringify(Object.fromEntries([entry])));
  }
  function cutAt(index) {
    return [
      Object.fromEntries(entries.slice(0, index)),
      Object.fromEntries(entries.slice(index))
    ];
  }
}
function transformObjectKeys(val, transform, exclude = {}) {
  if (val == null || typeof val !== "object") {
    return val;
  }
  if (Array.isArray(val)) {
    return val.map((input) => transformObjectKeys(input, transform, exclude));
  }
  const ret = {};
  for (const [k, v] of Object.entries(val)) {
    const childExclude = exclude[k];
    if (childExclude === true) {
      ret[transform(k)] = v;
    } else {
      ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
    }
  }
  return ret;
}

// ../tmp-toolkit-helpers/src/util/parallel.ts
async function parallelPromises(n, promises) {
  const ret = new Array();
  let count = 0;
  let error2;
  const queue = [...promises];
  return new Promise((ok, ko) => {
    tick();
    function tick() {
      if (count === 0 && error2) {
        ko(error2);
        return;
      }
      if (count === 0 && queue.length === 0) {
        ok(ret);
        return;
      }
      while (count < n && queue.length > 0 && !error2) {
        const next = queue.shift();
        if (next !== void 0) {
          start(next);
        }
      }
    }
    function start(fn) {
      count += 1;
      fn().then((result) => {
        ret.push(result);
      }).catch((e) => {
        error2 = e;
      }).finally(() => {
        count -= 1;
        tick();
      });
    }
  });
}

// ../tmp-toolkit-helpers/src/util/package-info.ts
var path3 = __toESM(require("path"));
function displayVersion() {
  return `${versionNumber()} (build ${commit()})`;
}
function isDeveloperBuild() {
  return versionNumber() === "0.0.0";
}
function versionNumber() {
  return require(path3.join(bundledPackageRootDir(__dirname), "package.json")).version.replace(/\+[0-9a-f]+$/, "");
}
function commit() {
  return require(path3.join(bundledPackageRootDir(__dirname), "build-info.json")).commit;
}

// ../tmp-toolkit-helpers/src/util/serialize.ts
var fs3 = __toESM(require("fs/promises"));

// ../tmp-toolkit-helpers/src/util/yaml-cfn.ts
var yaml = __toESM(require("yaml"));
var yaml_types = __toESM(require("yaml/types"));
function serialize(obj) {
  const oldFold = yaml_types.strOptions.fold.lineWidth;
  try {
    yaml_types.strOptions.fold.lineWidth = 0;
    return yaml.stringify(obj, { schema: "yaml-1.1" });
  } finally {
    yaml_types.strOptions.fold.lineWidth = oldFold;
  }
}
function deserialize(str) {
  return parseYamlStrWithCfnTags(str);
}
function makeTagForCfnIntrinsic(intrinsicName, addFnPrefix) {
  return {
    identify(value) {
      return typeof value === "string";
    },
    tag: `!${intrinsicName}`,
    resolve: (_doc, cstNode) => {
      const ret = {};
      ret[addFnPrefix ? `Fn::${intrinsicName}` : intrinsicName] = // the +1 is to account for the ! the short form begins with
      parseYamlStrWithCfnTags(cstNode.toString().substring(intrinsicName.length + 1));
      return ret;
    }
  };
}
var shortForms = [
  "Base64",
  "Cidr",
  "FindInMap",
  "GetAZs",
  "ImportValue",
  "Join",
  "Sub",
  "Select",
  "Split",
  "Transform",
  "And",
  "Equals",
  "If",
  "Not",
  "Or",
  "GetAtt"
].map((name) => makeTagForCfnIntrinsic(name, true)).concat(
  makeTagForCfnIntrinsic("Ref", false),
  makeTagForCfnIntrinsic("Condition", false)
);
function parseYamlStrWithCfnTags(text) {
  return yaml.parse(text, {
    customTags: shortForms,
    schema: "core"
  });
}

// ../tmp-toolkit-helpers/src/util/serialize.ts
function toYAML(obj) {
  return serialize(obj);
}
function deserializeStructure(str) {
  return deserialize(str);
}
function serializeStructure(object, json) {
  if (json) {
    return JSON.stringify(object, void 0, 2);
  } else {
    return toYAML(object);
  }
}
async function loadStructuredFile(fileName) {
  const contents = await fs3.readFile(fileName, { encoding: "utf-8" });
  return deserializeStructure(contents);
}
function obscureTemplate(template = {}) {
  if (template.Rules) {
    if (template.Rules.CheckBootstrapVersion) {
      if (Object.keys(template.Rules).length > 1) {
        delete template.Rules.CheckBootstrapVersion;
      } else {
        delete template.Rules;
      }
    }
  }
  return template;
}
function isJsonBuffer(value) {
  return typeof value === "object" && "type" in value && value.type === "Buffer" && "data" in value && Array.isArray(value.data);
}
function replacerBufferWithInfo(_key, value) {
  if (isJsonBuffer(value)) {
    return `<Buffer: ${formatBytes(value.data.length)}>`;
  }
  return value;
}

// ../tmp-toolkit-helpers/src/util/string-manipulation.ts
function padLeft(n, x, char = " ") {
  return char.repeat(Math.max(0, n - x.length)) + x;
}
function padRight(n, x, char = " ") {
  return x + char.repeat(Math.max(0, n - x.length));
}
function formatTime(num) {
  return roundPercentage(millisecondsToSeconds(num));
}
function roundPercentage(num) {
  return Math.round(100 * num) / 100;
}
function millisecondsToSeconds(num) {
  return num / 1e3;
}
function lowerCaseFirstCharacter(str) {
  return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}

// ../tmp-toolkit-helpers/src/util/type-brands.ts
function createBranded(value) {
  return value;
}

// ../tmp-toolkit-helpers/src/util/version-range.ts
var semver = __toESM(require("semver"));
function rangeFromSemver(ver, targetType) {
  const re = ver.match(/^([^\d]*)([\d.]*)$/);
  if (!re || !semver.valid(re[2])) {
    throw new ToolkitError("not a semver or unsupported range syntax");
  }
  const prefixPart = re[1];
  const verPart = re[2];
  switch (targetType) {
    case "bracket":
      switch (prefixPart) {
        case "":
          return ver;
        case "^":
          return `[${verPart},${semver.major(verPart) + 1}.0.0)`;
        default:
          throw new ToolkitError(`unsupported range syntax - ${prefixPart}`);
      }
    case "pep":
      switch (prefixPart) {
        case "":
          return `==${ver}`;
        case "^":
          return `>=${verPart},<${semver.major(verPart) + 1}.0.0`;
        default:
          throw new ToolkitError(`unsupported range syntax - ${prefixPart}`);
      }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  applyDefaults,
  bundledPackageRootDir,
  cdkCacheDir,
  cdkHomeDir,
  contentHash,
  contentHashAny,
  createBranded,
  deepClone,
  deepGet,
  deepMerge,
  deepSet,
  deserialize,
  deserializeStructure,
  displayVersion,
  findJsonValue,
  flatMap,
  flatten,
  formatBytes,
  formatErrorMessage,
  formatTime,
  getResultObj,
  ifDefined,
  isArray,
  isDeveloperBuild,
  isEmpty,
  isObject,
  loadStructuredFile,
  lowerCaseFirstCharacter,
  makeObject,
  mapObject,
  maxResourceTypeLength,
  numberFromBool,
  obscureTemplate,
  padLeft,
  padRight,
  parallelPromises,
  partition,
  rangeFromSemver,
  replacerBufferWithInfo,
  serialize,
  serializeStructure,
  splitBySize,
  stackEventHasErrorMessage,
  toYAML,
  transformObjectKeys,
  validateSnsTopicArn,
  versionNumber,
  zipDirectory
});
//# sourceMappingURL=util.js.map
