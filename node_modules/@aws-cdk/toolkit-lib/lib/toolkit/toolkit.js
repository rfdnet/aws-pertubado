"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.Toolkit = void 0;
require("../private/dispose-polyfill");
const path = require("node:path");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const non_interactive_io_host_1 = require("./non-interactive-io-host");
const private_1 = require("./private");
const bootstrap_1 = require("../actions/bootstrap");
const deploy_1 = require("../actions/deploy");
const private_2 = require("../actions/deploy/private");
const private_3 = require("../actions/diff/private");
const private_4 = require("../actions/watch/private");
const aws_auth_1 = require("../api/aws-auth");
const cloud_assembly_1 = require("../api/cloud-assembly");
const private_5 = require("../api/cloud-assembly/private");
const private_6 = require("../api/io/private");
const shared_private_1 = require("../api/shared-private");
const shared_public_1 = require("../api/shared-public");
const util_1 = require("../private/util");
const concurrency_1 = require("../util/concurrency");
const promises_1 = require("../util/promises");
/**
 * The AWS CDK Programmatic Toolkit
 */
class Toolkit extends private_5.CloudAssemblySourceBuilder {
    props;
    /**
     * The toolkit stack name used for bootstrapping resources.
     */
    toolkitStackName;
    /**
     * The IoHost of this Toolkit
     */
    ioHost;
    /**
     * The plugin host for loading and managing plugins
     */
    pluginHost;
    /**
     * Cache of the internal SDK Provider instance
     */
    sdkProviderCache;
    baseCredentials;
    constructor(props = {}) {
        super();
        this.props = props;
        this.toolkitStackName = props.toolkitStackName ?? shared_private_1.DEFAULT_TOOLKIT_STACK_NAME;
        this.pluginHost = props.pluginHost ?? new shared_public_1.PluginHost();
        let ioHost = props.ioHost ?? new non_interactive_io_host_1.NonInteractiveIoHost();
        if (props.emojis === false) {
            ioHost = (0, private_6.withoutEmojis)(ioHost);
        }
        if (props.color === false) {
            ioHost = (0, private_6.withoutColor)(ioHost);
        }
        // After removing emojis and color, we might end up with floating whitespace at either end of the message
        // This also removes newlines that we currently emit for CLI backwards compatibility.
        this.ioHost = (0, private_6.withTrimmedWhitespace)(ioHost);
        if (props.sdkConfig?.profile && props.sdkConfig?.baseCredentials) {
            throw new shared_private_1.ToolkitError('Specify at most one of \'sdkConfig.profile\' and \'sdkConfig.baseCredentials\'');
        }
        this.baseCredentials = props.sdkConfig?.baseCredentials ?? aws_auth_1.BaseCredentials.awsCliCompatible({ profile: props.sdkConfig?.profile });
    }
    /**
     * Access to the AWS SDK
     * @internal
     */
    async sdkProvider(action) {
        // @todo this needs to be different instance per action
        if (!this.sdkProviderCache) {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
            const services = {
                ioHelper,
                requestHandler: await (0, shared_private_1.makeRequestHandler)(ioHelper, this.props.sdkConfig?.httpOptions),
                logger: (0, private_6.asSdkLogger)(ioHelper),
                pluginHost: this.pluginHost,
            };
            const config = await this.baseCredentials.makeSdkConfig(services);
            this.sdkProviderCache = new shared_private_1.SdkProvider(config.credentialProvider, config.defaultRegion, services);
        }
        return this.sdkProviderCache;
    }
    /**
     * Helper to provide the CloudAssemblySourceBuilder with required toolkit services
     * @internal
     */
    async sourceBuilderServices() {
        return {
            ioHelper: (0, shared_private_1.asIoHelper)(this.ioHost, 'assembly'),
            sdkProvider: await this.sdkProvider('assembly'),
            pluginHost: this.pluginHost,
        };
    }
    /**
     * Bootstrap Action
     */
    async bootstrap(environments, options) {
        const startTime = Date.now();
        const results = [];
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'bootstrap');
        const bootstrapEnvironments = await environments.getEnvironments(this.ioHost);
        const source = options.source ?? bootstrap_1.BootstrapSource.default();
        const parameters = options.parameters;
        const bootstrapper = new shared_private_1.Bootstrapper(source, ioHelper);
        const sdkProvider = await this.sdkProvider('bootstrap');
        const limit = (0, concurrency_1.pLimit)(20);
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        await Promise.all(bootstrapEnvironments.map((environment, currentIdx) => limit(async () => {
            const bootstrapSpan = await ioHelper.span(private_6.SPAN.BOOTSTRAP_SINGLE)
                .begin(`${chalk.bold(environment.name)}: bootstrapping...`, {
                total: bootstrapEnvironments.length,
                current: currentIdx + 1,
                environment,
            });
            try {
                const bootstrapResult = await bootstrapper.bootstrapEnvironment(environment, sdkProvider, {
                    ...options,
                    toolkitStackName: this.toolkitStackName,
                    source,
                    parameters: parameters?.parameters,
                    usePreviousParameters: parameters?.keepExistingParameters,
                });
                const message = bootstrapResult.noOp
                    ? ` ✅  ${environment.name} (no changes)`
                    : ` ✅  ${environment.name}`;
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I9900.msg(chalk.green('\n' + message), { environment }));
                const envTime = await bootstrapSpan.end();
                const result = {
                    environment,
                    status: bootstrapResult.noOp ? 'no-op' : 'success',
                    duration: envTime.asMs,
                };
                results.push(result);
            }
            catch (e) {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E9900.msg(`\n ❌  ${chalk.bold(environment.name)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw e;
            }
        })));
        return {
            environments: results,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Synth Action
     *
     * The caller assumes ownership of the `CachedCloudAssembly` and is responsible for calling `dispose()` on
     * it after use.
     */
    async synth(cx, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'synth');
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        // NOTE: NOT 'await using' because we return ownership to the caller
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        const stacks = await assembly.selectStacksV2(selectStacks);
        const autoValidateStacks = options.validateStacks ? [assembly.selectStacksForValidation()] : [];
        await this.validateStacksMetadata(stacks.concat(...autoValidateStacks), ioHelper);
        await synthSpan.end();
        // if we have a single stack, print it to STDOUT
        const message = `Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`;
        const assemblyData = {
            assemblyDirectory: stacks.assembly.directory,
            stacksCount: stacks.stackCount,
            stackIds: stacks.hierarchicalIds,
        };
        if (stacks.stackCount === 1) {
            const firstStack = stacks.firstStack;
            const template = firstStack.template;
            const obscuredTemplate = (0, util_1.obscureTemplate)(template);
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I1901.msg(message, {
                ...assemblyData,
                stack: {
                    stackName: firstStack.stackName,
                    hierarchicalId: firstStack.hierarchicalId,
                    template,
                    stringifiedJson: (0, util_1.serializeStructure)(obscuredTemplate, true),
                    stringifiedYaml: (0, util_1.serializeStructure)(obscuredTemplate, false),
                },
            }));
        }
        else {
            // not outputting template to stdout, let's explain things to the user a little bit...
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I1902.msg(chalk.green(message), assemblyData));
            await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_INFO.msg(`Supply a stack id (${stacks.stackArtifacts.map((s) => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`));
        }
        return new cloud_assembly_1.CachedCloudAssembly(assembly);
    }
    /**
     * Diff Action
     */
    async diff(cx, options) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'diff');
            const selectStacks = options.stacks ?? private_5.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_1, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            const stacks = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const diffSpan = await ioHelper.span(private_6.SPAN.DIFF_STACK).begin({ stacks: selectStacks });
            const deployments = await this.deploymentsForAction('diff');
            const strict = !!options.strict;
            const contextLines = options.contextLines || 3;
            let diffs = 0;
            let formattedSecurityDiff = '';
            let formattedStackDiff = '';
            const templateInfos = await (0, private_3.makeTemplateInfos)(ioHelper, stacks, deployments, await this.sdkProvider('diff'), options);
            const templateDiffs = {};
            for (const templateInfo of templateInfos) {
                const formatter = new shared_private_1.DiffFormatter({
                    ioHelper,
                    templateInfo,
                });
                if (options.securityOnly) {
                    const securityDiff = formatter.formatSecurityDiff({
                        requireApproval: shared_private_1.RequireApproval.BROADENING,
                    });
                    formattedSecurityDiff = securityDiff.formattedDiff ?? '';
                    diffs = securityDiff.formattedDiff ? diffs + 1 : diffs;
                }
                else {
                    const diff = formatter.formatStackDiff({
                        strict,
                        context: contextLines,
                    });
                    formattedStackDiff = diff.formattedDiff;
                    diffs = diff.numStacksWithChanges;
                }
                (0, private_3.appendObject)(templateDiffs, formatter.diffs);
            }
            await diffSpan.end(`✨ Number of stacks with differences: ${diffs}`, {
                formattedSecurityDiff,
                formattedStackDiff,
            });
            return templateDiffs;
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            const result_1 = __disposeResources(env_1);
            if (result_1)
                await result_1;
        }
    }
    /**
     * List Action
     *
     * List selected stacks and their dependencies
     */
    async list(cx, options = {}) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'list');
            const selectStacks = options.stacks ?? private_5.ALL_STACKS;
            const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
            const assembly = __addDisposableResource(env_2, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            const stackCollection = await assembly.selectStacksV2(selectStacks);
            await synthSpan.end();
            const stacks = stackCollection.withDependencies();
            const message = stacks.map(s => s.id).join('\n');
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I2901.msg(message, { stacks }));
            return stacks;
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            const result_2 = __disposeResources(env_2);
            if (result_2)
                await result_2;
        }
    }
    /**
     * Deploy Action
     *
     * Deploys the selected stacks into an AWS account
     */
    async deploy(cx, options = {}) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'deploy');
            const assembly = __addDisposableResource(env_3, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._deploy(assembly, 'deploy', options);
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            const result_3 = __disposeResources(env_3);
            if (result_3)
                await result_3;
        }
    }
    /**
     * Helper to allow deploy being called as part of the watch action.
     */
    async _deploy(assembly, action, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const selectStacks = options.stacks ?? private_5.ALL_STACKS;
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: selectStacks });
        const stackCollection = await assembly.selectStacksV2(selectStacks);
        await this.validateStacksMetadata(stackCollection, ioHelper);
        const synthDuration = await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stackCollection.stackCount === 0) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E5001.msg('This app contains no stacks'));
            return ret;
        }
        const deployments = await this.deploymentsForAction('deploy');
        const migrator = new shared_private_1.ResourceMigrator({ deployments, ioHelper });
        await migrator.tryMigrateResources(stackCollection, options);
        const parameterMap = (0, private_2.buildParameterMap)(options.parameters?.parameters);
        const hotswapMode = options.hotswap ?? shared_private_1.HotswapMode.FULL_DEPLOYMENT;
        if (hotswapMode !== shared_private_1.HotswapMode.FULL_DEPLOYMENT) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5400.msg([
                '⚠️ The --hotswap and --hotswap-fallback flags deliberately introduce CloudFormation drift to speed up deployments',
                '⚠️ They should only be used for development - never use them for your production Stacks!',
            ].join('\n')));
        }
        const stacks = stackCollection.stackArtifacts;
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        const buildAsset = async (assetNode) => {
            const buildAssetSpan = await ioHelper.span(private_6.SPAN.BUILD_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.buildSingleAsset(assetNode.assetManifestArtifact, assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
            });
            await buildAssetSpan.end();
        };
        const publishAsset = async (assetNode) => {
            const publishAssetSpan = await ioHelper.span(private_6.SPAN.PUBLISH_ASSET).begin({
                asset: assetNode.asset,
            });
            await deployments.publishSingleAsset(assetNode.assetManifest, assetNode.asset, {
                stack: assetNode.parentStack,
                roleArn: options.roleArn,
                stackName: assetNode.parentStack.stackName,
                forcePublish: options.forceAssetPublishing,
            });
            await publishAssetSpan.end();
        };
        const deployStack = async (stackNode) => {
            const stack = stackNode.stack;
            if (stackCollection.stackCount !== 1) {
                await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.bold(stack.displayName)));
            }
            if (!stack.environment) {
                throw new shared_private_1.ToolkitError(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            // The generated stack has no resources
            if (Object.keys(stack.template.Resources || {}).length === 0) {
                // stack is empty and doesn't exist => do nothing
                const stackExists = await deployments.stackExists({ stack });
                if (!stackExists) {
                    return ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5021.msg(`${chalk.bold(stack.displayName)}: stack has no resources, skipping deployment.`));
                }
                // stack is empty, but exists => delete
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_W5022.msg(`${chalk.bold(stack.displayName)}: stack has no resources, deleting existing stack.`));
                await this._destroy(assembly, 'deploy', {
                    stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                    roleArn: options.roleArn,
                });
                return;
            }
            const currentTemplate = await deployments.readCurrentTemplate(stack);
            const permissionChangeType = (0, private_3.determinePermissionType)(currentTemplate, stack);
            const deployMotivation = '"--require-approval" is enabled and stack includes security-sensitive updates.';
            const deployQuestion = `${deployMotivation}\nDo you wish to deploy these changes`;
            const deployConfirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5060.req(deployQuestion, {
                motivation: deployMotivation,
                concurrency,
                permissionChangeType,
            }));
            if (!deployConfirmed) {
                throw new shared_private_1.ToolkitError('Aborted by user');
            }
            // Following are the same semantics we apply with respect to Notification ARNs (dictated by the SDK)
            //
            //  - undefined  =>  cdk ignores it, as if it wasn't supported (allows external management).
            //  - []:        =>  cdk manages it, and the user wants to wipe it out.
            //  - ['arn-1']  =>  cdk manages it, and the user wants to set it to ['arn-1'].
            const notificationArns = (!!options.notificationArns || !!stack.notificationArns)
                ? (options.notificationArns ?? []).concat(stack.notificationArns ?? [])
                : undefined;
            for (const notificationArn of notificationArns ?? []) {
                if (!(0, util_1.validateSnsTopicArn)(notificationArn)) {
                    throw new shared_private_1.ToolkitError(`Notification arn ${notificationArn} is not a valid arn for an SNS topic`);
                }
            }
            const stackIndex = stacks.indexOf(stack) + 1;
            const deploySpan = await ioHelper.span(private_6.SPAN.DEPLOY_STACK)
                .begin(`${chalk.bold(stack.displayName)}: deploying... [${stackIndex}/${stackCollection.stackCount}]`, {
                total: stackCollection.stackCount,
                current: stackIndex,
                stack,
            });
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = (0, shared_private_1.tagsForStack)(stack);
            }
            let deployDuration;
            try {
                let deployResult;
                let rollback = options.rollback;
                let iteration = 0;
                while (!deployResult) {
                    if (++iteration > 2) {
                        throw new shared_private_1.ToolkitError('This loop should have stabilized in 2 iterations, but didn\'t. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose');
                    }
                    const r = await deployments.deployStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                        toolkitStackName: this.toolkitStackName,
                        reuseAssets: options.reuseAssets,
                        notificationArns,
                        tags,
                        deploymentMethod: options.deploymentMethod,
                        forceDeployment: options.forceDeployment,
                        parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                        usePreviousParameters: options.parameters?.keepExistingParameters,
                        rollback,
                        hotswap: hotswapMode,
                        extraUserAgent: options.extraUserAgent,
                        hotswapPropertyOverrides: options.hotswapProperties ? (0, private_2.createHotswapPropertyOverrides)(options.hotswapProperties) : undefined,
                        assetParallelism: options.assetParallelism,
                    });
                    switch (r.type) {
                        case 'did-deploy-stack':
                            deployResult = r;
                            break;
                        case 'failpaused-need-rollback-first': {
                            const motivation = r.reason === 'replacement'
                                ? `Stack is in a paused fail state (${r.status}) and change includes a replacement which cannot be deployed with "--no-rollback"`
                                : `Stack is in a paused fail state (${r.status}) and command line arguments do not include "--no-rollback"`;
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new shared_private_1.ToolkitError('Aborted by user');
                            }
                            // Perform a rollback
                            await this._rollback(assembly, action, {
                                stacks: { patterns: [stack.hierarchicalId], strategy: cloud_assembly_1.StackSelectionStrategy.PATTERN_MUST_MATCH_SINGLE },
                                orphanFailedResources: options.orphanFailedResourcesDuringRollback,
                            });
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        case 'replacement-requires-rollback': {
                            const motivation = 'Change includes a replacement which cannot be deployed with "--no-rollback"';
                            const question = `${motivation}. Perform a regular deployment`;
                            const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I5050.req(question, {
                                motivation,
                                concurrency,
                            }));
                            if (!confirmed) {
                                throw new shared_private_1.ToolkitError('Aborted by user');
                            }
                            // Go around through the 'while' loop again but switch rollback to true.
                            rollback = true;
                            break;
                        }
                        default:
                            throw new shared_private_1.ToolkitError(`Unexpected result type from deployStack: ${JSON.stringify(r)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose`);
                    }
                }
                const message = deployResult.noOp
                    ? ` ✅  ${stack.displayName} (no changes)`
                    : ` ✅  ${stack.displayName}`;
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5900.msg(chalk.green('\n' + message), deployResult));
                deployDuration = await deploySpan.timing(private_6.IO.CDK_TOOLKIT_I5000);
                if (Object.keys(deployResult.outputs).length > 0) {
                    const buffer = ['Outputs:'];
                    stackOutputs[stack.stackName] = deployResult.outputs;
                    for (const name of Object.keys(deployResult.outputs).sort()) {
                        const value = deployResult.outputs[name];
                        buffer.push(`${chalk.cyan(stack.id)}.${chalk.cyan(name)} = ${chalk.underline(chalk.cyan(value))}`);
                    }
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5901.msg(buffer.join('\n')));
                }
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5901.msg(`Stack ARN:\n${deployResult.stackArn}`));
                ret.stacks.push({
                    stackName: stack.stackName,
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackArn: deployResult.stackArn,
                    outputs: deployResult.outputs,
                    hierarchicalId: stack.hierarchicalId,
                });
            }
            catch (e) {
                // It has to be exactly this string because an integration test tests for
                // "bold(stackname) failed: ResourceNotReady: <error>"
                throw new shared_private_1.ToolkitError([`❌  ${chalk.bold(stack.stackName)} failed:`, ...(e.name ? [`${e.name}:`] : []), e.message].join(' '));
            }
            finally {
                if (options.traceLogs) {
                    // deploy calls that originate from watch will come with their own cloudWatchLogMonitor
                    const cloudWatchLogMonitor = options.cloudWatchLogMonitor ?? new shared_private_1.CloudWatchLogEventMonitor({ ioHelper });
                    const foundLogGroupsResult = await (0, shared_private_1.findCloudWatchLogGroups)(await this.sdkProvider('deploy'), ioHelper, stack);
                    cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5031.msg(`The following log groups are added: ${foundLogGroupsResult.logGroupNames}`));
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            const duration = synthDuration.asMs + (deployDuration?.asMs ?? 0);
            await deploySpan.end(`\n✨  Total time: ${(0, util_1.formatTime)(duration)}s\n`, { duration });
        };
        const assetBuildTime = options.assetBuildTime ?? deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const prebuildAssets = assetBuildTime === deploy_1.AssetBuildTime.ALL_BEFORE_DEPLOY;
        const concurrency = options.concurrency || 1;
        const stacksAndTheirAssetManifests = stacks.flatMap((stack) => [
            stack,
            ...stack.dependencies.filter(x => cxapi.AssetManifestArtifact.isAssetManifestArtifact(x)),
        ]);
        const workGraph = new shared_private_1.WorkGraphBuilder(ioHelper, prebuildAssets).build(stacksAndTheirAssetManifests);
        // Unless we are running with '--force', skip already published assets
        if (!options.forceAssetPublishing) {
            await (0, private_2.removePublishedAssetsFromWorkGraph)(workGraph, deployments, options);
        }
        const graphConcurrency = {
            'stack': concurrency,
            'asset-build': 1, // This will be CPU-bound/memory bound, mostly matters for Docker builds
            'asset-publish': (options.assetParallelism ?? true) ? 8 : 1, // This will be I/O-bound, 8 in parallel seems reasonable
        };
        await workGraph.doParallel(graphConcurrency, {
            deployStack,
            buildAsset,
            publishAsset,
        });
        return ret;
    }
    /**
     * Watch Action
     *
     * Continuously observe project files and deploy the selected stacks
     * automatically when changes are detected.  Implies hotswap deployments.
     *
     * This function returns immediately, starting a watcher in the background.
     */
    async watch(cx, options) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'watch');
            const assembly = __addDisposableResource(env_4, await (0, private_1.assemblyFromSource)(ioHelper, cx, false), true);
            const rootDir = options.watchDir ?? process.cwd();
            if (options.include === undefined && options.exclude === undefined) {
                throw new shared_private_1.ToolkitError("Cannot use the 'watch' command without specifying at least one directory to monitor. " +
                    'Make sure to add a "watch" key to your cdk.json');
            }
            // For the "include" subkey under the "watch" key, the behavior is:
            // 1. No "watch" setting? We error out.
            // 2. "watch" setting without an "include" key? We default to observing "./**".
            // 3. "watch" setting with an empty "include" key? We default to observing "./**".
            // 4. Non-empty "include" key? Just use the "include" key.
            const watchIncludes = (0, private_4.patternsArrayForWatch)(options.include, {
                rootDir,
                returnRootDirIfEmpty: true,
            });
            // For the "exclude" subkey under the "watch" key,
            // the behavior is to add some default excludes in addition to the ones specified by the user:
            // 1. The CDK output directory.
            // 2. Any file whose name starts with a dot.
            // 3. Any directory's content whose name starts with a dot.
            // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
            const outdir = assembly.directory;
            const watchExcludes = (0, private_4.patternsArrayForWatch)(options.exclude, {
                rootDir,
                returnRootDirIfEmpty: false,
            });
            // only exclude the outdir if it is under the rootDir
            const relativeOutDir = path.relative(rootDir, outdir);
            if (Boolean(relativeOutDir && !relativeOutDir.startsWith('..' + path.sep) && !path.isAbsolute(relativeOutDir))) {
                watchExcludes.push(`${relativeOutDir}/**`);
            }
            watchExcludes.push('**/.*', '**/.*/**', '**/node_modules/**');
            // Print some debug information on computed settings
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5310.msg([
                `root directory used for 'watch' is: ${rootDir}`,
                `'include' patterns for 'watch': ${JSON.stringify(watchIncludes)}`,
                `'exclude' patterns for 'watch': ${JSON.stringify(watchExcludes)}`,
            ].join('\n'), {
                watchDir: rootDir,
                includes: watchIncludes,
                excludes: watchExcludes,
            }));
            let latch = 'pre-ready';
            const cloudWatchLogMonitor = options.traceLogs ? new shared_private_1.CloudWatchLogEventMonitor({ ioHelper }) : undefined;
            const deployAndWatch = async () => {
                latch = 'deploying';
                await cloudWatchLogMonitor?.deactivate();
                await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                // If latch is still 'deploying' after the 'await', that's fine,
                // but if it's 'queued', that means we need to deploy again
                while (latch === 'queued') {
                    // TypeScript doesn't realize latch can change between 'awaits',
                    // and thinks the above 'while' condition is always 'false' without the cast
                    latch = 'deploying';
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5315.msg("Detected file changes during deployment. Invoking 'cdk deploy' again"));
                    await this.invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor);
                }
                latch = 'open';
                await cloudWatchLogMonitor?.activate();
            };
            const watcher = chokidar
                .watch(watchIncludes, {
                ignored: watchExcludes,
                cwd: rootDir,
            })
                .on('ready', async () => {
                latch = 'open';
                await ioHelper.notify(private_6.IO.DEFAULT_TOOLKIT_DEBUG.msg("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment"));
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5314.msg("Triggering initial 'cdk deploy'"));
                await deployAndWatch();
            })
                .on('all', async (event, filePath) => {
                const watchEvent = {
                    event,
                    path: filePath,
                };
                if (latch === 'pre-ready') {
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5311.msg(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '${filePath}' for changes`, watchEvent));
                }
                else if (latch === 'open') {
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5312.msg(`Detected change to '${filePath}' (type: ${event}). Triggering 'cdk deploy'`, watchEvent));
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I5313.msg(`Detected change to '${filePath}' (type: ${event}) while 'cdk deploy' is still running. Will queue for another deployment after this one finishes'`, watchEvent));
                }
            });
            const stoppedPromise = (0, promises_1.promiseWithResolvers)();
            return {
                async dispose() {
                    await watcher.close();
                    // Prevents Node from staying alive. There is no 'end' event that the watcher emits
                    // that we can know it's definitely done, so best we can do is tell it to stop watching,
                    // stop keeping Node alive, and then pretend that's everything we needed to do.
                    watcher.unref();
                    stoppedPromise.resolve();
                    return stoppedPromise.promise;
                },
                async waitForEnd() {
                    return stoppedPromise.promise;
                },
                async [Symbol.asyncDispose]() {
                    return this.dispose();
                },
            };
        }
        catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
        }
        finally {
            const result_4 = __disposeResources(env_4);
            if (result_4)
                await result_4;
        }
    }
    /**
     * Rollback Action
     *
     * Rolls back the selected stacks.
     */
    async rollback(cx, options) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'rollback');
            const assembly = __addDisposableResource(env_5, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._rollback(assembly, 'rollback', options);
        }
        catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
        }
        finally {
            const result_5 = __disposeResources(env_5);
            if (result_5)
                await result_5;
        }
    }
    /**
     * Helper to allow rollback being called as part of the deploy or watch action.
     */
    async _rollback(assembly, action, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: options.stacks });
        const stacks = await assembly.selectStacksV2(options.stacks);
        await this.validateStacksMetadata(stacks, ioHelper);
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        if (stacks.stackCount === 0) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E6001.msg('No stacks selected'));
            return ret;
        }
        let anyRollbackable = false;
        for (const [index, stack] of stacks.stackArtifacts.entries()) {
            const rollbackSpan = await ioHelper.span(private_6.SPAN.ROLLBACK_STACK).begin(`Rolling back ${chalk.bold(stack.displayName)}`, {
                total: stacks.stackCount,
                current: index + 1,
                stack,
            });
            const deployments = await this.deploymentsForAction('rollback');
            try {
                const stackResult = await deployments.rollbackStack({
                    stack,
                    roleArn: options.roleArn,
                    toolkitStackName: this.toolkitStackName,
                    orphanFailedResources: options.orphanFailedResources,
                    validateBootstrapStackVersion: options.validateBootstrapStackVersion,
                    orphanLogicalIds: options.orphanLogicalIds,
                });
                if (!stackResult.notInRollbackableState) {
                    anyRollbackable = true;
                }
                await rollbackSpan.end();
                ret.stacks.push({
                    environment: {
                        account: stack.environment.account,
                        region: stack.environment.region,
                    },
                    stackName: stack.stackName,
                    stackArn: stackResult.stackArn,
                    result: stackResult.notInRollbackableState ? 'already-stable' : 'rolled-back',
                });
            }
            catch (e) {
                await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E6900.msg(`\n ❌  ${chalk.bold(stack.displayName)} failed: ${(0, util_1.formatErrorMessage)(e)}`, { error: e }));
                throw shared_private_1.ToolkitError.withCause('Rollback failed (use --force to orphan failing resources)', e);
            }
        }
        if (!anyRollbackable) {
            throw new shared_private_1.ToolkitError('No stacks were in a state that could be rolled back');
        }
        return ret;
    }
    /**
     * Refactor Action. Moves resources from one location (stack + logical ID) to another.
     */
    async refactor(cx, options = {}) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'refactor');
        const assembly = await (0, private_1.assemblyFromSource)(ioHelper, cx);
        return this._refactor(assembly, ioHelper, options);
    }
    async _refactor(assembly, ioHelper, options = {}) {
        if (!options.dryRun) {
            throw new shared_private_1.ToolkitError('Refactor is not available yet. Too see the proposed changes, use the --dry-run flag.');
        }
        const strategy = options.stacks?.strategy ?? cloud_assembly_1.StackSelectionStrategy.ALL_STACKS;
        if (strategy !== cloud_assembly_1.StackSelectionStrategy.ALL_STACKS) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_W8010.msg('Refactor does not yet support stack selection. Proceeding with the default behavior (considering all stacks).'));
        }
        const stacks = await assembly.selectStacksV2(private_5.ALL_STACKS);
        const sdkProvider = await this.sdkProvider('refactor');
        const movements = await (0, shared_private_1.findResourceMovements)(stacks.stackArtifacts, sdkProvider);
        const ambiguous = (0, shared_private_1.ambiguousMovements)(movements);
        if (ambiguous.length === 0) {
            const typedMappings = (0, shared_private_1.resourceMappings)(movements).map(m => m.toTypedMapping());
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I8900.msg((0, shared_private_1.formatTypedMappings)(typedMappings), {
                typedMappings,
            }));
        }
        else {
            const error = new shared_private_1.AmbiguityError(ambiguous);
            const paths = error.paths();
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I8900.msg((0, shared_private_1.formatAmbiguousMappings)(paths), {
                ambiguousPaths: paths,
            }));
        }
    }
    /**
     * Destroy Action
     *
     * Destroys the selected Stacks.
     */
    async destroy(cx, options) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
            const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, 'destroy');
            const assembly = __addDisposableResource(env_6, await (0, private_1.assemblyFromSource)(ioHelper, cx), true);
            return await this._destroy(assembly, 'destroy', options);
        }
        catch (e_6) {
            env_6.error = e_6;
            env_6.hasError = true;
        }
        finally {
            const result_6 = __disposeResources(env_6);
            if (result_6)
                await result_6;
        }
    }
    /**
     * Helper to allow destroy being called as part of the deploy action.
     */
    async _destroy(assembly, action, options) {
        const ioHelper = (0, shared_private_1.asIoHelper)(this.ioHost, action);
        const synthSpan = await ioHelper.span(private_6.SPAN.SYNTH_ASSEMBLY).begin({ stacks: options.stacks });
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        const stacks = (await assembly.selectStacksV2(options.stacks)).reversed();
        await synthSpan.end();
        const ret = {
            stacks: [],
        };
        const motivation = 'Destroying stacks is an irreversible action';
        const question = `Are you sure you want to delete: ${chalk.red(stacks.hierarchicalIds.join(', '))}`;
        const confirmed = await ioHelper.requestResponse(private_6.IO.CDK_TOOLKIT_I7010.req(question, { motivation }));
        if (!confirmed) {
            await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E7010.msg('Aborted by user'));
            return ret;
        }
        const destroySpan = await ioHelper.span(private_6.SPAN.DESTROY_ACTION).begin({
            stacks: stacks.stackArtifacts,
        });
        try {
            for (const [index, stack] of stacks.stackArtifacts.entries()) {
                try {
                    const singleDestroySpan = await ioHelper.span(private_6.SPAN.DESTROY_STACK)
                        .begin(chalk.green(`${chalk.blue(stack.displayName)}: destroying... [${index + 1}/${stacks.stackCount}]`), {
                        total: stacks.stackCount,
                        current: index + 1,
                        stack,
                    });
                    const deployments = await this.deploymentsForAction(action);
                    const result = await deployments.destroyStack({
                        stack,
                        deployName: stack.stackName,
                        roleArn: options.roleArn,
                    });
                    ret.stacks.push({
                        environment: {
                            account: stack.environment.account,
                            region: stack.environment.region,
                        },
                        stackName: stack.stackName,
                        stackArn: result.stackArn,
                        stackExisted: result.stackArn !== undefined,
                    });
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_I7900.msg(chalk.green(`\n ✅  ${chalk.blue(stack.displayName)}: ${action}ed`), stack));
                    await singleDestroySpan.end();
                }
                catch (e) {
                    await ioHelper.notify(private_6.IO.CDK_TOOLKIT_E7900.msg(`\n ❌  ${chalk.blue(stack.displayName)}: ${action} failed ${e}`, { error: e }));
                    throw e;
                }
            }
            return ret;
        }
        finally {
            await destroySpan.end();
        }
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    async validateStacksMetadata(stacks, ioHost) {
        const builder = (level) => {
            switch (level) {
                case 'error': return private_6.IO.CDK_ASSEMBLY_E9999;
                case 'warn': return private_6.IO.CDK_ASSEMBLY_W9999;
                default: return private_6.IO.CDK_ASSEMBLY_I9999;
            }
        };
        await stacks.validateMetadata(this.props.assemblyFailureAt, async (level, msg) => ioHost.notify(builder(level).msg(`[${level} at ${msg.id}] ${msg.entry.data}`, msg)));
    }
    /**
     * Create a deployments class
     */
    async deploymentsForAction(action) {
        return new shared_private_1.Deployments({
            sdkProvider: await this.sdkProvider(action),
            toolkitStackName: this.toolkitStackName,
            ioHelper: (0, shared_private_1.asIoHelper)(this.ioHost, action),
        });
    }
    async invokeDeployFromWatch(assembly, options, cloudWatchLogMonitor) {
        // watch defaults hotswap to enabled
        const hotswap = options.hotswap ?? shared_private_1.HotswapMode.HOTSWAP_ONLY;
        const deployOptions = {
            ...options,
            cloudWatchLogMonitor,
            hotswap,
            extraUserAgent: `cdk-watch/hotswap-${hotswap === shared_private_1.HotswapMode.FULL_DEPLOYMENT ? 'off' : 'on'}`,
        };
        try {
            await this._deploy(assembly, 'watch', deployOptions);
        }
        catch {
            // just continue - deploy will show the error
        }
    }
}
exports.Toolkit = Toolkit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRvb2xraXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVDQUFxQztBQUNyQyxrQ0FBa0M7QUFFbEMseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CLHVFQUFpRTtBQUVqRSx1Q0FBK0M7QUFRL0Msb0RBQXVEO0FBQ3ZELDhDQUF1RTtBQUN2RSx1REFLbUM7QUFHbkMscURBQWtIO0FBTWxILHNEQUFpRTtBQUNqRSw4Q0FBa0U7QUFFbEUsMERBQW9GO0FBRXBGLDJEQUF1RjtBQUV2RiwrQ0FBOEc7QUFXOUcsMERBc0IrQjtBQUUvQix3REFBa0Q7QUFDbEQsMENBTXlCO0FBQ3pCLHFEQUE2QztBQUM3QywrQ0FBd0Q7QUF3RHhEOztHQUVHO0FBQ0gsTUFBYSxPQUFRLFNBQVEsb0NBQTBCO0lBdUJqQjtJQXRCcEM7O09BRUc7SUFDYSxnQkFBZ0IsQ0FBUztJQUV6Qzs7T0FFRztJQUNhLE1BQU0sQ0FBVTtJQUVoQzs7T0FFRztJQUNhLFVBQVUsQ0FBYTtJQUV2Qzs7T0FFRztJQUNLLGdCQUFnQixDQUFlO0lBRS9CLGVBQWUsQ0FBa0I7SUFFekMsWUFBb0MsUUFBd0IsRUFBRTtRQUM1RCxLQUFLLEVBQUUsQ0FBQztRQUQwQixVQUFLLEdBQUwsS0FBSyxDQUFxQjtRQUU1RCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixJQUFJLDJDQUEwQixDQUFDO1FBRTdFLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLFVBQVUsSUFBSSxJQUFJLDBCQUFVLEVBQUUsQ0FBQztRQUV2RCxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxJQUFJLElBQUksOENBQW9CLEVBQUUsQ0FBQztRQUN4RCxJQUFJLEtBQUssQ0FBQyxN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QUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0I7WUFDdkMsUUFBUSxFQUFFLElBQUEsMkJBQVUsRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztTQUMxQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sS0FBSyxDQUFDLHFCQUFxQixDQUNqQyxRQUF1QixFQUN2QixPQUFxQixFQUNyQixvQkFBZ0Q7UUFFaEQsb0NBQW9DO1FBQ3BDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksNEJBQVcsQ0FBQyxZQUFZLENBQUM7UUFDNUQsTUFBTSxhQUFhLEdBQTBCO1lBQzNDLEdBQUcsT0FBTztZQUNWLG9CQUFvQjtZQUNwQixPQUFPO1lBQ1AsY0FBYyxFQUFFLHFCQUFxQixPQUFPLEtBQUssNEJBQVcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFO1NBQzlGLENBQUM7UUFFRixJQUFJLENBQUM7WUFDSCxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztRQUN2RCxDQUFDO1FBQUMsTUFBTSxDQUFDO1lBQ1AsNkNBQTZDO1FBQy9DLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUEvOEJELDBCQSs4QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3ByaXZhdGUvZGlzcG9zZS1wb2x5ZmlsbCc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgdHlwZSB7IFRlbXBsYXRlRGlmZiB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIGNob2tpZGFyIGZyb20gJ2Nob2tpZGFyJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IE5vbkludGVyYWN0aXZlSW9Ib3N0IH0gZnJvbSAnLi9ub24taW50ZXJhY3RpdmUtaW8taG9zdCc7XG5pbXBvcnQgdHlwZSB7IFRvb2xraXRTZXJ2aWNlcyB9IGZyb20gJy4vcHJpdmF0ZSc7XG5pbXBvcnQgeyBhc3NlbWJseUZyb21Tb3VyY2UgfSBmcm9tICcuL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3lSZXN1bHQsIERlc3Ryb3lSZXN1bHQsIFJvbGxiYWNrUmVzdWx0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEJvb3RzdHJhcEVudmlyb25tZW50cyxcbiAgQm9vdHN0cmFwT3B0aW9ucyxcbiAgQm9vdHN0cmFwUmVzdWx0LFxuICBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdCxcbn0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU291cmNlIH0gZnJvbSAnLi4vYWN0aW9ucy9ib290c3RyYXAnO1xuaW1wb3J0IHsgQXNzZXRCdWlsZFRpbWUsIHR5cGUgRGVwbG95T3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvZGVwbG95JztcbmltcG9ydCB7XG4gIGJ1aWxkUGFyYW1ldGVyTWFwLFxuICBjcmVhdGVIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gIHR5cGUgRXh0ZW5kZWREZXBsb3lPcHRpb25zLFxuICByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoLFxufSBmcm9tICcuLi9hY3Rpb25zL2RlcGxveS9wcml2YXRlJztcbmltcG9ydCB7IHR5cGUgRGVzdHJveU9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2Rlc3Ryb3knO1xuaW1wb3J0IHR5cGUgeyBEaWZmT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvZGlmZic7XG5pbXBvcnQgeyBhcHBlbmRPYmplY3QsIGRldGVybWluZVBlcm1pc3Npb25UeXBlLCBtYWtlVGVtcGxhdGVJbmZvcyBhcyBwcmVwYXJlRGlmZiB9IGZyb20gJy4uL2FjdGlvbnMvZGlmZi9wcml2YXRlJztcbmltcG9ydCB7IHR5cGUgTGlzdE9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL2xpc3QnO1xuaW1wb3J0IHR5cGUgeyBSZWZhY3Rvck9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3JlZmFjdG9yJztcbmltcG9ydCB7IHR5cGUgUm9sbGJhY2tPcHRpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy9yb2xsYmFjayc7XG5pbXBvcnQgeyB0eXBlIFN5bnRoT3B0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMvc3ludGgnO1xuaW1wb3J0IHR5cGUgeyBXYXRjaE9wdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zL3dhdGNoJztcbmltcG9ydCB7IHBhdHRlcm5zQXJyYXlGb3JXYXRjaCB9IGZyb20gJy4uL2FjdGlvbnMvd2F0Y2gvcHJpdmF0ZSc7XG5pbXBvcnQgeyBCYXNlQ3JlZGVudGlhbHMsIHR5cGUgU2RrQ29uZmlnIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkQXNzZW1ibHlTb3VyY2UgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHsgQ2FjaGVkQ2xvdWRBc3NlbWJseSwgU3RhY2tTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseSc7XG5pbXBvcnQgdHlwZSB7IFN0YWNrQXNzZW1ibHkgfSBmcm9tICcuLi9hcGkvY2xvdWQtYXNzZW1ibHkvcHJpdmF0ZSc7XG5pbXBvcnQgeyBBTExfU1RBQ0tTLCBDbG91ZEFzc2VtYmx5U291cmNlQnVpbGRlciB9IGZyb20gJy4uL2FwaS9jbG91ZC1hc3NlbWJseS9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgSUlvSG9zdCwgSW9NZXNzYWdlTGV2ZWwgfSBmcm9tICcuLi9hcGkvaW8nO1xuaW1wb3J0IHsgYXNTZGtMb2dnZXIsIElPLCBTUEFOLCB3aXRob3V0Q29sb3IsIHdpdGhvdXRFbW9qaXMsIHdpdGhUcmltbWVkV2hpdGVzcGFjZSB9IGZyb20gJy4uL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB0eXBlIHtcbiAgQXNzZXRCdWlsZE5vZGUsXG4gIEFzc2V0UHVibGlzaE5vZGUsXG4gIENvbmN1cnJlbmN5LFxuICBJb0hlbHBlcixcbiAgU3RhY2tDb2xsZWN0aW9uLFxuICBTdGFja05vZGUsXG4gIFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdCxcbiAgU2RrUHJvdmlkZXJTZXJ2aWNlcyxcbn0gZnJvbSAnLi4vYXBpL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7XG4gIFNka1Byb3ZpZGVyLFxuICBBbWJpZ3VpdHlFcnJvcixcbiAgYW1iaWd1b3VzTW92ZW1lbnRzLFxuICBhc0lvSGVscGVyLFxuICBCb290c3RyYXBwZXIsXG4gIENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsXG4gIERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FLFxuICBEZXBsb3ltZW50cyxcbiAgRGlmZkZvcm1hdHRlcixcbiAgZmluZFJlc291cmNlTW92ZW1lbnRzLFxuICBmaW5kQ2xvdWRXYXRjaExvZ0dyb3VwcyxcbiAgZm9ybWF0QW1iaWd1b3VzTWFwcGluZ3MsXG4gIGZvcm1hdFR5cGVkTWFwcGluZ3MsXG4gIEhvdHN3YXBNb2RlLFxuICBSZXF1aXJlQXBwcm92YWwsXG4gIFJlc291cmNlTWlncmF0b3IsXG4gIHRhZ3NGb3JTdGFjayxcbiAgVG9vbGtpdEVycm9yLFxuICByZXNvdXJjZU1hcHBpbmdzLFxuICBXb3JrR3JhcGhCdWlsZGVyLFxuICBtYWtlUmVxdWVzdEhhbmRsZXIsXG59IGZyb20gJy4uL2FwaS9zaGFyZWQtcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IEFzc2VtYmx5RGF0YSwgU3RhY2tEZXRhaWxzLCBUb29sa2l0QWN0aW9uIH0gZnJvbSAnLi4vYXBpL3NoYXJlZC1wdWJsaWMnO1xuaW1wb3J0IHsgUGx1Z2luSG9zdCB9IGZyb20gJy4uL2FwaS9zaGFyZWQtcHVibGljJztcbmltcG9ydCB7XG4gIGZvcm1hdEVycm9yTWVzc2FnZSxcbiAgZm9ybWF0VGltZSxcbiAgb2JzY3VyZVRlbXBsYXRlLFxuICBzZXJpYWxpemVTdHJ1Y3R1cmUsXG4gIHZhbGlkYXRlU25zVG9waWNBcm4sXG59IGZyb20gJy4uL3ByaXZhdGUvdXRpbCc7XG5pbXBvcnQgeyBwTGltaXQgfSBmcm9tICcuLi91dGlsL2NvbmN1cnJlbmN5JztcbmltcG9ydCB7IHByb21pc2VXaXRoUmVzb2x2ZXJzIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbGtpdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIElvSG9zdCBpbXBsZW1lbnRhdGlvbiwgaGFuZGxpbmcgdGhlIGlubGluZSBpbnRlcmFjdGlvbnMgYmV0d2VlbiB0aGUgVG9vbGtpdCBhbmQgYW4gaW50ZWdyYXRpb24uXG4gICAqL1xuICByZWFkb25seSBpb0hvc3Q/OiBJSW9Ib3N0O1xuXG4gIC8qKlxuICAgKiBBbGxvdyBlbW9qaXMgaW4gbWVzc2FnZXMgc2VudCB0byB0aGUgSW9Ib3N0LlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBlbW9qaXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFsbG93IEFOU0kgY29sb3JzIGFuZCBmb3JtYXR0aW5nIGluIElvSG9zdCBtZXNzYWdlcy5cbiAgICogU2V0dGluZyB0aGlzIHZhbHVlIHRvIGBmYWxzZWAgZW5mb3JjZXMgdGhhdCBubyBjb2xvciBvciBzdHlsZSBzaG93cyB1cFxuICAgKiBpbiBtZXNzYWdlcyBzZW50IHRvIHRoZSBJb0hvc3QuXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB0byB0cnVlIGlzIGEgbm8tb3A7IGl0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGRlZmF1bHQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGV0ZWN0cyBjb2xvciBmcm9tIHRoZSBUVFkgc3RhdHVzIG9mIHRoZSBJb0hvc3RcbiAgICovXG4gIHJlYWRvbmx5IGNvbG9yPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgU0RLLlxuICAgKi9cbiAgcmVhZG9ubHkgc2RrQ29uZmlnPzogU2RrQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSB0b29sa2l0IHN0YWNrIHRvIGJlIHVzZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IFwiQ0RLVG9vbGtpdFwiXG4gICAqL1xuICByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGYWlsIENsb3VkIEFzc2VtYmxpZXNcbiAgICpcbiAgICogQGRlZmF1bHQgXCJlcnJvclwiXG4gICAqL1xuICByZWFkb25seSBhc3NlbWJseUZhaWx1cmVBdD86ICdlcnJvcicgfCAnd2FybicgfCAnbm9uZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBwbHVnaW4gaG9zdCB0byB1c2UgZm9yIGxvYWRpbmcgYW5kIHF1ZXJ5aW5nIHBsdWdpbnNcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgYSBwbHVnaW4gbWFuYWdpbmcgY2xhc3Mgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBVc2UgYHRvb2xraXQucGx1Z2luSG9zdC5sb2FkKClgIHRvIGxvYWQgcGx1Z2lucyBpbnRvIHRoZSBwbHVnaW4gaG9zdCBmcm9tIGRpc2suXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQSBmcmVzaCBwbHVnaW4gaG9zdFxuICAgKi9cbiAgcmVhZG9ubHkgcGx1Z2luSG9zdD86IFBsdWdpbkhvc3Q7XG59XG5cbi8qKlxuICogVGhlIEFXUyBDREsgUHJvZ3JhbW1hdGljIFRvb2xraXRcbiAqL1xuZXhwb3J0IGNsYXNzIFRvb2xraXQgZXh0ZW5kcyBDbG91ZEFzc2VtYmx5U291cmNlQnVpbGRlciB7XG4gIC8qKlxuICAgKiBUaGUgdG9vbGtpdCBzdGFjayBuYW1lIHVzZWQgZm9yIGJvb3RzdHJhcHBpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElvSG9zdCBvZiB0aGlzIFRvb2xraXRcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBpb0hvc3Q6IElJb0hvc3Q7XG5cbiAgLyoqXG4gICAqIFRoZSBwbHVnaW4gaG9zdCBmb3IgbG9hZGluZyBhbmQgbWFuYWdpbmcgcGx1Z2luc1xuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBsdWdpbkhvc3Q6IFBsdWdpbkhvc3Q7XG5cbiAgLyoqXG4gICAqIENhY2hlIG9mIHRoZSBpbnRlcm5hbCBTREsgUHJvdmlkZXIgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgc2RrUHJvdmlkZXJDYWNoZT86IFNka1Byb3ZpZGVyO1xuXG4gIHByaXZhdGUgYmFzZUNyZWRlbnRpYWxzOiBCYXNlQ3JlZGVudGlhbHM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IFRvb2xraXRPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudG9vbGtpdFN0YWNrTmFtZSA9IHByb3BzLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG5cbiAgICB0aGlzLnBsdWdpbkhvc3QgPSBwcm9wcy5wbHVnaW5Ib3N0ID8/IG5ldyBQbHVnaW5Ib3N0KCk7XG5cbiAgICBsZXQgaW9Ib3N0ID0gcHJvcHMuaW9Ib3N0ID8/IG5ldyBOb25JbnRlcmFjdGl2ZUlvSG9zdCgpO1xuICAgIGlmIChwcm9wcy5lbW9qaXMgPT09IGZhbHNlKSB7XG4gICAgICBpb0hvc3QgPSB3aXRob3V0RW1vamlzKGlvSG9zdCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgIGlvSG9zdCA9IHdpdGhvdXRDb2xvcihpb0hvc3QpO1xuICAgIH1cbiAgICAvLyBBZnRlciByZW1vdmluZyBlbW9qaXMgYW5kIGNvbG9yLCB3ZSBtaWdodCBlbmQgdXAgd2l0aCBmbG9hdGluZyB3aGl0ZXNwYWNlIGF0IGVpdGhlciBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgICAvLyBUaGlzIGFsc28gcmVtb3ZlcyBuZXdsaW5lcyB0aGF0IHdlIGN1cnJlbnRseSBlbWl0IGZvciBDTEkgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdGhpcy5pb0hvc3QgPSB3aXRoVHJpbW1lZFdoaXRlc3BhY2UoaW9Ib3N0KTtcblxuICAgIGlmIChwcm9wcy5zZGtDb25maWc/LnByb2ZpbGUgJiYgcHJvcHMuc2RrQ29uZmlnPy5iYXNlQ3JlZGVudGlhbHMpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1NwZWNpZnkgYXQgbW9zdCBvbmUgb2YgXFwnc2RrQ29uZmlnLnByb2ZpbGVcXCcgYW5kIFxcJ3Nka0NvbmZpZy5iYXNlQ3JlZGVudGlhbHNcXCcnKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlQ3JlZGVudGlhbHMgPSBwcm9wcy5zZGtDb25maWc/LmJhc2VDcmVkZW50aWFscyA/PyBCYXNlQ3JlZGVudGlhbHMuYXdzQ2xpQ29tcGF0aWJsZSh7IHByb2ZpbGU6IHByb3BzLnNka0NvbmZpZz8ucHJvZmlsZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdG8gdGhlIEFXUyBTREtcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgc2RrUHJvdmlkZXIoYWN0aW9uOiBUb29sa2l0QWN0aW9uKTogUHJvbWlzZTxTZGtQcm92aWRlcj4ge1xuICAgIC8vIEB0b2RvIHRoaXMgbmVlZHMgdG8gYmUgZGlmZmVyZW50IGluc3RhbmNlIHBlciBhY3Rpb25cbiAgICBpZiAoIXRoaXMuc2RrUHJvdmlkZXJDYWNoZSkge1xuICAgICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgICAgY29uc3Qgc2VydmljZXM6IFNka1Byb3ZpZGVyU2VydmljZXMgPSB7XG4gICAgICAgIGlvSGVscGVyLFxuICAgICAgICByZXF1ZXN0SGFuZGxlcjogYXdhaXQgbWFrZVJlcXVlc3RIYW5kbGVyKGlvSGVscGVyLCB0aGlzLnByb3BzLnNka0NvbmZpZz8uaHR0cE9wdGlvbnMpLFxuICAgICAgICBsb2dnZXI6IGFzU2RrTG9nZ2VyKGlvSGVscGVyKSxcbiAgICAgICAgcGx1Z2luSG9zdDogdGhpcy5wbHVnaW5Ib3N0LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5iYXNlQ3JlZGVudGlhbHMubWFrZVNka0NvbmZpZyhzZXJ2aWNlcyk7XG4gICAgICB0aGlzLnNka1Byb3ZpZGVyQ2FjaGUgPSBuZXcgU2RrUHJvdmlkZXIoY29uZmlnLmNyZWRlbnRpYWxQcm92aWRlciwgY29uZmlnLmRlZmF1bHRSZWdpb24sIHNlcnZpY2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZGtQcm92aWRlckNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBwcm92aWRlIHRoZSBDbG91ZEFzc2VtYmx5U291cmNlQnVpbGRlciB3aXRoIHJlcXVpcmVkIHRvb2xraXQgc2VydmljZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXN5bmMgc291cmNlQnVpbGRlclNlcnZpY2VzKCk6IFByb21pc2U8VG9vbGtpdFNlcnZpY2VzPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlvSGVscGVyOiBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnYXNzZW1ibHknKSxcbiAgICAgIHNka1Byb3ZpZGVyOiBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdhc3NlbWJseScpLFxuICAgICAgcGx1Z2luSG9zdDogdGhpcy5wbHVnaW5Ib3N0LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQm9vdHN0cmFwIEFjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGJvb3RzdHJhcChlbnZpcm9ubWVudHM6IEJvb3RzdHJhcEVudmlyb25tZW50cywgb3B0aW9uczogQm9vdHN0cmFwT3B0aW9ucyk6IFByb21pc2U8Qm9vdHN0cmFwUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXN1bHRzOiBFbnZpcm9ubWVudEJvb3RzdHJhcFJlc3VsdFtdID0gW107XG5cbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdib290c3RyYXAnKTtcbiAgICBjb25zdCBib290c3RyYXBFbnZpcm9ubWVudHMgPSBhd2FpdCBlbnZpcm9ubWVudHMuZ2V0RW52aXJvbm1lbnRzKHRoaXMuaW9Ib3N0KTtcbiAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSA/PyBCb290c3RyYXBTb3VyY2UuZGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBvcHRpb25zLnBhcmFtZXRlcnM7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVyID0gbmV3IEJvb3RzdHJhcHBlcihzb3VyY2UsIGlvSGVscGVyKTtcbiAgICBjb25zdCBzZGtQcm92aWRlciA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2Jvb3RzdHJhcCcpO1xuICAgIGNvbnN0IGxpbWl0ID0gcExpbWl0KDIwKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGJvb3RzdHJhcEVudmlyb25tZW50cy5tYXAoKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgY3VycmVudElkeCkgPT4gbGltaXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYm9vdHN0cmFwU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5CT09UU1RSQVBfU0lOR0xFKVxuICAgICAgICAuYmVnaW4oYCR7Y2hhbGsuYm9sZChlbnZpcm9ubWVudC5uYW1lKX06IGJvb3RzdHJhcHBpbmcuLi5gLCB7XG4gICAgICAgICAgdG90YWw6IGJvb3RzdHJhcEVudmlyb25tZW50cy5sZW5ndGgsXG4gICAgICAgICAgY3VycmVudDogY3VycmVudElkeCsxLFxuICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYm9vdHN0cmFwUmVzdWx0ID0gYXdhaXQgYm9vdHN0cmFwcGVyLmJvb3RzdHJhcEVudmlyb25tZW50KFxuICAgICAgICAgIGVudmlyb25tZW50LFxuICAgICAgICAgIHNka1Byb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lOiB0aGlzLnRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzPy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzPy5rZWVwRXhpc3RpbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJvb3RzdHJhcFJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJHtlbnZpcm9ubWVudC5uYW1lfSAobm8gY2hhbmdlcylgXG4gICAgICAgICAgOiBgIOKchSAgJHtlbnZpcm9ubWVudC5uYW1lfWA7XG5cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k5OTAwLm1zZyhjaGFsay5ncmVlbignXFxuJyArIG1lc3NhZ2UpLCB7IGVudmlyb25tZW50IH0pKTtcbiAgICAgICAgY29uc3QgZW52VGltZSA9IGF3YWl0IGJvb3RzdHJhcFNwYW4uZW5kKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHQgPSB7XG4gICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgc3RhdHVzOiBib290c3RyYXBSZXN1bHQubm9PcCA/ICduby1vcCcgOiAnc3VjY2VzcycsXG4gICAgICAgICAgZHVyYXRpb246IGVudlRpbWUuYXNNcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U5OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ib2xkKGVudmlyb25tZW50Lm5hbWUpfSBmYWlsZWQ6ICR7Zm9ybWF0RXJyb3JNZXNzYWdlKGUpfWAsIHsgZXJyb3I6IGUgfSkpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW52aXJvbm1lbnRzOiByZXN1bHRzLFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aCBBY3Rpb25cbiAgICpcbiAgICogVGhlIGNhbGxlciBhc3N1bWVzIG93bmVyc2hpcCBvZiB0aGUgYENhY2hlZENsb3VkQXNzZW1ibHlgIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyBgZGlzcG9zZSgpYCBvblxuICAgKiBpdCBhZnRlciB1c2UuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGgoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBTeW50aE9wdGlvbnMgPSB7fSk6IFByb21pc2U8Q2FjaGVkQ2xvdWRBc3NlbWJseT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3N5bnRoJyk7XG4gICAgY29uc3Qgc2VsZWN0U3RhY2tzID0gb3B0aW9ucy5zdGFja3MgPz8gQUxMX1NUQUNLUztcbiAgICBjb25zdCBzeW50aFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uU1lOVEhfQVNTRU1CTFkpLmJlZ2luKHsgc3RhY2tzOiBzZWxlY3RTdGFja3MgfSk7XG5cbiAgICAvLyBOT1RFOiBOT1QgJ2F3YWl0IHVzaW5nJyBiZWNhdXNlIHdlIHJldHVybiBvd25lcnNoaXAgdG8gdGhlIGNhbGxlclxuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3NWMihzZWxlY3RTdGFja3MpO1xuICAgIGNvbnN0IGF1dG9WYWxpZGF0ZVN0YWNrcyA9IG9wdGlvbnMudmFsaWRhdGVTdGFja3MgPyBbYXNzZW1ibHkuc2VsZWN0U3RhY2tzRm9yVmFsaWRhdGlvbigpXSA6IFtdO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3MuY29uY2F0KC4uLmF1dG9WYWxpZGF0ZVN0YWNrcyksIGlvSGVscGVyKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgc2luZ2xlIHN0YWNrLCBwcmludCBpdCB0byBTVERPVVRcbiAgICBjb25zdCBtZXNzYWdlID0gYFN1Y2Nlc3NmdWxseSBzeW50aGVzaXplZCB0byAke2NoYWxrLmJsdWUocGF0aC5yZXNvbHZlKHN0YWNrcy5hc3NlbWJseS5kaXJlY3RvcnkpKX1gO1xuICAgIGNvbnN0IGFzc2VtYmx5RGF0YTogQXNzZW1ibHlEYXRhID0ge1xuICAgICAgYXNzZW1ibHlEaXJlY3Rvcnk6IHN0YWNrcy5hc3NlbWJseS5kaXJlY3RvcnksXG4gICAgICBzdGFja3NDb3VudDogc3RhY2tzLnN0YWNrQ291bnQsXG4gICAgICBzdGFja0lkczogc3RhY2tzLmhpZXJhcmNoaWNhbElkcyxcbiAgICB9O1xuXG4gICAgaWYgKHN0YWNrcy5zdGFja0NvdW50ID09PSAxKSB7XG4gICAgICBjb25zdCBmaXJzdFN0YWNrID0gc3RhY2tzLmZpcnN0U3RhY2shO1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBmaXJzdFN0YWNrLnRlbXBsYXRlO1xuICAgICAgY29uc3Qgb2JzY3VyZWRUZW1wbGF0ZSA9IG9ic2N1cmVUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTE5MDEubXNnKG1lc3NhZ2UsIHtcbiAgICAgICAgLi4uYXNzZW1ibHlEYXRhLFxuICAgICAgICBzdGFjazoge1xuICAgICAgICAgIHN0YWNrTmFtZTogZmlyc3RTdGFjay5zdGFja05hbWUsXG4gICAgICAgICAgaGllcmFyY2hpY2FsSWQ6IGZpcnN0U3RhY2suaGllcmFyY2hpY2FsSWQsXG4gICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgc3RyaW5naWZpZWRKc29uOiBzZXJpYWxpemVTdHJ1Y3R1cmUob2JzY3VyZWRUZW1wbGF0ZSwgdHJ1ZSksXG4gICAgICAgICAgc3RyaW5naWZpZWRZYW1sOiBzZXJpYWxpemVTdHJ1Y3R1cmUob2JzY3VyZWRUZW1wbGF0ZSwgZmFsc2UpLFxuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3Qgb3V0cHV0dGluZyB0ZW1wbGF0ZSB0byBzdGRvdXQsIGxldCdzIGV4cGxhaW4gdGhpbmdzIHRvIHRoZSB1c2VyIGEgbGl0dGxlIGJpdC4uLlxuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0kxOTAyLm1zZyhjaGFsay5ncmVlbihtZXNzYWdlKSwgYXNzZW1ibHlEYXRhKSk7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGBTdXBwbHkgYSBzdGFjayBpZCAoJHtzdGFja3Muc3RhY2tBcnRpZmFjdHMubWFwKChzKSA9PiBjaGFsay5ncmVlbihzLmhpZXJhcmNoaWNhbElkKSkuam9pbignLCAnKX0pIHRvIGRpc3BsYXkgaXRzIHRlbXBsYXRlLmApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENhY2hlZENsb3VkQXNzZW1ibHkoYXNzZW1ibHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpZmYgQWN0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGlmZihjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IERpZmZPcHRpb25zKTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBUZW1wbGF0ZURpZmZ9PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCAnZGlmZicpO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoc2VsZWN0U3RhY2tzKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCBkaWZmU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5ESUZGX1NUQUNLKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbignZGlmZicpO1xuXG4gICAgY29uc3Qgc3RyaWN0ID0gISFvcHRpb25zLnN0cmljdDtcbiAgICBjb25zdCBjb250ZXh0TGluZXMgPSBvcHRpb25zLmNvbnRleHRMaW5lcyB8fCAzO1xuXG4gICAgbGV0IGRpZmZzID0gMDtcbiAgICBsZXQgZm9ybWF0dGVkU2VjdXJpdHlEaWZmID0gJyc7XG4gICAgbGV0IGZvcm1hdHRlZFN0YWNrRGlmZiA9ICcnO1xuXG4gICAgY29uc3QgdGVtcGxhdGVJbmZvcyA9IGF3YWl0IHByZXBhcmVEaWZmKGlvSGVscGVyLCBzdGFja3MsIGRlcGxveW1lbnRzLCBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKCdkaWZmJyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHRlbXBsYXRlRGlmZnM6IHsgW25hbWU6IHN0cmluZ106IFRlbXBsYXRlRGlmZiB9ID0ge307XG4gICAgZm9yIChjb25zdCB0ZW1wbGF0ZUluZm8gb2YgdGVtcGxhdGVJbmZvcykge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IERpZmZGb3JtYXR0ZXIoe1xuICAgICAgICBpb0hlbHBlcixcbiAgICAgICAgdGVtcGxhdGVJbmZvLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLnNlY3VyaXR5T25seSkge1xuICAgICAgICBjb25zdCBzZWN1cml0eURpZmYgPSBmb3JtYXR0ZXIuZm9ybWF0U2VjdXJpdHlEaWZmKHtcbiAgICAgICAgICByZXF1aXJlQXBwcm92YWw6IFJlcXVpcmVBcHByb3ZhbC5CUk9BREVOSU5HLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybWF0dGVkU2VjdXJpdHlEaWZmID0gc2VjdXJpdHlEaWZmLmZvcm1hdHRlZERpZmYgPz8gJyc7XG4gICAgICAgIGRpZmZzID0gc2VjdXJpdHlEaWZmLmZvcm1hdHRlZERpZmYgPyBkaWZmcyArIDEgOiBkaWZmcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBmb3JtYXR0ZXIuZm9ybWF0U3RhY2tEaWZmKHtcbiAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dExpbmVzLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybWF0dGVkU3RhY2tEaWZmID0gZGlmZi5mb3JtYXR0ZWREaWZmO1xuICAgICAgICBkaWZmcyA9IGRpZmYubnVtU3RhY2tzV2l0aENoYW5nZXM7XG4gICAgICB9XG4gICAgICBhcHBlbmRPYmplY3QodGVtcGxhdGVEaWZmcywgZm9ybWF0dGVyLmRpZmZzKTtcbiAgICB9XG5cbiAgICBhd2FpdCBkaWZmU3Bhbi5lbmQoYOKcqCBOdW1iZXIgb2Ygc3RhY2tzIHdpdGggZGlmZmVyZW5jZXM6ICR7ZGlmZnN9YCwge1xuICAgICAgZm9ybWF0dGVkU2VjdXJpdHlEaWZmLFxuICAgICAgZm9ybWF0dGVkU3RhY2tEaWZmLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlRGlmZnM7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBBY3Rpb25cbiAgICpcbiAgICogTGlzdCBzZWxlY3RlZCBzdGFja3MgYW5kIHRoZWlyIGRlcGVuZGVuY2llc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3QoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBMaXN0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxTdGFja0RldGFpbHNbXT4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ2xpc3QnKTtcbiAgICBjb25zdCBzZWxlY3RTdGFja3MgPSBvcHRpb25zLnN0YWNrcyA/PyBBTExfU1RBQ0tTO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IHNlbGVjdFN0YWNrcyB9KTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgc3ludGhTcGFuLmVuZCgpO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gc3RhY2tDb2xsZWN0aW9uLndpdGhEZXBlbmRlbmNpZXMoKTtcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhY2tzLm1hcChzID0+IHMuaWQpLmpvaW4oJ1xcbicpO1xuXG4gICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0kyOTAxLm1zZyhtZXNzYWdlLCB7IHN0YWNrcyB9KSk7XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgQWN0aW9uXG4gICAqXG4gICAqIERlcGxveXMgdGhlIHNlbGVjdGVkIHN0YWNrcyBpbnRvIGFuIEFXUyBhY2NvdW50XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVwbG95KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogRGVwbG95T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkZXBsb3knKTtcbiAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9kZXBsb3koYXNzZW1ibHksICdkZXBsb3knLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWxsb3cgZGVwbG95IGJlaW5nIGNhbGxlZCBhcyBwYXJ0IG9mIHRoZSB3YXRjaCBhY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9kZXBsb3koYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksIGFjdGlvbjogJ2RlcGxveScgfCAnd2F0Y2gnLCBvcHRpb25zOiBFeHRlbmRlZERlcGxveU9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHNlbGVjdFN0YWNrcyA9IG9wdGlvbnMuc3RhY2tzID8/IEFMTF9TVEFDS1M7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogc2VsZWN0U3RhY2tzIH0pO1xuICAgIGNvbnN0IHN0YWNrQ29sbGVjdGlvbiA9IGF3YWl0IGFzc2VtYmx5LnNlbGVjdFN0YWNrc1YyKHNlbGVjdFN0YWNrcyk7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrQ29sbGVjdGlvbiwgaW9IZWxwZXIpO1xuICAgIGNvbnN0IHN5bnRoRHVyYXRpb24gPSBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IERlcGxveVJlc3VsdCA9IHtcbiAgICAgIHN0YWNrczogW10sXG4gICAgfTtcblxuICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U1MDAxLm1zZygnVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJykpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBsb3ltZW50cyA9IGF3YWl0IHRoaXMuZGVwbG95bWVudHNGb3JBY3Rpb24oJ2RlcGxveScpO1xuICAgIGNvbnN0IG1pZ3JhdG9yID0gbmV3IFJlc291cmNlTWlncmF0b3IoeyBkZXBsb3ltZW50cywgaW9IZWxwZXIgfSk7XG5cbiAgICBhd2FpdCBtaWdyYXRvci50cnlNaWdyYXRlUmVzb3VyY2VzKHN0YWNrQ29sbGVjdGlvbiwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJNYXAgPSBidWlsZFBhcmFtZXRlck1hcChvcHRpb25zLnBhcmFtZXRlcnM/LnBhcmFtZXRlcnMpO1xuXG4gICAgY29uc3QgaG90c3dhcE1vZGUgPSBvcHRpb25zLmhvdHN3YXAgPz8gSG90c3dhcE1vZGUuRlVMTF9ERVBMT1lNRU5UO1xuICAgIGlmIChob3Rzd2FwTW9kZSAhPT0gSG90c3dhcE1vZGUuRlVMTF9ERVBMT1lNRU5UKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfVzU0MDAubXNnKFtcbiAgICAgICAgJ+KaoO+4jyBUaGUgLS1ob3Rzd2FwIGFuZCAtLWhvdHN3YXAtZmFsbGJhY2sgZmxhZ3MgZGVsaWJlcmF0ZWx5IGludHJvZHVjZSBDbG91ZEZvcm1hdGlvbiBkcmlmdCB0byBzcGVlZCB1cCBkZXBsb3ltZW50cycsXG4gICAgICAgICfimqDvuI8gVGhleSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBkZXZlbG9wbWVudCAtIG5ldmVyIHVzZSB0aGVtIGZvciB5b3VyIHByb2R1Y3Rpb24gU3RhY2tzIScsXG4gICAgICBdLmpvaW4oJ1xcbicpKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tzID0gc3RhY2tDb2xsZWN0aW9uLnN0YWNrQXJ0aWZhY3RzO1xuICAgIGNvbnN0IHN0YWNrT3V0cHV0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dHNGaWxlID0gb3B0aW9ucy5vdXRwdXRzRmlsZTtcblxuICAgIGNvbnN0IGJ1aWxkQXNzZXQgPSBhc3luYyAoYXNzZXROb2RlOiBBc3NldEJ1aWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgYnVpbGRBc3NldFNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uQlVJTERfQVNTRVQpLmJlZ2luKHtcbiAgICAgICAgYXNzZXQ6IGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgZGVwbG95bWVudHMuYnVpbGRTaW5nbGVBc3NldChcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3RBcnRpZmFjdCxcbiAgICAgICAgYXNzZXROb2RlLmFzc2V0TWFuaWZlc3QsXG4gICAgICAgIGFzc2V0Tm9kZS5hc3NldCxcbiAgICAgICAge1xuICAgICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHN0YWNrTmFtZTogYXNzZXROb2RlLnBhcmVudFN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBidWlsZEFzc2V0U3Bhbi5lbmQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcHVibGlzaEFzc2V0ID0gYXN5bmMgKGFzc2V0Tm9kZTogQXNzZXRQdWJsaXNoTm9kZSkgPT4ge1xuICAgICAgY29uc3QgcHVibGlzaEFzc2V0U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5QVUJMSVNIX0FTU0VUKS5iZWdpbih7XG4gICAgICAgIGFzc2V0OiBhc3NldE5vZGUuYXNzZXQsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGRlcGxveW1lbnRzLnB1Ymxpc2hTaW5nbGVBc3NldChhc3NldE5vZGUuYXNzZXRNYW5pZmVzdCwgYXNzZXROb2RlLmFzc2V0LCB7XG4gICAgICAgIHN0YWNrOiBhc3NldE5vZGUucGFyZW50U3RhY2ssXG4gICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgc3RhY2tOYW1lOiBhc3NldE5vZGUucGFyZW50U3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBmb3JjZVB1Ymxpc2g6IG9wdGlvbnMuZm9yY2VBc3NldFB1Ymxpc2hpbmcsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHB1Ymxpc2hBc3NldFNwYW4uZW5kKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlcGxveVN0YWNrID0gYXN5bmMgKHN0YWNrTm9kZTogU3RhY2tOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdGFjayA9IHN0YWNrTm9kZS5zdGFjaztcbiAgICAgIGlmIChzdGFja0NvbGxlY3Rpb24uc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgU3RhY2sgJHtzdGFjay5kaXNwbGF5TmFtZX0gZG9lcyBub3QgZGVmaW5lIGFuIGVudmlyb25tZW50LCBhbmQgQVdTIGNyZWRlbnRpYWxzIGNvdWxkIG5vdCBiZSBvYnRhaW5lZCBmcm9tIHN0YW5kYXJkIGxvY2F0aW9ucyBvciBubyByZWdpb24gd2FzIGNvbmZpZ3VyZWQuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGdlbmVyYXRlZCBzdGFjayBoYXMgbm8gcmVzb3VyY2VzXG4gICAgICBpZiAoT2JqZWN0LmtleXMoc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzIHx8IHt9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHkgYW5kIGRvZXNuJ3QgZXhpc3QgPT4gZG8gbm90aGluZ1xuICAgICAgICBjb25zdCBzdGFja0V4aXN0cyA9IGF3YWl0IGRlcGxveW1lbnRzLnN0YWNrRXhpc3RzKHsgc3RhY2sgfSk7XG4gICAgICAgIGlmICghc3RhY2tFeGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX1c1MDIxLm1zZyhgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX06IHN0YWNrIGhhcyBubyByZXNvdXJjZXMsIHNraXBwaW5nIGRlcGxveW1lbnQuYCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhY2sgaXMgZW1wdHksIGJ1dCBleGlzdHMgPT4gZGVsZXRlXG4gICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9XNTAyMi5tc2coYCR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9OiBzdGFjayBoYXMgbm8gcmVzb3VyY2VzLCBkZWxldGluZyBleGlzdGluZyBzdGFjay5gKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Rlc3Ryb3koYXNzZW1ibHksICdkZXBsb3knLCB7XG4gICAgICAgICAgc3RhY2tzOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLCBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFIH0sXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IGRlcGxveW1lbnRzLnJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2spO1xuICAgICAgY29uc3QgcGVybWlzc2lvbkNoYW5nZVR5cGUgPSBkZXRlcm1pbmVQZXJtaXNzaW9uVHlwZShjdXJyZW50VGVtcGxhdGUsIHN0YWNrKTtcbiAgICAgIGNvbnN0IGRlcGxveU1vdGl2YXRpb24gPSAnXCItLXJlcXVpcmUtYXBwcm92YWxcIiBpcyBlbmFibGVkIGFuZCBzdGFjayBpbmNsdWRlcyBzZWN1cml0eS1zZW5zaXRpdmUgdXBkYXRlcy4nO1xuICAgICAgY29uc3QgZGVwbG95UXVlc3Rpb24gPSBgJHtkZXBsb3lNb3RpdmF0aW9ufVxcbkRvIHlvdSB3aXNoIHRvIGRlcGxveSB0aGVzZSBjaGFuZ2VzYDtcbiAgICAgIGNvbnN0IGRlcGxveUNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNTA2MC5yZXEoZGVwbG95UXVlc3Rpb24sIHtcbiAgICAgICAgbW90aXZhdGlvbjogZGVwbG95TW90aXZhdGlvbixcbiAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgIHBlcm1pc3Npb25DaGFuZ2VUeXBlLFxuICAgICAgfSkpO1xuICAgICAgaWYgKCFkZXBsb3lDb25maXJtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvbGxvd2luZyBhcmUgdGhlIHNhbWUgc2VtYW50aWNzIHdlIGFwcGx5IHdpdGggcmVzcGVjdCB0byBOb3RpZmljYXRpb24gQVJOcyAoZGljdGF0ZWQgYnkgdGhlIFNESylcbiAgICAgIC8vXG4gICAgICAvLyAgLSB1bmRlZmluZWQgID0+ICBjZGsgaWdub3JlcyBpdCwgYXMgaWYgaXQgd2Fzbid0IHN1cHBvcnRlZCAoYWxsb3dzIGV4dGVybmFsIG1hbmFnZW1lbnQpLlxuICAgICAgLy8gIC0gW106ICAgICAgICA9PiAgY2RrIG1hbmFnZXMgaXQsIGFuZCB0aGUgdXNlciB3YW50cyB0byB3aXBlIGl0IG91dC5cbiAgICAgIC8vICAtIFsnYXJuLTEnXSAgPT4gIGNkayBtYW5hZ2VzIGl0LCBhbmQgdGhlIHVzZXIgd2FudHMgdG8gc2V0IGl0IHRvIFsnYXJuLTEnXS5cbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbkFybnMgPSAoISFvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgfHwgISFzdGFjay5ub3RpZmljYXRpb25Bcm5zKVxuICAgICAgICA/IChvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMgPz8gW10pLmNvbmNhdChzdGFjay5ub3RpZmljYXRpb25Bcm5zID8/IFtdKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgZm9yIChjb25zdCBub3RpZmljYXRpb25Bcm4gb2Ygbm90aWZpY2F0aW9uQXJucyA/PyBbXSkge1xuICAgICAgICBpZiAoIXZhbGlkYXRlU25zVG9waWNBcm4obm90aWZpY2F0aW9uQXJuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE5vdGlmaWNhdGlvbiBhcm4gJHtub3RpZmljYXRpb25Bcm59IGlzIG5vdCBhIHZhbGlkIGFybiBmb3IgYW4gU05TIHRvcGljYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHN0YWNrcy5pbmRleE9mKHN0YWNrKSArIDE7XG4gICAgICBjb25zdCBkZXBsb3lTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkRFUExPWV9TVEFDSylcbiAgICAgICAgLmJlZ2luKGAke2NoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpfTogZGVwbG95aW5nLi4uIFske3N0YWNrSW5kZXh9LyR7c3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnR9XWAsIHtcbiAgICAgICAgICB0b3RhbDogc3RhY2tDb2xsZWN0aW9uLnN0YWNrQ291bnQsXG4gICAgICAgICAgY3VycmVudDogc3RhY2tJbmRleCxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgfSk7XG5cbiAgICAgIGxldCB0YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgaWYgKCF0YWdzIHx8IHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRhZ3MgPSB0YWdzRm9yU3RhY2soc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGVwbG95RHVyYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZGVwbG95UmVzdWx0OiBTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgbGV0IHJvbGxiYWNrID0gb3B0aW9ucy5yb2xsYmFjaztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICghZGVwbG95UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCsraXRlcmF0aW9uID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVGhpcyBsb29wIHNob3VsZCBoYXZlIHN0YWJpbGl6ZWQgaW4gMiBpdGVyYXRpb25zLCBidXQgZGlkblxcJ3QuIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IGRlcGxveW1lbnRzLmRlcGxveVN0YWNrKHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgICAgdG9vbGtpdFN0YWNrTmFtZTogdGhpcy50b29sa2l0U3RhY2tOYW1lLFxuICAgICAgICAgICAgcmV1c2VBc3NldHM6IG9wdGlvbnMucmV1c2VBc3NldHMsXG4gICAgICAgICAgICBub3RpZmljYXRpb25Bcm5zLFxuICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgIGRlcGxveW1lbnRNZXRob2Q6IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZCxcbiAgICAgICAgICAgIGZvcmNlRGVwbG95bWVudDogb3B0aW9ucy5mb3JjZURlcGxveW1lbnQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJNYXBbJyonXSwgcGFyYW1ldGVyTWFwW3N0YWNrLnN0YWNrTmFtZV0pLFxuICAgICAgICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnM/LmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xsYmFjayxcbiAgICAgICAgICAgIGhvdHN3YXA6IGhvdHN3YXBNb2RlLFxuICAgICAgICAgICAgZXh0cmFVc2VyQWdlbnQ6IG9wdGlvbnMuZXh0cmFVc2VyQWdlbnQsXG4gICAgICAgICAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IG9wdGlvbnMuaG90c3dhcFByb3BlcnRpZXMgPyBjcmVhdGVIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMob3B0aW9ucy5ob3Rzd2FwUHJvcGVydGllcykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhc3NldFBhcmFsbGVsaXNtOiBvcHRpb25zLmFzc2V0UGFyYWxsZWxpc20sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlkLWRlcGxveS1zdGFjayc6XG4gICAgICAgICAgICAgIGRlcGxveVJlc3VsdCA9IHI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdmYWlscGF1c2VkLW5lZWQtcm9sbGJhY2stZmlyc3QnOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSByLnJlYXNvbiA9PT0gJ3JlcGxhY2VtZW50J1xuICAgICAgICAgICAgICAgID8gYFN0YWNrIGlzIGluIGEgcGF1c2VkIGZhaWwgc3RhdGUgKCR7ci5zdGF0dXN9KSBhbmQgY2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCJgXG4gICAgICAgICAgICAgICAgOiBgU3RhY2sgaXMgaW4gYSBwYXVzZWQgZmFpbCBzdGF0ZSAoJHtyLnN0YXR1c30pIGFuZCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIGRvIG5vdCBpbmNsdWRlIFwiLS1uby1yb2xsYmFja1wiYDtcbiAgICAgICAgICAgICAgY29uc3QgcXVlc3Rpb24gPSBgJHttb3RpdmF0aW9ufS4gUGVyZm9ybSBhIHJlZ3VsYXIgZGVwbG95bWVudGA7XG5cbiAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgaW9IZWxwZXIucmVxdWVzdFJlc3BvbnNlKElPLkNES19UT09MS0lUX0k1MDUwLnJlcShxdWVzdGlvbiwge1xuICAgICAgICAgICAgICAgIG1vdGl2YXRpb24sXG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdBYm9ydGVkIGJ5IHVzZXInKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFBlcmZvcm0gYSByb2xsYmFja1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yb2xsYmFjayhhc3NlbWJseSwgYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgc3RhY2tzOiB7IHBhdHRlcm5zOiBbc3RhY2suaGllcmFyY2hpY2FsSWRdLCBzdHJhdGVneTogU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5QQVRURVJOX01VU1RfTUFUQ0hfU0lOR0xFIH0sXG4gICAgICAgICAgICAgICAgb3JwaGFuRmFpbGVkUmVzb3VyY2VzOiBvcHRpb25zLm9ycGhhbkZhaWxlZFJlc291cmNlc0R1cmluZ1JvbGxiYWNrLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBHbyBhcm91bmQgdGhyb3VnaCB0aGUgJ3doaWxlJyBsb29wIGFnYWluIGJ1dCBzd2l0Y2ggcm9sbGJhY2sgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgcm9sbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZW1lbnQtcmVxdWlyZXMtcm9sbGJhY2snOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnQ2hhbmdlIGluY2x1ZGVzIGEgcmVwbGFjZW1lbnQgd2hpY2ggY2Fubm90IGJlIGRlcGxveWVkIHdpdGggXCItLW5vLXJvbGxiYWNrXCInO1xuICAgICAgICAgICAgICBjb25zdCBxdWVzdGlvbiA9IGAke21vdGl2YXRpb259LiBQZXJmb3JtIGEgcmVndWxhciBkZXBsb3ltZW50YDtcblxuICAgICAgICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBpb0hlbHBlci5yZXF1ZXN0UmVzcG9uc2UoSU8uQ0RLX1RPT0xLSVRfSTUwNTAucmVxKHF1ZXN0aW9uLCB7XG4gICAgICAgICAgICAgICAgbW90aXZhdGlvbixcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR28gYXJvdW5kIHRocm91Z2ggdGhlICd3aGlsZScgbG9vcCBhZ2FpbiBidXQgc3dpdGNoIHJvbGxiYWNrIHRvIHRydWUuXG4gICAgICAgICAgICAgIHJvbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBkZXBsb3lTdGFjazogJHtKU09OLnN0cmluZ2lmeShyKX0uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgZXJyb3IsIHBsZWFzZSByZXBvcnQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRlcGxveVJlc3VsdC5ub09wXG4gICAgICAgICAgPyBgIOKchSAgJHtzdGFjay5kaXNwbGF5TmFtZX0gKG5vIGNoYW5nZXMpYFxuICAgICAgICAgIDogYCDinIUgICR7c3RhY2suZGlzcGxheU5hbWV9YDtcblxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU5MDAubXNnKGNoYWxrLmdyZWVuKCdcXG4nICsgbWVzc2FnZSksIGRlcGxveVJlc3VsdCkpO1xuICAgICAgICBkZXBsb3lEdXJhdGlvbiA9IGF3YWl0IGRlcGxveVNwYW4udGltaW5nKElPLkNES19UT09MS0lUX0k1MDAwKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVwbG95UmVzdWx0Lm91dHB1dHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBbJ091dHB1dHM6J107XG4gICAgICAgICAgc3RhY2tPdXRwdXRzW3N0YWNrLnN0YWNrTmFtZV0gPSBkZXBsb3lSZXN1bHQub3V0cHV0cztcblxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkZXBsb3lSZXN1bHQub3V0cHV0cykuc29ydCgpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlcGxveVJlc3VsdC5vdXRwdXRzW25hbWVdO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goYCR7Y2hhbGsuY3lhbihzdGFjay5pZCl9LiR7Y2hhbGsuY3lhbihuYW1lKX0gPSAke2NoYWxrLnVuZGVybGluZShjaGFsay5jeWFuKHZhbHVlKSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTkwMS5tc2coYnVmZmVyLmpvaW4oJ1xcbicpKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1OTAxLm1zZyhgU3RhY2sgQVJOOlxcbiR7ZGVwbG95UmVzdWx0LnN0YWNrQXJufWApKTtcblxuICAgICAgICByZXQuc3RhY2tzLnB1c2goe1xuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICBhY2NvdW50OiBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgICAgICAgcmVnaW9uOiBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFja0FybjogZGVwbG95UmVzdWx0LnN0YWNrQXJuLFxuICAgICAgICAgIG91dHB1dHM6IGRlcGxveVJlc3VsdC5vdXRwdXRzLFxuICAgICAgICAgIGhpZXJhcmNoaWNhbElkOiBzdGFjay5oaWVyYXJjaGljYWxJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gSXQgaGFzIHRvIGJlIGV4YWN0bHkgdGhpcyBzdHJpbmcgYmVjYXVzZSBhbiBpbnRlZ3JhdGlvbiB0ZXN0IHRlc3RzIGZvclxuICAgICAgICAvLyBcImJvbGQoc3RhY2tuYW1lKSBmYWlsZWQ6IFJlc291cmNlTm90UmVhZHk6IDxlcnJvcj5cIlxuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIFtg4p2MICAke2NoYWxrLmJvbGQoc3RhY2suc3RhY2tOYW1lKX0gZmFpbGVkOmAsIC4uLihlLm5hbWUgPyBbYCR7ZS5uYW1lfTpgXSA6IFtdKSwgZS5tZXNzYWdlXS5qb2luKCcgJyksXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAob3B0aW9ucy50cmFjZUxvZ3MpIHtcbiAgICAgICAgICAvLyBkZXBsb3kgY2FsbHMgdGhhdCBvcmlnaW5hdGUgZnJvbSB3YXRjaCB3aWxsIGNvbWUgd2l0aCB0aGVpciBvd24gY2xvdWRXYXRjaExvZ01vbml0b3JcbiAgICAgICAgICBjb25zdCBjbG91ZFdhdGNoTG9nTW9uaXRvciA9IG9wdGlvbnMuY2xvdWRXYXRjaExvZ01vbml0b3IgPz8gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IoeyBpb0hlbHBlciB9KTtcbiAgICAgICAgICBjb25zdCBmb3VuZExvZ0dyb3Vwc1Jlc3VsdCA9IGF3YWl0IGZpbmRDbG91ZFdhdGNoTG9nR3JvdXBzKGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ2RlcGxveScpLCBpb0hlbHBlciwgc3RhY2spO1xuICAgICAgICAgIGNsb3VkV2F0Y2hMb2dNb25pdG9yLmFkZExvZ0dyb3VwcyhcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmVudixcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LnNkayxcbiAgICAgICAgICAgIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUwMzEubXNnKGBUaGUgZm9sbG93aW5nIGxvZyBncm91cHMgYXJlIGFkZGVkOiAke2ZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXN9YCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW4gb3V0cHV0cyBmaWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgY3JlYXRlIHRoZSBmaWxlIHBhdGggYW5kIHdyaXRlIHN0YWNrIG91dHB1dHMgdG8gaXQgb25jZS5cbiAgICAgICAgLy8gT3V0cHV0cyBhcmUgd3JpdHRlbiBhZnRlciBhbGwgc3RhY2tzIGhhdmUgYmVlbiBkZXBsb3llZC4gSWYgYSBzdGFjayBkZXBsb3ltZW50IGZhaWxzLFxuICAgICAgICAvLyBhbGwgb2YgdGhlIG91dHB1dHMgZnJvbSBzdWNjZXNzZnVsbHkgZGVwbG95ZWQgc3RhY2tzIGJlZm9yZSB0aGUgZmFpbHVyZSB3aWxsIHN0aWxsIGJlIHdyaXR0ZW4uXG4gICAgICAgIGlmIChvdXRwdXRzRmlsZSkge1xuICAgICAgICAgIGZzLmVuc3VyZUZpbGVTeW5jKG91dHB1dHNGaWxlKTtcbiAgICAgICAgICBhd2FpdCBmcy53cml0ZUpzb24ob3V0cHV0c0ZpbGUsIHN0YWNrT3V0cHV0cywge1xuICAgICAgICAgICAgc3BhY2VzOiAyLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb24gPSBzeW50aER1cmF0aW9uLmFzTXMgKyAoZGVwbG95RHVyYXRpb24/LmFzTXMgPz8gMCk7XG4gICAgICBhd2FpdCBkZXBsb3lTcGFuLmVuZChgXFxu4pyoICBUb3RhbCB0aW1lOiAke2Zvcm1hdFRpbWUoZHVyYXRpb24pfXNcXG5gLCB7IGR1cmF0aW9uIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBhc3NldEJ1aWxkVGltZSA9IG9wdGlvbnMuYXNzZXRCdWlsZFRpbWUgPz8gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgcHJlYnVpbGRBc3NldHMgPSBhc3NldEJ1aWxkVGltZSA9PT0gQXNzZXRCdWlsZFRpbWUuQUxMX0JFRk9SRV9ERVBMT1k7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IDE7XG5cbiAgICBjb25zdCBzdGFja3NBbmRUaGVpckFzc2V0TWFuaWZlc3RzID0gc3RhY2tzLmZsYXRNYXAoKHN0YWNrKSA9PiBbXG4gICAgICBzdGFjayxcbiAgICAgIC4uLnN0YWNrLmRlcGVuZGVuY2llcy5maWx0ZXIoeCA9PiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QuaXNBc3NldE1hbmlmZXN0QXJ0aWZhY3QoeCkpLFxuICAgIF0pO1xuICAgIGNvbnN0IHdvcmtHcmFwaCA9IG5ldyBXb3JrR3JhcGhCdWlsZGVyKGlvSGVscGVyLCBwcmVidWlsZEFzc2V0cykuYnVpbGQoc3RhY2tzQW5kVGhlaXJBc3NldE1hbmlmZXN0cyk7XG5cbiAgICAvLyBVbmxlc3Mgd2UgYXJlIHJ1bm5pbmcgd2l0aCAnLS1mb3JjZScsIHNraXAgYWxyZWFkeSBwdWJsaXNoZWQgYXNzZXRzXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlQXNzZXRQdWJsaXNoaW5nKSB7XG4gICAgICBhd2FpdCByZW1vdmVQdWJsaXNoZWRBc3NldHNGcm9tV29ya0dyYXBoKHdvcmtHcmFwaCwgZGVwbG95bWVudHMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoQ29uY3VycmVuY3k6IENvbmN1cnJlbmN5ID0ge1xuICAgICAgJ3N0YWNrJzogY29uY3VycmVuY3ksXG4gICAgICAnYXNzZXQtYnVpbGQnOiAxLCAvLyBUaGlzIHdpbGwgYmUgQ1BVLWJvdW5kL21lbW9yeSBib3VuZCwgbW9zdGx5IG1hdHRlcnMgZm9yIERvY2tlciBidWlsZHNcbiAgICAgICdhc3NldC1wdWJsaXNoJzogKG9wdGlvbnMuYXNzZXRQYXJhbGxlbGlzbSA/PyB0cnVlKSA/IDggOiAxLCAvLyBUaGlzIHdpbGwgYmUgSS9PLWJvdW5kLCA4IGluIHBhcmFsbGVsIHNlZW1zIHJlYXNvbmFibGVcbiAgICB9O1xuXG4gICAgYXdhaXQgd29ya0dyYXBoLmRvUGFyYWxsZWwoZ3JhcGhDb25jdXJyZW5jeSwge1xuICAgICAgZGVwbG95U3RhY2ssXG4gICAgICBidWlsZEFzc2V0LFxuICAgICAgcHVibGlzaEFzc2V0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXRjaCBBY3Rpb25cbiAgICpcbiAgICogQ29udGludW91c2x5IG9ic2VydmUgcHJvamVjdCBmaWxlcyBhbmQgZGVwbG95IHRoZSBzZWxlY3RlZCBzdGFja3NcbiAgICogYXV0b21hdGljYWxseSB3aGVuIGNoYW5nZXMgYXJlIGRldGVjdGVkLiAgSW1wbGllcyBob3Rzd2FwIGRlcGxveW1lbnRzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHksIHN0YXJ0aW5nIGEgd2F0Y2hlciBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB3YXRjaChjeDogSUNsb3VkQXNzZW1ibHlTb3VyY2UsIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyk6IFByb21pc2U8SVdhdGNoZXI+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICd3YXRjaCcpO1xuICAgIGF3YWl0IHVzaW5nIGFzc2VtYmx5ID0gYXdhaXQgYXNzZW1ibHlGcm9tU291cmNlKGlvSGVscGVyLCBjeCwgZmFsc2UpO1xuICAgIGNvbnN0IHJvb3REaXIgPSBvcHRpb25zLndhdGNoRGlyID8/IHByb2Nlc3MuY3dkKCk7XG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5leGNsdWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVzZSB0aGUgJ3dhdGNoJyBjb21tYW5kIHdpdGhvdXQgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgZGlyZWN0b3J5IHRvIG1vbml0b3IuIFwiICtcbiAgICAgICAgICAnTWFrZSBzdXJlIHRvIGFkZCBhIFwid2F0Y2hcIiBrZXkgdG8geW91ciBjZGsuanNvbicsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZvciB0aGUgXCJpbmNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LCB0aGUgYmVoYXZpb3IgaXM6XG4gICAgLy8gMS4gTm8gXCJ3YXRjaFwiIHNldHRpbmc/IFdlIGVycm9yIG91dC5cbiAgICAvLyAyLiBcIndhdGNoXCIgc2V0dGluZyB3aXRob3V0IGFuIFwiaW5jbHVkZVwiIGtleT8gV2UgZGVmYXVsdCB0byBvYnNlcnZpbmcgXCIuLyoqXCIuXG4gICAgLy8gMy4gXCJ3YXRjaFwiIHNldHRpbmcgd2l0aCBhbiBlbXB0eSBcImluY2x1ZGVcIiBrZXk/IFdlIGRlZmF1bHQgdG8gb2JzZXJ2aW5nIFwiLi8qKlwiLlxuICAgIC8vIDQuIE5vbi1lbXB0eSBcImluY2x1ZGVcIiBrZXk/IEp1c3QgdXNlIHRoZSBcImluY2x1ZGVcIiBrZXkuXG4gICAgY29uc3Qgd2F0Y2hJbmNsdWRlcyA9IHBhdHRlcm5zQXJyYXlGb3JXYXRjaChvcHRpb25zLmluY2x1ZGUsIHtcbiAgICAgIHJvb3REaXIsXG4gICAgICByZXR1cm5Sb290RGlySWZFbXB0eTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIEZvciB0aGUgXCJleGNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBhZGQgc29tZSBkZWZhdWx0IGV4Y2x1ZGVzIGluIGFkZGl0aW9uIHRvIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgdXNlcjpcbiAgICAvLyAxLiBUaGUgQ0RLIG91dHB1dCBkaXJlY3RvcnkuXG4gICAgLy8gMi4gQW55IGZpbGUgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBhIGRvdC5cbiAgICAvLyAzLiBBbnkgZGlyZWN0b3J5J3MgY29udGVudCB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIC8vIDQuIEFueSBub2RlX21vZHVsZXMgYW5kIGl0cyBjb250ZW50IChldmVuIGlmIGl0J3Mgbm90IGEgSlMvVFMgcHJvamVjdCwgeW91IG1pZ2h0IGJlIHVzaW5nIGEgbG9jYWwgYXdzLWNsaSBwYWNrYWdlKVxuICAgIGNvbnN0IG91dGRpciA9IGFzc2VtYmx5LmRpcmVjdG9yeTtcbiAgICBjb25zdCB3YXRjaEV4Y2x1ZGVzID0gcGF0dGVybnNBcnJheUZvcldhdGNoKG9wdGlvbnMuZXhjbHVkZSwge1xuICAgICAgcm9vdERpcixcbiAgICAgIHJldHVyblJvb3REaXJJZkVtcHR5OiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgZXhjbHVkZSB0aGUgb3V0ZGlyIGlmIGl0IGlzIHVuZGVyIHRoZSByb290RGlyXG4gICAgY29uc3QgcmVsYXRpdmVPdXREaXIgPSBwYXRoLnJlbGF0aXZlKHJvb3REaXIsIG91dGRpcik7XG4gICAgaWYgKEJvb2xlYW4ocmVsYXRpdmVPdXREaXIgJiYgIXJlbGF0aXZlT3V0RGlyLnN0YXJ0c1dpdGgoJy4uJyArIHBhdGguc2VwKSAmJiAhcGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlT3V0RGlyKSkpIHtcbiAgICAgIHdhdGNoRXhjbHVkZXMucHVzaChgJHtyZWxhdGl2ZU91dERpcn0vKipgKTtcbiAgICB9XG5cbiAgICB3YXRjaEV4Y2x1ZGVzLnB1c2goJyoqLy4qJywgJyoqLy4qLyoqJywgJyoqL25vZGVfbW9kdWxlcy8qKicpO1xuXG4gICAgLy8gUHJpbnQgc29tZSBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiBjb21wdXRlZCBzZXR0aW5nc1xuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMC5tc2coW1xuICAgICAgYHJvb3QgZGlyZWN0b3J5IHVzZWQgZm9yICd3YXRjaCcgaXM6ICR7cm9vdERpcn1gLFxuICAgICAgYCdpbmNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEluY2x1ZGVzKX1gLFxuICAgICAgYCdleGNsdWRlJyBwYXR0ZXJucyBmb3IgJ3dhdGNoJzogJHtKU09OLnN0cmluZ2lmeSh3YXRjaEV4Y2x1ZGVzKX1gLFxuICAgIF0uam9pbignXFxuJyksIHtcbiAgICAgIHdhdGNoRGlyOiByb290RGlyLFxuICAgICAgaW5jbHVkZXM6IHdhdGNoSW5jbHVkZXMsXG4gICAgICBleGNsdWRlczogd2F0Y2hFeGNsdWRlcyxcbiAgICB9KSk7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgIC0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgZmlsZSBjaGFuZ2VkXG4gICAgLy8gfCAgICAgICAgICAgIHwgIHJlYWR5IGV2ZW50ICAgfCAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tfFxuICAgIC8vIHwgcHJlLXJlYWR5ICB8IC0tLS0tLS0tLS0tLS0+IHwgb3BlbiB8ICAgICAgICAgICAgICAgICAgICAgfCBkZXBsb3lpbmcgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgcXVldWVkICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS18XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0gICAgICAgICAgICAgICAgLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tXG4gICAgdHlwZSBMYXRjaFN0YXRlID0gJ3ByZS1yZWFkeScgfCAnb3BlbicgfCAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnO1xuICAgIGxldCBsYXRjaDogTGF0Y2hTdGF0ZSA9ICdwcmUtcmVhZHknO1xuXG4gICAgY29uc3QgY2xvdWRXYXRjaExvZ01vbml0b3IgPSBvcHRpb25zLnRyYWNlTG9ncyA/IG5ldyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yKHsgaW9IZWxwZXIgfSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGVwbG95QW5kV2F0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgICBsYXRjaCA9ICdkZXBsb3lpbmcnIGFzIExhdGNoU3RhdGU7XG4gICAgICBhd2FpdCBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChhc3NlbWJseSwgb3B0aW9ucywgY2xvdWRXYXRjaExvZ01vbml0b3IpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKGxhdGNoID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycsXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MzE1Lm1zZyhcIkRldGVjdGVkIGZpbGUgY2hhbmdlcyBkdXJpbmcgZGVwbG95bWVudC4gSW52b2tpbmcgJ2NkayBkZXBsb3knIGFnYWluXCIpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZva2VEZXBsb3lGcm9tV2F0Y2goYXNzZW1ibHksIG9wdGlvbnMsIGNsb3VkV2F0Y2hMb2dNb25pdG9yKTtcbiAgICAgIH1cbiAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgYXdhaXQgY2xvdWRXYXRjaExvZ01vbml0b3I/LmFjdGl2YXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdhdGNoZXIgPSBjaG9raWRhclxuICAgICAgLndhdGNoKHdhdGNoSW5jbHVkZXMsIHtcbiAgICAgICAgaWdub3JlZDogd2F0Y2hFeGNsdWRlcyxcbiAgICAgICAgY3dkOiByb290RGlyLFxuICAgICAgfSlcbiAgICAgIC5vbigncmVhZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxhdGNoID0gJ29wZW4nO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhcIid3YXRjaCcgcmVjZWl2ZWQgdGhlICdyZWFkeScgZXZlbnQuIEZyb20gbm93IG9uLCBhbGwgZmlsZSBjaGFuZ2VzIHdpbGwgdHJpZ2dlciBhIGRlcGxveW1lbnRcIikpO1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTQubXNnKFwiVHJpZ2dlcmluZyBpbml0aWFsICdjZGsgZGVwbG95J1wiKSk7XG4gICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdhbGwnLCBhc3luYyAoZXZlbnQ6ICdhZGQnIHwgJ2FkZERpcicgfCAnY2hhbmdlJyB8ICd1bmxpbmsnIHwgJ3VubGlua0RpcicsIGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgd2F0Y2hFdmVudCA9IHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxhdGNoID09PSAncHJlLXJlYWR5Jykge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTMxMS5tc2coYCd3YXRjaCcgaXMgb2JzZXJ2aW5nICR7ZXZlbnQgPT09ICdhZGREaXInID8gJ2RpcmVjdG9yeScgOiAndGhlIGZpbGUnfSAnJHtmaWxlUGF0aH0nIGZvciBjaGFuZ2VzYCwgd2F0Y2hFdmVudCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTIubXNnKGBEZXRlY3RlZCBjaGFuZ2UgdG8gJyR7ZmlsZVBhdGh9JyAodHlwZTogJHtldmVudH0pLiBUcmlnZ2VyaW5nICdjZGsgZGVwbG95J2AsIHdhdGNoRXZlbnQpKTtcbiAgICAgICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgbGF0Y2ggaXMgZWl0aGVyICdkZXBsb3lpbmcnIG9yICdxdWV1ZWQnXG4gICAgICAgICAgbGF0Y2ggPSAncXVldWVkJztcbiAgICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUzMTMubXNnKFxuICAgICAgICAgICAgYERldGVjdGVkIGNoYW5nZSB0byAnJHtmaWxlUGF0aH0nICh0eXBlOiAke2V2ZW50fSkgd2hpbGUgJ2NkayBkZXBsb3knIGlzIHN0aWxsIHJ1bm5pbmcuIFdpbGwgcXVldWUgZm9yIGFub3RoZXIgZGVwbG95bWVudCBhZnRlciB0aGlzIG9uZSBmaW5pc2hlcydgLFxuICAgICAgICAgICAgd2F0Y2hFdmVudCxcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjb25zdCBzdG9wcGVkUHJvbWlzZSA9IHByb21pc2VXaXRoUmVzb2x2ZXJzPHZvaWQ+KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgYXdhaXQgd2F0Y2hlci5jbG9zZSgpO1xuICAgICAgICAvLyBQcmV2ZW50cyBOb2RlIGZyb20gc3RheWluZyBhbGl2ZS4gVGhlcmUgaXMgbm8gJ2VuZCcgZXZlbnQgdGhhdCB0aGUgd2F0Y2hlciBlbWl0c1xuICAgICAgICAvLyB0aGF0IHdlIGNhbiBrbm93IGl0J3MgZGVmaW5pdGVseSBkb25lLCBzbyBiZXN0IHdlIGNhbiBkbyBpcyB0ZWxsIGl0IHRvIHN0b3Agd2F0Y2hpbmcsXG4gICAgICAgIC8vIHN0b3Aga2VlcGluZyBOb2RlIGFsaXZlLCBhbmQgdGhlbiBwcmV0ZW5kIHRoYXQncyBldmVyeXRoaW5nIHdlIG5lZWRlZCB0byBkby5cbiAgICAgICAgd2F0Y2hlci51bnJlZigpO1xuICAgICAgICBzdG9wcGVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHdhaXRGb3JFbmQoKSB7XG4gICAgICAgIHJldHVybiBzdG9wcGVkUHJvbWlzZS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgfSxcbiAgICB9IHNhdGlzZmllcyBJV2F0Y2hlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBBY3Rpb25cbiAgICpcbiAgICogUm9sbHMgYmFjayB0aGUgc2VsZWN0ZWQgc3RhY2tzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJvbGxiYWNrKGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogUm9sbGJhY2tPcHRpb25zKTogUHJvbWlzZTxSb2xsYmFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3JvbGxiYWNrJyk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcm9sbGJhY2soYXNzZW1ibHksICdyb2xsYmFjaycsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhbGxvdyByb2xsYmFjayBiZWluZyBjYWxsZWQgYXMgcGFydCBvZiB0aGUgZGVwbG95IG9yIHdhdGNoIGFjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JvbGxiYWNrKGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBhY3Rpb246ICdyb2xsYmFjaycgfCAnZGVwbG95JyB8ICd3YXRjaCcsIG9wdGlvbnM6IFJvbGxiYWNrT3B0aW9ucyk6IFByb21pc2U8Um9sbGJhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsIGFjdGlvbik7XG4gICAgY29uc3Qgc3ludGhTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlNZTlRIX0FTU0VNQkxZKS5iZWdpbih7IHN0YWNrczogb3B0aW9ucy5zdGFja3MgfSk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIob3B0aW9ucy5zdGFja3MpO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTdGFja3NNZXRhZGF0YShzdGFja3MsIGlvSGVscGVyKTtcbiAgICBhd2FpdCBzeW50aFNwYW4uZW5kKCk7XG5cbiAgICBjb25zdCByZXQ6IFJvbGxiYWNrUmVzdWx0ID0ge1xuICAgICAgc3RhY2tzOiBbXSxcbiAgICB9O1xuXG4gICAgaWYgKHN0YWNrcy5zdGFja0NvdW50ID09PSAwKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTYwMDEubXNnKCdObyBzdGFja3Mgc2VsZWN0ZWQnKSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGxldCBhbnlSb2xsYmFja2FibGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW2luZGV4LCBzdGFja10gb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgcm9sbGJhY2tTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLlJPTExCQUNLX1NUQUNLKS5iZWdpbihgUm9sbGluZyBiYWNrICR7Y2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSl9YCwge1xuICAgICAgICB0b3RhbDogc3RhY2tzLnN0YWNrQ291bnQsXG4gICAgICAgIGN1cnJlbnQ6IGluZGV4ICsgMSxcbiAgICAgICAgc3RhY2ssXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbigncm9sbGJhY2snKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YWNrUmVzdWx0ID0gYXdhaXQgZGVwbG95bWVudHMucm9sbGJhY2tTdGFjayh7XG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgcm9sZUFybjogb3B0aW9ucy5yb2xlQXJuLFxuICAgICAgICAgIHRvb2xraXRTdGFja05hbWU6IHRoaXMudG9vbGtpdFN0YWNrTmFtZSxcbiAgICAgICAgICBvcnBoYW5GYWlsZWRSZXNvdXJjZXM6IG9wdGlvbnMub3JwaGFuRmFpbGVkUmVzb3VyY2VzLFxuICAgICAgICAgIHZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uOiBvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICAgIG9ycGhhbkxvZ2ljYWxJZHM6IG9wdGlvbnMub3JwaGFuTG9naWNhbElkcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3RhY2tSZXN1bHQubm90SW5Sb2xsYmFja2FibGVTdGF0ZSkge1xuICAgICAgICAgIGFueVJvbGxiYWNrYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcm9sbGJhY2tTcGFuLmVuZCgpO1xuXG4gICAgICAgIHJldC5zdGFja3MucHVzaCh7XG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHtcbiAgICAgICAgICAgIGFjY291bnQ6IHN0YWNrLmVudmlyb25tZW50LmFjY291bnQsXG4gICAgICAgICAgICByZWdpb246IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIHN0YWNrQXJuOiBzdGFja1Jlc3VsdC5zdGFja0FybixcbiAgICAgICAgICByZXN1bHQ6IHN0YWNrUmVzdWx0Lm5vdEluUm9sbGJhY2thYmxlU3RhdGUgPyAnYWxyZWFkeS1zdGFibGUnIDogJ3JvbGxlZC1iYWNrJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0U2OTAwLm1zZyhgXFxuIOKdjCAgJHtjaGFsay5ib2xkKHN0YWNrLmRpc3BsYXlOYW1lKX0gZmFpbGVkOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgICAgdGhyb3cgVG9vbGtpdEVycm9yLndpdGhDYXVzZSgnUm9sbGJhY2sgZmFpbGVkICh1c2UgLS1mb3JjZSB0byBvcnBoYW4gZmFpbGluZyByZXNvdXJjZXMpJywgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYW55Um9sbGJhY2thYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdObyBzdGFja3Mgd2VyZSBpbiBhIHN0YXRlIHRoYXQgY291bGQgYmUgcm9sbGVkIGJhY2snKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmFjdG9yIEFjdGlvbi4gTW92ZXMgcmVzb3VyY2VzIGZyb20gb25lIGxvY2F0aW9uIChzdGFjayArIGxvZ2ljYWwgSUQpIHRvIGFub3RoZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVmYWN0b3IoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlLCBvcHRpb25zOiBSZWZhY3Rvck9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlvSGVscGVyID0gYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgJ3JlZmFjdG9yJyk7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gdGhpcy5fcmVmYWN0b3IoYXNzZW1ibHksIGlvSGVscGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX3JlZmFjdG9yKGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LCBpb0hlbHBlcjogSW9IZWxwZXIsIG9wdGlvbnM6IFJlZmFjdG9yT3B0aW9ucyA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignUmVmYWN0b3IgaXMgbm90IGF2YWlsYWJsZSB5ZXQuIFRvbyBzZWUgdGhlIHByb3Bvc2VkIGNoYW5nZXMsIHVzZSB0aGUgLS1kcnktcnVuIGZsYWcuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zLnN0YWNrcz8uc3RyYXRlZ3kgPz8gU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5BTExfU1RBQ0tTO1xuICAgIGlmIChzdHJhdGVneSAhPT0gU3RhY2tTZWxlY3Rpb25TdHJhdGVneS5BTExfU1RBQ0tTKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfVzgwMTAubXNnKFxuICAgICAgICAnUmVmYWN0b3IgZG9lcyBub3QgeWV0IHN1cHBvcnQgc3RhY2sgc2VsZWN0aW9uLiBQcm9jZWVkaW5nIHdpdGggdGhlIGRlZmF1bHQgYmVoYXZpb3IgKGNvbnNpZGVyaW5nIGFsbCBzdGFja3MpLicsXG4gICAgICApKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoQUxMX1NUQUNLUyk7XG5cbiAgICBjb25zdCBzZGtQcm92aWRlciA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIoJ3JlZmFjdG9yJyk7XG4gICAgY29uc3QgbW92ZW1lbnRzID0gYXdhaXQgZmluZFJlc291cmNlTW92ZW1lbnRzKHN0YWNrcy5zdGFja0FydGlmYWN0cywgc2RrUHJvdmlkZXIpO1xuICAgIGNvbnN0IGFtYmlndW91cyA9IGFtYmlndW91c01vdmVtZW50cyhtb3ZlbWVudHMpO1xuICAgIGlmIChhbWJpZ3VvdXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCB0eXBlZE1hcHBpbmdzID0gcmVzb3VyY2VNYXBwaW5ncyhtb3ZlbWVudHMpLm1hcChtID0+IG0udG9UeXBlZE1hcHBpbmcoKSk7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTg5MDAubXNnKGZvcm1hdFR5cGVkTWFwcGluZ3ModHlwZWRNYXBwaW5ncyksIHtcbiAgICAgICAgdHlwZWRNYXBwaW5ncyxcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQW1iaWd1aXR5RXJyb3IoYW1iaWd1b3VzKTtcbiAgICAgIGNvbnN0IHBhdGhzID0gZXJyb3IucGF0aHMoKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JODkwMC5tc2coZm9ybWF0QW1iaWd1b3VzTWFwcGluZ3MocGF0aHMpLCB7XG4gICAgICAgIGFtYmlndW91c1BhdGhzOiBwYXRocyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBBY3Rpb25cbiAgICpcbiAgICogRGVzdHJveXMgdGhlIHNlbGVjdGVkIFN0YWNrcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95KGN4OiBJQ2xvdWRBc3NlbWJseVNvdXJjZSwgb3B0aW9uczogRGVzdHJveU9wdGlvbnMpOiBQcm9taXNlPERlc3Ryb3lSZXN1bHQ+IHtcbiAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIodGhpcy5pb0hvc3QsICdkZXN0cm95Jyk7XG4gICAgYXdhaXQgdXNpbmcgYXNzZW1ibHkgPSBhd2FpdCBhc3NlbWJseUZyb21Tb3VyY2UoaW9IZWxwZXIsIGN4KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fZGVzdHJveShhc3NlbWJseSwgJ2Rlc3Ryb3knLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWxsb3cgZGVzdHJveSBiZWluZyBjYWxsZWQgYXMgcGFydCBvZiB0aGUgZGVwbG95IGFjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX2Rlc3Ryb3koYXNzZW1ibHk6IFN0YWNrQXNzZW1ibHksIGFjdGlvbjogJ2RlcGxveScgfCAnZGVzdHJveScsIG9wdGlvbnM6IERlc3Ryb3lPcHRpb25zKTogUHJvbWlzZTxEZXN0cm95UmVzdWx0PiB7XG4gICAgY29uc3QgaW9IZWxwZXIgPSBhc0lvSGVscGVyKHRoaXMuaW9Ib3N0LCBhY3Rpb24pO1xuICAgIGNvbnN0IHN5bnRoU3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5TWU5USF9BU1NFTUJMWSkuYmVnaW4oeyBzdGFja3M6IG9wdGlvbnMuc3RhY2tzIH0pO1xuICAgIC8vIFRoZSBzdGFja3Mgd2lsbCBoYXZlIGJlZW4gb3JkZXJlZCBmb3IgZGVwbG95bWVudCwgc28gcmV2ZXJzZSB0aGVtIGZvciBkZWxldGlvbi5cbiAgICBjb25zdCBzdGFja3MgPSAoYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIob3B0aW9ucy5zdGFja3MpKS5yZXZlcnNlZCgpO1xuICAgIGF3YWl0IHN5bnRoU3Bhbi5lbmQoKTtcblxuICAgIGNvbnN0IHJldDogRGVzdHJveVJlc3VsdCA9IHtcbiAgICAgIHN0YWNrczogW10sXG4gICAgfTtcblxuICAgIGNvbnN0IG1vdGl2YXRpb24gPSAnRGVzdHJveWluZyBzdGFja3MgaXMgYW4gaXJyZXZlcnNpYmxlIGFjdGlvbic7XG4gICAgY29uc3QgcXVlc3Rpb24gPSBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZTogJHtjaGFsay5yZWQoc3RhY2tzLmhpZXJhcmNoaWNhbElkcy5qb2luKCcsICcpKX1gO1xuICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IGlvSGVscGVyLnJlcXVlc3RSZXNwb25zZShJTy5DREtfVE9PTEtJVF9JNzAxMC5yZXEocXVlc3Rpb24sIHsgbW90aXZhdGlvbiB9KSk7XG4gICAgaWYgKCFjb25maXJtZWQpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNzAxMC5tc2coJ0Fib3J0ZWQgYnkgdXNlcicpKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdHJveVNwYW4gPSBhd2FpdCBpb0hlbHBlci5zcGFuKFNQQU4uREVTVFJPWV9BQ1RJT04pLmJlZ2luKHtcbiAgICAgIHN0YWNrczogc3RhY2tzLnN0YWNrQXJ0aWZhY3RzLFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc3RhY2tdIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaW5nbGVEZXN0cm95U3BhbiA9IGF3YWl0IGlvSGVscGVyLnNwYW4oU1BBTi5ERVNUUk9ZX1NUQUNLKVxuICAgICAgICAgICAgLmJlZ2luKGNoYWxrLmdyZWVuKGAke2NoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpfTogZGVzdHJveWluZy4uLiBbJHtpbmRleCArIDF9LyR7c3RhY2tzLnN0YWNrQ291bnR9XWApLCB7XG4gICAgICAgICAgICAgIHRvdGFsOiBzdGFja3Muc3RhY2tDb3VudCxcbiAgICAgICAgICAgICAgY3VycmVudDogaW5kZXggKyAxLFxuICAgICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGRlcGxveW1lbnRzID0gYXdhaXQgdGhpcy5kZXBsb3ltZW50c0ZvckFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlcGxveW1lbnRzLmRlc3Ryb3lTdGFjayh7XG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIGRlcGxveU5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldC5zdGFja3MucHVzaCh7XG4gICAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgICBhY2NvdW50OiBzdGFjay5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgICAgICAgICByZWdpb246IHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFja05hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICAgIHN0YWNrQXJuOiByZXN1bHQuc3RhY2tBcm4sXG4gICAgICAgICAgICBzdGFja0V4aXN0ZWQ6IHJlc3VsdC5zdGFja0FybiAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k3OTAwLm1zZyhjaGFsay5ncmVlbihgXFxuIOKchSAgJHtjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKX06ICR7YWN0aW9ufWVkYCksIHN0YWNrKSk7XG4gICAgICAgICAgYXdhaXQgc2luZ2xlRGVzdHJveVNwYW4uZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNzkwMC5tc2coYFxcbiDinYwgICR7Y2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSl9OiAke2FjdGlvbn0gZmFpbGVkICR7ZX1gLCB7IGVycm9yOiBlIH0pKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGRlc3Ryb3lTcGFuLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgc3RhY2tzIGZvciBlcnJvcnMgYW5kIHdhcm5pbmdzIGFjY29yZGluZyB0byB0aGUgQ0xJJ3MgY3VycmVudCBzZXR0aW5nc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGF0ZVN0YWNrc01ldGFkYXRhKHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLCBpb0hvc3Q6IElvSGVscGVyKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IChsZXZlbDogSW9NZXNzYWdlTGV2ZWwpID0+IHtcbiAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOiByZXR1cm4gSU8uQ0RLX0FTU0VNQkxZX0U5OTk5O1xuICAgICAgICBjYXNlICd3YXJuJzogcmV0dXJuIElPLkNES19BU1NFTUJMWV9XOTk5OTtcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIElPLkNES19BU1NFTUJMWV9JOTk5OTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHN0YWNrcy52YWxpZGF0ZU1ldGFkYXRhKFxuICAgICAgdGhpcy5wcm9wcy5hc3NlbWJseUZhaWx1cmVBdCxcbiAgICAgIGFzeW5jIChsZXZlbCwgbXNnKSA9PiBpb0hvc3Qubm90aWZ5KGJ1aWxkZXIobGV2ZWwpLm1zZyhgWyR7bGV2ZWx9IGF0ICR7bXNnLmlkfV0gJHttc2cuZW50cnkuZGF0YX1gLCBtc2cpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRlcGxveW1lbnRzIGNsYXNzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlcGxveW1lbnRzRm9yQWN0aW9uKGFjdGlvbjogVG9vbGtpdEFjdGlvbik6IFByb21pc2U8RGVwbG95bWVudHM+IHtcbiAgICByZXR1cm4gbmV3IERlcGxveW1lbnRzKHtcbiAgICAgIHNka1Byb3ZpZGVyOiBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyKGFjdGlvbiksXG4gICAgICB0b29sa2l0U3RhY2tOYW1lOiB0aGlzLnRvb2xraXRTdGFja05hbWUsXG4gICAgICBpb0hlbHBlcjogYXNJb0hlbHBlcih0aGlzLmlvSG9zdCwgYWN0aW9uKSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW52b2tlRGVwbG95RnJvbVdhdGNoKFxuICAgIGFzc2VtYmx5OiBTdGFja0Fzc2VtYmx5LFxuICAgIG9wdGlvbnM6IFdhdGNoT3B0aW9ucyxcbiAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcj86IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHdhdGNoIGRlZmF1bHRzIGhvdHN3YXAgdG8gZW5hYmxlZFxuICAgIGNvbnN0IGhvdHN3YXAgPSBvcHRpb25zLmhvdHN3YXAgPz8gSG90c3dhcE1vZGUuSE9UU1dBUF9PTkxZO1xuICAgIGNvbnN0IGRlcGxveU9wdGlvbnM6IEV4dGVuZGVkRGVwbG95T3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcixcbiAgICAgIGhvdHN3YXAsXG4gICAgICBleHRyYVVzZXJBZ2VudDogYGNkay13YXRjaC9ob3Rzd2FwLSR7aG90c3dhcCA9PT0gSG90c3dhcE1vZGUuRlVMTF9ERVBMT1lNRU5UID8gJ29mZicgOiAnb24nfWAsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZXBsb3koYXNzZW1ibHksICd3YXRjaCcsIGRlcGxveU9wdGlvbnMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8ganVzdCBjb250aW51ZSAtIGRlcGxveSB3aWxsIHNob3cgdGhlIGVycm9yXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhlIHJlc3VsdCBvZiBhIGBjZGsud2F0Y2goKWAgb3BlcmF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElXYXRjaGVyIGV4dGVuZHMgQXN5bmNEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIFN0b3AgdGhlIHdhdGNoZXIgYW5kIHdhaXQgZm9yIHRoZSBjdXJyZW50IHdhdGNoIGl0ZXJhdGlvbiB0byBjb21wbGV0ZS5cbiAgICpcbiAgICogQW4gYWxpYXMgZm9yIGBbU3ltYm9sLmFzeW5jRGlzcG9zZV1gLCBhcyBhIG1vcmUgcmVhZGFibGUgYWx0ZXJuYXRpdmUgZm9yXG4gICAqIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIERpc3Bvc2FibGUgQVBJcyB5ZXQuXG4gICAqL1xuICBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIHRoZSB3YXRjaGVyIHRvIHN0b3AuXG4gICAqXG4gICAqIFRoZSB3YXRjaGVyIHdpbGwgb25seSBzdG9wIGlmIGBkaXNwb3NlKClgIG9yIGBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKWAgYXJlIGNhbGxlZC5cbiAgICpcbiAgICogSWYgbmVpdGhlciBvZiB0aG9zZSBpcyBjYWxsZWQsIGF3YWl0aW5nIHRoaXMgcHJvbWlzZSB3aWxsIHdhaXQgZm9yZXZlci5cbiAgICovXG4gIHdhaXRGb3JFbmQoKTogUHJvbWlzZTx2b2lkPjtcbn1cbiJdfQ==