"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTemplateInfos = makeTemplateInfos;
exports.determinePermissionType = determinePermissionType;
exports.appendObject = appendObject;
const cloudformation_diff_1 = require("@aws-cdk/cloudformation-diff");
const fs = require("fs-extra");
const uuid = require("uuid");
const __1 = require("..");
const shared_private_1 = require("../../../api/shared-private");
const shared_public_1 = require("../../../api/shared-public");
const util_1 = require("../../../private/util");
function makeTemplateInfos(ioHelper, stacks, deployments, sdkProvider, options) {
    switch (options.method?.method ?? __1.DiffMethod.ChangeSet().method) {
        case 'local-file':
            return localFileDiff(stacks, options);
        case 'template-only':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, false);
        case 'change-set':
            return cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, true);
        default:
            throw new shared_public_1.ToolkitError((0, util_1.formatErrorMessage)(`Unknown diff method ${options.method}`));
    }
}
async function localFileDiff(stacks, options) {
    const methodOptions = (options.method?.options ?? {});
    // Compare single stack against fixed template
    if (stacks.stackCount !== 1) {
        throw new shared_public_1.ToolkitError('Can only select one stack when comparing to fixed template. Use --exclusively to avoid selecting multiple stacks.');
    }
    if (!(await fs.pathExists(methodOptions.path))) {
        throw new shared_public_1.ToolkitError(`There is no file at ${methodOptions.path}`);
    }
    const file = fs.readFileSync(methodOptions.path).toString();
    const template = (0, util_1.deserializeStructure)(file);
    return [{
            oldTemplate: template,
            newTemplate: stacks.firstStack,
        }];
}
async function cfnDiff(ioHelper, stacks, deployments, options, sdkProvider, includeChangeSet) {
    const templateInfos = [];
    const methodOptions = (options.method?.options ?? {});
    // Compare N stacks against deployed templates
    for (const stack of stacks.stackArtifacts) {
        const templateWithNestedStacks = await deployments.readCurrentTemplateWithNestedStacks(stack, methodOptions.compareAgainstProcessedTemplate);
        const currentTemplate = templateWithNestedStacks.deployedRootTemplate;
        const nestedStacks = templateWithNestedStacks.nestedStacks;
        const migrator = new shared_private_1.ResourceMigrator({ deployments, ioHelper });
        const resourcesToImport = await migrator.tryGetResources(await deployments.resolveEnvironment(stack));
        if (resourcesToImport) {
            (0, shared_private_1.removeNonImportResources)(stack);
        }
        const changeSet = includeChangeSet ? await changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, methodOptions.parameters, methodOptions.fallbackToTemplate) : undefined;
        templateInfos.push({
            oldTemplate: currentTemplate,
            newTemplate: stack,
            isImport: !!resourcesToImport,
            nestedStacks,
            changeSet,
        });
    }
    return templateInfos;
}
async function changeSetDiff(ioHelper, deployments, stack, sdkProvider, resourcesToImport, parameters = {}, fallBackToTemplate = true) {
    let stackExists = false;
    try {
        stackExists = await deployments.stackExists({
            stack,
            deployName: stack.stackName,
            tryLookupRole: true,
        });
    }
    catch (e) {
        if (!fallBackToTemplate) {
            throw new shared_public_1.ToolkitError(`describeStacks call failed with ${e} for ${stack.stackName}, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.notify(shared_private_1.IO.DEFAULT_TOOLKIT_DEBUG.msg(`Checking if the stack ${stack.stackName} exists before creating the changeset has failed, will base the diff on template differences.\n`));
        await ioHelper.notify(shared_private_1.IO.DEFAULT_TOOLKIT_DEBUG.msg((0, util_1.formatErrorMessage)(e)));
        stackExists = false;
    }
    if (stackExists) {
        return shared_private_1.cfnApi.createDiffChangeSet(ioHelper, {
            stack,
            uuid: uuid.v4(),
            deployments,
            willExecute: false,
            sdkProvider,
            parameters: parameters,
            resourcesToImport,
            failOnError: !fallBackToTemplate,
        });
    }
    else {
        if (!fallBackToTemplate) {
            throw new shared_public_1.ToolkitError(`the stack '${stack.stackName}' has not been deployed to CloudFormation, set fallBackToTemplate to true or use DiffMethod.templateOnly to base the diff on template differences.`);
        }
        await ioHelper.notify(shared_private_1.IO.DEFAULT_TOOLKIT_DEBUG.msg(`the stack '${stack.stackName}' has not been deployed to CloudFormation, skipping changeset creation.`));
        return;
    }
}
/**
 * Return whether the diff has security-impacting changes that need confirmation.
 */
function determinePermissionType(oldTemplate, newTemplate, changeSet) {
    // @todo return a printable version of the full diff.
    const diff = (0, cloudformation_diff_1.fullDiff)(oldTemplate, newTemplate.template, changeSet);
    if (diff.permissionsBroadened) {
        return shared_public_1.PermissionChangeType.BROADENING;
    }
    else if (diff.permissionsAnyChanges) {
        return shared_public_1.PermissionChangeType.NON_BROADENING;
    }
    else {
        return shared_public_1.PermissionChangeType.NONE;
    }
}
/**
 * Appends all properties from obj2 to obj1.
 * obj2 values take priority in the case of collisions.
 *
 * @param obj1 The object to modify
 * @param obj2 The object to consume
 *
 * @returns obj1 with all properties from obj2
 */
function appendObject(obj1, obj2) {
    // Directly modify obj1 by adding all properties from obj2
    for (const key in obj2) {
        obj1[key] = obj2[key];
    }
    // Return the modified obj1
    return obj1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFZQSw4Q0FpQkM7QUEySEQsMERBZUM7QUFXRCxvQ0FXQztBQTVMRCxzRUFBd0Q7QUFFeEQsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUU3QiwwQkFBZ0M7QUFFaEMsZ0VBQXFHO0FBQ3JHLDhEQUFnRjtBQUNoRixnREFBaUY7QUFFakYsU0FBZ0IsaUJBQWlCLENBQy9CLFFBQWtCLEVBQ2xCLE1BQXVCLEVBQ3ZCLFdBQXdCLEVBQ3hCLFdBQXdCLEVBQ3hCLE9BQW9CO0lBRXBCLFFBQVEsT0FBTyxDQUFDLE1BQU0sRUFBRSxNQUFNLElBQUksY0FBVSxDQUFDLFNBQVMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hFLEtBQUssWUFBWTtZQUNmLE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN4QyxLQUFLLGVBQWU7WUFDbEIsT0FBTyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM3RSxLQUFLLFlBQVk7WUFDZixPQUFPLE9BQU8sQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVFO1lBQ0UsTUFBTSxJQUFJLDRCQUFZLENBQUMsSUFBQSx5QkFBa0IsRUFBQyx1QkFBdUIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RixDQUFDO0FBQ0gsQ0FBQztBQUVELEtBQUssVUFBVSxhQUFhLENBQUMsTUFBdUIsRUFBRSxPQUFvQjtJQUN4RSxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBeUIsQ0FBQztJQUU5RSw4Q0FBOEM7SUFDOUMsSUFBSSxN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RztBQUNILFNBQWdCLHVCQUF1QixDQUNyQyxXQUFnQixFQUNoQixXQUE4QyxFQUM5QyxTQUFtQztJQUVuQyxxREFBcUQ7SUFDckQsTUFBTSxJQUFJLEdBQUcsSUFBQSw4QkFBUSxFQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRXBFLElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDOUIsT0FBTyxvQ0FBb0IsQ0FBQyxVQUFVLENBQUM7SUFDekMsQ0FBQztTQUFNLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDdEMsT0FBTyxvQ0FBb0IsQ0FBQyxjQUFjLENBQUM7SUFDN0MsQ0FBQztTQUFNLENBQUM7UUFDTixPQUFPLG9DQUFvQixDQUFDLElBQUksQ0FBQztJQUNuQyxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBZ0IsWUFBWSxDQUMxQixJQUEyQixFQUMzQixJQUEyQjtJQUUzQiwwREFBMEQ7SUFDMUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCwyQkFBMkI7SUFDM0IsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBEZXNjcmliZUNoYW5nZVNldE91dHB1dCB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgZnVsbERpZmYgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgdHlwZSB7IENoYW5nZVNldERpZmZPcHRpb25zLCBEaWZmT3B0aW9ucywgTG9jYWxGaWxlRGlmZk9wdGlvbnMgfSBmcm9tICcuLic7XG5pbXBvcnQgeyBEaWZmTWV0aG9kIH0gZnJvbSAnLi4nO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3ltZW50cywgUmVzb3VyY2VzVG9JbXBvcnQsIElvSGVscGVyLCBTZGtQcm92aWRlciwgU3RhY2tDb2xsZWN0aW9uLCBUZW1wbGF0ZUluZm8gfSBmcm9tICcuLi8uLi8uLi9hcGkvc2hhcmVkLXByaXZhdGUnO1xuaW1wb3J0IHsgUmVzb3VyY2VNaWdyYXRvciwgSU8sIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcywgY2ZuQXBpIH0gZnJvbSAnLi4vLi4vLi4vYXBpL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7IFBlcm1pc3Npb25DaGFuZ2VUeXBlLCBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9hcGkvc2hhcmVkLXB1YmxpYyc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVN0cnVjdHVyZSwgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vLi4vcHJpdmF0ZS91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VUZW1wbGF0ZUluZm9zKFxuICBpb0hlbHBlcjogSW9IZWxwZXIsXG4gIHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLFxuICBkZXBsb3ltZW50czogRGVwbG95bWVudHMsXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgb3B0aW9uczogRGlmZk9wdGlvbnMsXG4pOiBQcm9taXNlPFRlbXBsYXRlSW5mb1tdPiB7XG4gIHN3aXRjaCAob3B0aW9ucy5tZXRob2Q/Lm1ldGhvZCA/PyBEaWZmTWV0aG9kLkNoYW5nZVNldCgpLm1ldGhvZCkge1xuICAgIGNhc2UgJ2xvY2FsLWZpbGUnOlxuICAgICAgcmV0dXJuIGxvY2FsRmlsZURpZmYoc3RhY2tzLCBvcHRpb25zKTtcbiAgICBjYXNlICd0ZW1wbGF0ZS1vbmx5JzpcbiAgICAgIHJldHVybiBjZm5EaWZmKGlvSGVscGVyLCBzdGFja3MsIGRlcGxveW1lbnRzLCBvcHRpb25zLCBzZGtQcm92aWRlciwgZmFsc2UpO1xuICAgIGNhc2UgJ2NoYW5nZS1zZXQnOlxuICAgICAgcmV0dXJuIGNmbkRpZmYoaW9IZWxwZXIsIHN0YWNrcywgZGVwbG95bWVudHMsIG9wdGlvbnMsIHNka1Byb3ZpZGVyLCB0cnVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihmb3JtYXRFcnJvck1lc3NhZ2UoYFVua25vd24gZGlmZiBtZXRob2QgJHtvcHRpb25zLm1ldGhvZH1gKSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9jYWxGaWxlRGlmZihzdGFja3M6IFN0YWNrQ29sbGVjdGlvbiwgb3B0aW9uczogRGlmZk9wdGlvbnMpOiBQcm9taXNlPFRlbXBsYXRlSW5mb1tdPiB7XG4gIGNvbnN0IG1ldGhvZE9wdGlvbnMgPSAob3B0aW9ucy5tZXRob2Q/Lm9wdGlvbnMgPz8ge30pIGFzIExvY2FsRmlsZURpZmZPcHRpb25zO1xuXG4gIC8vIENvbXBhcmUgc2luZ2xlIHN0YWNrIGFnYWluc3QgZml4ZWQgdGVtcGxhdGVcbiAgaWYgKHN0YWNrcy5zdGFja0NvdW50ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICdDYW4gb25seSBzZWxlY3Qgb25lIHN0YWNrIHdoZW4gY29tcGFyaW5nIHRvIGZpeGVkIHRlbXBsYXRlLiBVc2UgLS1leGNsdXNpdmVseSB0byBhdm9pZCBzZWxlY3RpbmcgbXVsdGlwbGUgc3RhY2tzLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMobWV0aG9kT3B0aW9ucy5wYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGVyZSBpcyBubyBmaWxlIGF0ICR7bWV0aG9kT3B0aW9ucy5wYXRofWApO1xuICB9XG5cbiAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhtZXRob2RPcHRpb25zLnBhdGgpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHRlbXBsYXRlID0gZGVzZXJpYWxpemVTdHJ1Y3R1cmUoZmlsZSk7XG5cbiAgcmV0dXJuIFt7XG4gICAgb2xkVGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIG5ld1RlbXBsYXRlOiBzdGFja3MuZmlyc3RTdGFjayxcbiAgfV07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNmbkRpZmYoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgc3RhY2tzOiBTdGFja0NvbGxlY3Rpb24sXG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cyxcbiAgb3B0aW9uczogRGlmZk9wdGlvbnMsXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgaW5jbHVkZUNoYW5nZVNldDogYm9vbGVhbixcbik6IFByb21pc2U8VGVtcGxhdGVJbmZvW10+IHtcbiAgY29uc3QgdGVtcGxhdGVJbmZvcyA9IFtdO1xuICBjb25zdCBtZXRob2RPcHRpb25zID0gKG9wdGlvbnMubWV0aG9kPy5vcHRpb25zID8/IHt9KSBhcyBDaGFuZ2VTZXREaWZmT3B0aW9ucztcblxuICAvLyBDb21wYXJlIE4gc3RhY2tzIGFnYWluc3QgZGVwbG95ZWQgdGVtcGxhdGVzXG4gIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgY29uc3QgdGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzID0gYXdhaXQgZGVwbG95bWVudHMucmVhZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MoXG4gICAgICBzdGFjayxcbiAgICAgIG1ldGhvZE9wdGlvbnMuY29tcGFyZUFnYWluc3RQcm9jZXNzZWRUZW1wbGF0ZSxcbiAgICApO1xuICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IHRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcy5kZXBsb3llZFJvb3RUZW1wbGF0ZTtcbiAgICBjb25zdCBuZXN0ZWRTdGFja3MgPSB0ZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MubmVzdGVkU3RhY2tzO1xuXG4gICAgY29uc3QgbWlncmF0b3IgPSBuZXcgUmVzb3VyY2VNaWdyYXRvcih7IGRlcGxveW1lbnRzLCBpb0hlbHBlciB9KTtcbiAgICBjb25zdCByZXNvdXJjZXNUb0ltcG9ydCA9IGF3YWl0IG1pZ3JhdG9yLnRyeUdldFJlc291cmNlcyhhd2FpdCBkZXBsb3ltZW50cy5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2spKTtcbiAgICBpZiAocmVzb3VyY2VzVG9JbXBvcnQpIHtcbiAgICAgIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyhzdGFjayk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gaW5jbHVkZUNoYW5nZVNldCA/IGF3YWl0IGNoYW5nZVNldERpZmYoXG4gICAgICBpb0hlbHBlcixcbiAgICAgIGRlcGxveW1lbnRzLFxuICAgICAgc3RhY2ssXG4gICAgICBzZGtQcm92aWRlcixcbiAgICAgIHJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgbWV0aG9kT3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgbWV0aG9kT3B0aW9ucy5mYWxsYmFja1RvVGVtcGxhdGUsXG4gICAgKSA6IHVuZGVmaW5lZDtcblxuICAgIHRlbXBsYXRlSW5mb3MucHVzaCh7XG4gICAgICBvbGRUZW1wbGF0ZTogY3VycmVudFRlbXBsYXRlLFxuICAgICAgbmV3VGVtcGxhdGU6IHN0YWNrLFxuICAgICAgaXNJbXBvcnQ6ICEhcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICBuZXN0ZWRTdGFja3MsXG4gICAgICBjaGFuZ2VTZXQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGVJbmZvcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hhbmdlU2V0RGlmZihcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBkZXBsb3ltZW50czogRGVwbG95bWVudHMsXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgcmVzb3VyY2VzVG9JbXBvcnQ/OiBSZXNvdXJjZXNUb0ltcG9ydCxcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gPSB7fSxcbiAgZmFsbEJhY2tUb1RlbXBsYXRlOiBib29sZWFuID0gdHJ1ZSxcbik6IFByb21pc2U8YW55IHwgdW5kZWZpbmVkPiB7XG4gIGxldCBzdGFja0V4aXN0cyA9IGZhbHNlO1xuICB0cnkge1xuICAgIHN0YWNrRXhpc3RzID0gYXdhaXQgZGVwbG95bWVudHMuc3RhY2tFeGlzdHMoe1xuICAgICAgc3RhY2ssXG4gICAgICBkZXBsb3lOYW1lOiBzdGFjay5zdGFja05hbWUsXG4gICAgICB0cnlMb29rdXBSb2xlOiB0cnVlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoIWZhbGxCYWNrVG9UZW1wbGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgZGVzY3JpYmVTdGFja3MgY2FsbCBmYWlsZWQgd2l0aCAke2V9IGZvciAke3N0YWNrLnN0YWNrTmFtZX0sIHNldCBmYWxsQmFja1RvVGVtcGxhdGUgdG8gdHJ1ZSBvciB1c2UgRGlmZk1ldGhvZC50ZW1wbGF0ZU9ubHkgdG8gYmFzZSB0aGUgZGlmZiBvbiB0ZW1wbGF0ZSBkaWZmZXJlbmNlcy5gKTtcbiAgICB9XG5cbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhgQ2hlY2tpbmcgaWYgdGhlIHN0YWNrICR7c3RhY2suc3RhY2tOYW1lfSBleGlzdHMgYmVmb3JlIGNyZWF0aW5nIHRoZSBjaGFuZ2VzZXQgaGFzIGZhaWxlZCwgd2lsbCBiYXNlIHRoZSBkaWZmIG9uIHRlbXBsYXRlIGRpZmZlcmVuY2VzLlxcbmApKTtcbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhmb3JtYXRFcnJvck1lc3NhZ2UoZSkpKTtcbiAgICBzdGFja0V4aXN0cyA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YWNrRXhpc3RzKSB7XG4gICAgcmV0dXJuIGNmbkFwaS5jcmVhdGVEaWZmQ2hhbmdlU2V0KGlvSGVscGVyLCB7XG4gICAgICBzdGFjayxcbiAgICAgIHV1aWQ6IHV1aWQudjQoKSxcbiAgICAgIGRlcGxveW1lbnRzLFxuICAgICAgd2lsbEV4ZWN1dGU6IGZhbHNlLFxuICAgICAgc2RrUHJvdmlkZXIsXG4gICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICBmYWlsT25FcnJvcjogIWZhbGxCYWNrVG9UZW1wbGF0ZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWZhbGxCYWNrVG9UZW1wbGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgdGhlIHN0YWNrICcke3N0YWNrLnN0YWNrTmFtZX0nIGhhcyBub3QgYmVlbiBkZXBsb3llZCB0byBDbG91ZEZvcm1hdGlvbiwgc2V0IGZhbGxCYWNrVG9UZW1wbGF0ZSB0byB0cnVlIG9yIHVzZSBEaWZmTWV0aG9kLnRlbXBsYXRlT25seSB0byBiYXNlIHRoZSBkaWZmIG9uIHRlbXBsYXRlIGRpZmZlcmVuY2VzLmApO1xuICAgIH1cblxuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfREVCVUcubXNnKGB0aGUgc3RhY2sgJyR7c3RhY2suc3RhY2tOYW1lfScgaGFzIG5vdCBiZWVuIGRlcGxveWVkIHRvIENsb3VkRm9ybWF0aW9uLCBza2lwcGluZyBjaGFuZ2VzZXQgY3JlYXRpb24uYCkpO1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBkaWZmIGhhcyBzZWN1cml0eS1pbXBhY3RpbmcgY2hhbmdlcyB0aGF0IG5lZWQgY29uZmlybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lUGVybWlzc2lvblR5cGUoXG4gIG9sZFRlbXBsYXRlOiBhbnksXG4gIG5ld1RlbXBsYXRlOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gIGNoYW5nZVNldD86IERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0LFxuKTogUGVybWlzc2lvbkNoYW5nZVR5cGUge1xuICAvLyBAdG9kbyByZXR1cm4gYSBwcmludGFibGUgdmVyc2lvbiBvZiB0aGUgZnVsbCBkaWZmLlxuICBjb25zdCBkaWZmID0gZnVsbERpZmYob2xkVGVtcGxhdGUsIG5ld1RlbXBsYXRlLnRlbXBsYXRlLCBjaGFuZ2VTZXQpO1xuXG4gIGlmIChkaWZmLnBlcm1pc3Npb25zQnJvYWRlbmVkKSB7XG4gICAgcmV0dXJuIFBlcm1pc3Npb25DaGFuZ2VUeXBlLkJST0FERU5JTkc7XG4gIH0gZWxzZSBpZiAoZGlmZi5wZXJtaXNzaW9uc0FueUNoYW5nZXMpIHtcbiAgICByZXR1cm4gUGVybWlzc2lvbkNoYW5nZVR5cGUuTk9OX0JST0FERU5JTkc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFBlcm1pc3Npb25DaGFuZ2VUeXBlLk5PTkU7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmRzIGFsbCBwcm9wZXJ0aWVzIGZyb20gb2JqMiB0byBvYmoxLlxuICogb2JqMiB2YWx1ZXMgdGFrZSBwcmlvcml0eSBpbiB0aGUgY2FzZSBvZiBjb2xsaXNpb25zLlxuICpcbiAqIEBwYXJhbSBvYmoxIFRoZSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0gb2JqMiBUaGUgb2JqZWN0IHRvIGNvbnN1bWVcbiAqXG4gKiBAcmV0dXJucyBvYmoxIHdpdGggYWxsIHByb3BlcnRpZXMgZnJvbSBvYmoyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRPYmplY3Q8VD4oXG4gIG9iajE6IHsgW25hbWU6IHN0cmluZ106IFQgfSxcbiAgb2JqMjogeyBbbmFtZTogc3RyaW5nXTogVCB9LFxuKTogeyBbbmFtZTogc3RyaW5nXTogVCB9IHtcbiAgLy8gRGlyZWN0bHkgbW9kaWZ5IG9iajEgYnkgYWRkaW5nIGFsbCBwcm9wZXJ0aWVzIGZyb20gb2JqMlxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmoyKSB7XG4gICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmoxXG4gIHJldHVybiBvYmoxO1xufVxuIl19