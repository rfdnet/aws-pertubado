"use strict";
var __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(exports, "__esModule", { value: true });
exports.BootstrapSource = exports.BootstrapStackParameters = exports.BootstrapEnvironments = void 0;
const private_1 = require("./private");
const private_2 = require("../../api/cloud-assembly/private");
const shared_private_1 = require("../../api/shared-private");
const private_3 = require("../../toolkit/private");
/**
 * Create manage bootstrap environments
 */
class BootstrapEnvironments {
    envProvider;
    /**
     * Create from a list of environment descriptors
     * List of strings like `['aws://012345678912/us-east-1', 'aws://234567890123/eu-west-1']`
     */
    static fromList(environments) {
        return new BootstrapEnvironments((0, private_1.environmentsFromDescriptors)(environments));
    }
    /**
     * Create from a cloud assembly source
     */
    static fromCloudAssemblySource(cx) {
        return new BootstrapEnvironments(async (ioHost) => {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const ioHelper = (0, shared_private_1.asIoHelper)(ioHost, 'bootstrap');
                const assembly = __addDisposableResource(env_1, await (0, private_3.assemblyFromSource)(ioHelper, cx), true);
                const stackCollection = await assembly.selectStacksV2(private_2.ALL_STACKS);
                return stackCollection.stackArtifacts.map(stack => stack.environment);
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                const result_1 = __disposeResources(env_1);
                if (result_1)
                    await result_1;
            }
        });
    }
    constructor(envProvider) {
        this.envProvider = envProvider;
    }
    /**
     * Compute the bootstrap enviornments
     *
     * @internal
     */
    async getEnvironments(ioHost) {
        if (Array.isArray(this.envProvider)) {
            return this.envProvider;
        }
        return this.envProvider(ioHost);
    }
}
exports.BootstrapEnvironments = BootstrapEnvironments;
/**
 * Parameters of the bootstrapping template with flexible configuration options
 */
class BootstrapStackParameters {
    /**
     * Use only existing parameters on the stack.
     */
    static onlyExisting() {
        return new BootstrapStackParameters({}, true);
    }
    /**
     * Use exactly these parameters and remove any other existing parameters from the stack.
     */
    static exactly(params) {
        return new BootstrapStackParameters(params, false);
    }
    /**
     * Define additional parameters for the stack, while keeping existing parameters for unspecified values.
     */
    static withExisting(params) {
        return new BootstrapStackParameters(params, true);
    }
    /**
     * The parameters as a Map for easy access and manipulation
     */
    parameters;
    keepExistingParameters;
    constructor(params, usePreviousParameters = true) {
        this.keepExistingParameters = usePreviousParameters;
        this.parameters = params;
    }
}
exports.BootstrapStackParameters = BootstrapStackParameters;
/**
 * Source configuration for bootstrap operations
 */
class BootstrapSource {
    /**
     * Use the default bootstrap template
     */
    static default() {
        return { source: 'default' };
    }
    /**
     * Use a custom bootstrap template
     */
    static customTemplate(templateFile) {
        return {
            source: 'custom',
            templateFile,
        };
    }
}
exports.BootstrapSource = BootstrapSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsdUNBQXdEO0FBRXhELDhEQUE4RDtBQUc5RCw2REFBc0Q7QUFDdEQsbURBQTJEO0FBRTNEOztHQUVHO0FBQ0gsTUFBYSxxQkFBcUI7SUFxQks7SUFwQnJDOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBc0I7UUFDcEMsT0FBTyxJQUFJLHFCQUFxQixDQUFDLElBQUEscUNBQTJCLEVBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsdUJBQXVCLENBQUMsRUFBd0I7UUFDckQsT0FBTyxJQUFJLHFCQUFxQixDQUFDLEtBQUssRUFBRSxNQUFlLEVBQUUsRUFBRTs7O2dCQUN6RCxNQUFNLFFBQVEsR0FBRyxJQUFBLDJCQUFVLEVBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO2dCQUNqRCxNQUFZLFFBQVEsa0NBQUcsTUFBTSxJQUFBLDRCQUFrQixFQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsT0FBQSxDQUFDO2dCQUM5RCxNQUFNLGVBQWUsR0FBRyxNQUFNLFFBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQVUsQ0FBQyxDQUFDO2dCQUNsRSxPQUFPLGVBQWUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7OztTQUN2RSxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsWUFBcUMsV0FBc0Y7UUFBdEYsZ0JBQVcsR0FBWCxXQUFXLENBQTJFO0lBRTNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFlO1FBQ25DLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQztZQUNwQyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDMUIsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsQyxDQUFDO0NBQ0Y7QUFwQ0Qsc0RBb0NDO0FBK0lEOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkM7O09BRUc7SUFDSSxNQUFNLENBQUMsWUFBWTtRQUN4QixPQUFPLElBQUksd0JBQXdCLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBMkI7UUFDL0MsT0FBTyxJQUFJLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQTJCO1FBQ3BELE9BQU8sSUFBSSx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ2EsVUFBVSxDQUF1QjtJQUNqQyxzQkFBc0IsQ0FBVTtJQUVoRCxZQUFvQixNQUE0QixFQUFFLHFCQUFxQixHQUFHLElBQUk7UUFDNUUsSUFBSSxDQUFDLHNCQUFzQixHQUFHLHFCQUFxQixDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDO0lBQzNCLENBQUM7Q0FDRjtBQWhDRCw0REFnQ0M7QUFFRDs7R0FFRztBQUNILE1BQWEsZUFBZTtJQUMxQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxPQUFPO1FBQ1osT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsY0FBYyxDQUFDLFlBQW9CO1FBQ3hDLE9BQU87WUFDTCxNQUFNLEVBQUUsUUFBUTtZQUNoQixZQUFZO1NBQ2IsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQWpCRCwwQ0FpQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBlbnZpcm9ubWVudHNGcm9tRGVzY3JpcHRvcnMgfSBmcm9tICcuL3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJQ2xvdWRBc3NlbWJseVNvdXJjZSB9IGZyb20gJy4uLy4uL2FwaS9jbG91ZC1hc3NlbWJseSc7XG5pbXBvcnQgeyBBTExfU1RBQ0tTIH0gZnJvbSAnLi4vLi4vYXBpL2Nsb3VkLWFzc2VtYmx5L3ByaXZhdGUnO1xuaW1wb3J0IHR5cGUgeyBJSW9Ib3N0IH0gZnJvbSAnLi4vLi4vYXBpL2lvJztcbmltcG9ydCB0eXBlIHsgVGFnIH0gZnJvbSAnLi4vLi4vYXBpL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7IGFzSW9IZWxwZXIgfSBmcm9tICcuLi8uLi9hcGkvc2hhcmVkLXByaXZhdGUnO1xuaW1wb3J0IHsgYXNzZW1ibHlGcm9tU291cmNlIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9wcml2YXRlJztcblxuLyoqXG4gKiBDcmVhdGUgbWFuYWdlIGJvb3RzdHJhcCBlbnZpcm9ubWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcEVudmlyb25tZW50cyB7XG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGxpc3Qgb2YgZW52aXJvbm1lbnQgZGVzY3JpcHRvcnNcbiAgICogTGlzdCBvZiBzdHJpbmdzIGxpa2UgYFsnYXdzOi8vMDEyMzQ1Njc4OTEyL3VzLWVhc3QtMScsICdhd3M6Ly8yMzQ1Njc4OTAxMjMvZXUtd2VzdC0xJ11gXG4gICAqL1xuICBzdGF0aWMgZnJvbUxpc3QoZW52aXJvbm1lbnRzOiBzdHJpbmdbXSk6IEJvb3RzdHJhcEVudmlyb25tZW50cyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBFbnZpcm9ubWVudHMoZW52aXJvbm1lbnRzRnJvbURlc2NyaXB0b3JzKGVudmlyb25tZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmcm9tIGEgY2xvdWQgYXNzZW1ibHkgc291cmNlXG4gICAqL1xuICBzdGF0aWMgZnJvbUNsb3VkQXNzZW1ibHlTb3VyY2UoY3g6IElDbG91ZEFzc2VtYmx5U291cmNlKTogQm9vdHN0cmFwRW52aXJvbm1lbnRzIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcEVudmlyb25tZW50cyhhc3luYyAoaW9Ib3N0OiBJSW9Ib3N0KSA9PiB7XG4gICAgICBjb25zdCBpb0hlbHBlciA9IGFzSW9IZWxwZXIoaW9Ib3N0LCAnYm9vdHN0cmFwJyk7XG4gICAgICBhd2FpdCB1c2luZyBhc3NlbWJseSA9IGF3YWl0IGFzc2VtYmx5RnJvbVNvdXJjZShpb0hlbHBlciwgY3gpO1xuICAgICAgY29uc3Qgc3RhY2tDb2xsZWN0aW9uID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzVjIoQUxMX1NUQUNLUyk7XG4gICAgICByZXR1cm4gc3RhY2tDb2xsZWN0aW9uLnN0YWNrQXJ0aWZhY3RzLm1hcChzdGFjayA9PiBzdGFjay5lbnZpcm9ubWVudCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZW52UHJvdmlkZXI6IGN4YXBpLkVudmlyb25tZW50W10gfCAoKGlvSG9zdDogSUlvSG9zdCkgPT4gUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudFtdPikpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGJvb3RzdHJhcCBlbnZpb3JubWVudHNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBnZXRFbnZpcm9ubWVudHMoaW9Ib3N0OiBJSW9Ib3N0KTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudFtdPiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5lbnZQcm92aWRlcikpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudlByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbnZQcm92aWRlcihpb0hvc3QpO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgQm9vdHN0cmFwXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIEJvb3RzdHJhcCBlbnZpcm9ubWVudCBwYXJhbWV0ZXJzIGZvciBDbG91ZEZvcm1hdGlvbiB1c2VkIHdoZW4gZGVwbG95aW5nIHRoZSBib290c3RyYXAgc3RhY2tcbiAgICogQGRlZmF1bHQgQm9vdHN0cmFwRW52aXJvbm1lbnRQYXJhbWV0ZXJzLm9ubHlFeGlzdGluZygpXG4gICAqL1xuICByZWFkb25seSBwYXJhbWV0ZXJzPzogQm9vdHN0cmFwU3RhY2tQYXJhbWV0ZXJzO1xuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgc291cmNlIG9mIHRoZSBib290c3RyYXAgc3RhY2tcbiAgICpcbiAgICogQGRlZmF1bHQgQm9vdHN0cmFwU291cmNlLmRlZmF1bHQoKVxuICAgKi9cbiAgcmVhZG9ubHkgc291cmNlPzogeyBzb3VyY2U6ICdkZWZhdWx0JyB9IHwgeyBzb3VyY2U6ICdjdXN0b20nOyB0ZW1wbGF0ZUZpbGU6IHN0cmluZyB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGV4ZWN1dGUgdGhlIGNoYW5nZXNldCBvciBvbmx5IGNyZWF0ZSBpdCBhbmQgbGVhdmUgaXQgaW4gcmV2aWV3XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGV4ZWN1dGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUYWdzIGZvciBjZGt0b29sa2l0IHN0YWNrXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSB0YWdzPzogVGFnW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN0YWNrcyBjcmVhdGVkIGJ5IHRoZSBib290c3RyYXAgcHJvY2VzcyBzaG91bGQgYmUgcHJvdGVjdGVkIGZyb20gdGVybWluYXRpb25cbiAgICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS91c2luZy1jZm4tcHJvdGVjdC1zdGFja3MuaHRtbFxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB0ZXJtaW5hdGlvblByb3RlY3Rpb24/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFBhcmFtZXRlciB2YWx1ZXMgZm9yIHRoZSBib290c3RyYXBwaW5nIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwUGFyYW1ldGVycyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSB0byBiZSBnaXZlbiB0byB0aGUgQ0RLIEJvb3RzdHJhcCBidWNrZXRcbiAgICogQnkgZGVmYXVsdCwgYSBuYW1lIGlzIGdlbmVyYXRlZCBieSBDbG91ZEZvcm1hdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZhbHVlLCBvcHRpb25hbCBhcmd1bWVudFxuICAgKi9cbiAgcmVhZG9ubHkgYnVja2V0TmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIGV4aXN0aW5nIEtNUyBrZXkgdG8gYmUgdXNlZCBmb3IgZW5jcnlwdGluZyBpdGVtcyBpbiB0aGUgYnVja2V0XG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0IEtNUyBrZXkgaXMgdXNlZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZhbHVlLCBvcHRpb25hbCBhcmd1bWVudFxuICAgKi9cbiAgcmVhZG9ubHkga21zS2V5SWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGNyZWF0ZSBhIG5ldyBjdXN0b21lciBtYXN0ZXIga2V5IChDTUspXG4gICAqXG4gICAqIE9ubHkgYXBwbGllcyB0byBtb2Rlcm4gYm9vdHN0cmFwcGluZ1xuICAgKiBMZWdhY3kgYm9vdHN0cmFwcGluZyB3aWxsIG5ldmVyIGNyZWF0ZSBhIENNSywgb25seSB1c2UgdGhlIGRlZmF1bHQgUzMga2V5XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjcmVhdGVDdXN0b21lck1hc3RlcktleT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIEFXUyBhY2NvdW50IElEcyB0aGF0IGFyZSB0cnVzdGVkIHRvIGRlcGxveSBpbnRvIHRoZSBlbnZpcm9ubWVudCBiZWluZyBib290c3RyYXBwZWRcbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHJlYWRvbmx5IHRydXN0ZWRBY2NvdW50cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBBV1MgYWNjb3VudCBJRHMgdGhhdCBhcmUgdHJ1c3RlZCB0byBsb29rIHVwIHZhbHVlcyBpbiB0aGUgZW52aXJvbm1lbnQgYmVpbmcgYm9vdHN0cmFwcGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXA/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgQVdTIGFjY291bnQgSURzIHRoYXQgc2hvdWxkIG5vdCBiZSB0cnVzdGVkIGJ5IHRoZSBib290c3RyYXBwZWQgZW52aXJvbm1lbnRcbiAgICogSWYgdGhlc2UgYWNjb3VudHMgYXJlIGFscmVhZHkgdHJ1c3RlZCwgdGhleSB3aWxsIGJlIHJlbW92ZWQgb24gYm9vdHN0cmFwcGluZ1xuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgdW50cnVzdGVkQWNjb3VudHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogVGhlIEFSTnMgb2YgdGhlIElBTSBtYW5hZ2VkIHBvbGljaWVzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoZSByb2xlIHBlcmZvcm1pbmcgQ2xvdWRGb3JtYXRpb24gZGVwbG95bWVudHNcbiAgICogSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIHRoZSBBZG1pbmlzdHJhdG9yQWNjZXNzIHBvbGljeVxuICAgKiBBdCBsZWFzdCBvbmUgcG9saWN5IGlzIHJlcXVpcmVkIGlmIGB0cnVzdGVkQWNjb3VudHNgIHdlcmUgcGFzc2VkXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgdG8gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgYm9vdHN0cmFwcGVkIGVudmlyb25tZW50c1xuICAgKiBUaGUgZGVmYXVsdCBxdWFsaWZpZXIgaXMgYW4gYXJiaXRyYXJ5IGJ1dCB1bmlxdWUgc3RyaW5nXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gJ2huYjY1OWZkcydcbiAgICovXG4gIHJlYWRvbmx5IHF1YWxpZmllcj86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gZW5hYmxlIFMzIFN0YWdpbmcgQnVja2V0IFB1YmxpYyBBY2Nlc3MgQmxvY2sgQ29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBwdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb24/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBGbGFnIGZvciB1c2luZyB0aGUgZGVmYXVsdCBwZXJtaXNzaW9ucyBib3VuZGFyeSBmb3IgYm9vdHN0cmFwcGluZ1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHZhbHVlLCBvcHRpb25hbCBhcmd1bWVudFxuICAgKi9cbiAgcmVhZG9ubHkgZXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBOYW1lIGZvciB0aGUgY3VzdG9tZXIncyBjdXN0b20gcGVybWlzc2lvbnMgYm91bmRhcnkgZm9yIGJvb3RzdHJhcHBpbmdcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyB2YWx1ZSwgb3B0aW9uYWwgYXJndW1lbnRcbiAgICovXG4gIHJlYWRvbmx5IGN1c3RvbVBlcm1pc3Npb25zQm91bmRhcnk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW52aXJvbm1lbnRCb290c3RyYXBSZXN1bHQge1xuICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ25vLW9wJztcbiAgZHVyYXRpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb290c3RyYXBSZXN1bHQge1xuICBlbnZpcm9ubWVudHM6IEVudmlyb25tZW50Qm9vdHN0cmFwUmVzdWx0W107XG4gIGR1cmF0aW9uOiBudW1iZXI7XG59XG5cbi8qKlxuICogUGFyYW1ldGVycyBvZiB0aGUgYm9vdHN0cmFwcGluZyB0ZW1wbGF0ZSB3aXRoIGZsZXhpYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwU3RhY2tQYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIFVzZSBvbmx5IGV4aXN0aW5nIHBhcmFtZXRlcnMgb24gdGhlIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvbmx5RXhpc3RpbmcoKSB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja1BhcmFtZXRlcnMoe30sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBleGFjdGx5IHRoZXNlIHBhcmFtZXRlcnMgYW5kIHJlbW92ZSBhbnkgb3RoZXIgZXhpc3RpbmcgcGFyYW1ldGVycyBmcm9tIHRoZSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZXhhY3RseShwYXJhbXM6IEJvb3RzdHJhcFBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrUGFyYW1ldGVycyhwYXJhbXMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc3RhY2ssIHdoaWxlIGtlZXBpbmcgZXhpc3RpbmcgcGFyYW1ldGVycyBmb3IgdW5zcGVjaWZpZWQgdmFsdWVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB3aXRoRXhpc3RpbmcocGFyYW1zOiBCb290c3RyYXBQYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja1BhcmFtZXRlcnMocGFyYW1zLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGFyYW1ldGVycyBhcyBhIE1hcCBmb3IgZWFzeSBhY2Nlc3MgYW5kIG1hbmlwdWxhdGlvblxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBhcmFtZXRlcnM/OiBCb290c3RyYXBQYXJhbWV0ZXJzO1xuICBwdWJsaWMgcmVhZG9ubHkga2VlcEV4aXN0aW5nUGFyYW1ldGVyczogYm9vbGVhbjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKHBhcmFtcz86IEJvb3RzdHJhcFBhcmFtZXRlcnMsIHVzZVByZXZpb3VzUGFyYW1ldGVycyA9IHRydWUpIHtcbiAgICB0aGlzLmtlZXBFeGlzdGluZ1BhcmFtZXRlcnMgPSB1c2VQcmV2aW91c1BhcmFtZXRlcnM7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1zO1xuICB9XG59XG5cbi8qKlxuICogU291cmNlIGNvbmZpZ3VyYXRpb24gZm9yIGJvb3RzdHJhcCBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBTb3VyY2Uge1xuICAvKipcbiAgICogVXNlIHRoZSBkZWZhdWx0IGJvb3RzdHJhcCB0ZW1wbGF0ZVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHQoKTogQm9vdHN0cmFwT3B0aW9uc1snc291cmNlJ10ge1xuICAgIHJldHVybiB7IHNvdXJjZTogJ2RlZmF1bHQnIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlIGEgY3VzdG9tIGJvb3RzdHJhcCB0ZW1wbGF0ZVxuICAgKi9cbiAgc3RhdGljIGN1c3RvbVRlbXBsYXRlKHRlbXBsYXRlRmlsZTogc3RyaW5nKTogQm9vdHN0cmFwT3B0aW9uc1snc291cmNlJ10ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6ICdjdXN0b20nLFxuICAgICAgdGVtcGxhdGVGaWxlLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==