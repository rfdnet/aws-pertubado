import * as cxapi from '@aws-cdk/cx-api';
import { CloudFormationStackArtifact } from '@aws-cdk/cx-api';
import { StackEvent } from '@aws-sdk/client-cloudformation';

interface BootstrapRole {
	/**
	 * The ARN of the IAM role created as part of bootrapping
	 * e.g. lookupRoleArn
	 */
	readonly arn: string;
	/**
	 * External ID to use when assuming the bootstrap role
	 *
	 * @default - No external ID
	 */
	readonly assumeRoleExternalId?: string;
	/**
	 * Additional options to pass to STS when assuming the role.
	 *
	 * - `RoleArn` should not be used. Use the dedicated `arn` property instead.
	 * - `ExternalId` should not be used. Use the dedicated `assumeRoleExternalId` instead.
	 *
	 * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property
	 * @default - No additional options.
	 */
	readonly assumeRoleAdditionalOptions?: {
		[key: string]: any;
	};
	/**
	 * Version of bootstrap stack required to use this role
	 *
	 * @default - No bootstrap stack required
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * Name of SSM parameter with bootstrap stack version
	 *
	 * @default - Discover SSM parameter by reading stack
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
}
interface AwsCloudFormationStackProperties {
	/**
	 * A file relative to the assembly root which contains the CloudFormation template for this stack.
	 */
	readonly templateFile: string;
	/**
	 * Values for CloudFormation stack parameters that should be passed when the stack is deployed.
	 *
	 * @default - No parameters
	 */
	readonly parameters?: {
		[id: string]: string;
	};
	/**
	 * Values for CloudFormation stack tags that should be passed when the stack is deployed.
	 *
	 * @default - No tags
	 */
	readonly tags?: {
		[id: string]: string;
	};
	/**
	 * SNS Notification ARNs that should receive CloudFormation Stack Events.
	 *
	 * @default - No notification arns
	 */
	readonly notificationArns?: string[];
	/**
	 * The name to use for the CloudFormation stack.
	 * @default - name derived from artifact ID
	 */
	readonly stackName?: string;
	/**
	 * Whether to enable termination protection for this stack.
	 *
	 * @default false
	 */
	readonly terminationProtection?: boolean;
	/**
	 * The role that needs to be assumed to deploy the stack
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly assumeRoleArn?: string;
	/**
	 * External ID to use when assuming role for cloudformation deployments
	 *
	 * @default - No external ID
	 */
	readonly assumeRoleExternalId?: string;
	/**
	 * Additional options to pass to STS when assuming the role.
	 *
	 * - `RoleArn` should not be used. Use the dedicated `assumeRoleArn` property instead.
	 * - `ExternalId` should not be used. Use the dedicated `assumeRoleExternalId` instead.
	 *
	 * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property
	 * @default - No additional options.
	 */
	readonly assumeRoleAdditionalOptions?: {
		[key: string]: any;
	};
	/**
	 * The role that is passed to CloudFormation to execute the change set
	 *
	 * @default - No role is passed (currently assumed role/credentials are used)
	 */
	readonly cloudFormationExecutionRoleArn?: string;
	/**
	 * The role to use to look up values from the target AWS account
	 *
	 * @default - No role is assumed (current credentials are used)
	 */
	readonly lookupRole?: BootstrapRole;
	/**
	 * If the stack template has already been included in the asset manifest, its asset URL
	 *
	 * @default - Not uploaded yet, upload just before deploying
	 */
	readonly stackTemplateAssetObjectUrl?: string;
	/**
	 * Version of bootstrap stack required to deploy this stack
	 *
	 * @default - No bootstrap stack required
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * SSM parameter where the bootstrap stack version number can be found
	 *
	 * Only used if `requiresBootstrapStackVersion` is set.
	 *
	 * - If this value is not set, the bootstrap stack name must be known at
	 *   deployment time so the stack version can be looked up from the stack
	 *   outputs.
	 * - If this value is set, the bootstrap stack can have any name because
	 *   we won't need to look it up.
	 *
	 * @default - Bootstrap stack version number looked up
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
	/**
	 * Whether this stack should be validated by the CLI after synthesis
	 *
	 * @default - false
	 */
	readonly validateOnSynth?: boolean;
}
interface AssetManifestOptions {
	/**
	 * Version of bootstrap stack required to deploy this stack
	 *
	 * @default - Version 1 (basic modern bootstrap stack)
	 */
	readonly requiresBootstrapStackVersion?: number;
	/**
	 * SSM parameter where the bootstrap stack version number can be found
	 *
	 * - If this value is not set, the bootstrap stack name must be known at
	 *   deployment time so the stack version can be looked up from the stack
	 *   outputs.
	 * - If this value is set, the bootstrap stack can have any name because
	 *   we won't need to look it up.
	 *
	 * @default - Bootstrap stack version number looked up
	 */
	readonly bootstrapStackVersionSsmParameter?: string;
}
interface AssetManifestProperties extends AssetManifestOptions {
	/**
	 * Filename of the asset manifest
	 */
	readonly file: string;
}
interface TreeArtifactProperties {
	/**
	 * Filename of the tree artifact
	 */
	readonly file: string;
}
interface NestedCloudAssemblyProperties {
	/**
	 * Relative path to the nested cloud assembly
	 */
	readonly directoryName: string;
	/**
	 * Display name for the cloud assembly
	 *
	 * @default - The artifact ID
	 */
	readonly displayName?: string;
}
type ArtifactProperties = AwsCloudFormationStackProperties | AssetManifestProperties | TreeArtifactProperties | NestedCloudAssemblyProperties;
interface BaseAssetMetadataEntry {
	/**
	 * Requested packaging style
	 */
	readonly packaging: string;
	/**
	 * Logical identifier for the asset
	 */
	readonly id: string;
	/**
	 * The hash of the asset source.
	 */
	readonly sourceHash: string;
	/**
	 * Path on disk to the asset
	 */
	readonly path: string;
}
interface FileAssetMetadataEntry extends BaseAssetMetadataEntry {
	/**
	 * Requested packaging style
	 */
	readonly packaging: "zip" | "file";
	/**
	 * Name of parameter where S3 bucket should be passed in
	 */
	readonly s3BucketParameter: string;
	/**
	 * Name of parameter where S3 key should be passed in
	 */
	readonly s3KeyParameter: string;
	/**
	 * The name of the parameter where the hash of the bundled asset should be passed in.
	 */
	readonly artifactHashParameter: string;
}
interface Tag {
	/**
	 * Tag key.
	 *
	 * (In the actual file on disk this will be cased as "Key", and the structure is
	 * patched to match this structure upon loading:
	 * https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
	 */
	readonly key: string;
	/**
	 * Tag value.
	 *
	 * (In the actual file on disk this will be cased as "Value", and the structure is
	 * patched to match this structure upon loading:
	 * https://github.com/aws/aws-cdk/blob/4aadaa779b48f35838cccd4e25107b2338f05547/packages/%40aws-cdk/cloud-assembly-schema/lib/manifest.ts#L137)
	 */
	readonly value: string;
}
interface ContainerImageAssetCacheOption {
	/**
	 * The type of cache to use.
	 * Refer to https://docs.docker.com/build/cache/backends/ for full list of backends.
	 * @default - unspecified
	 *
	 * @example 'registry'
	 */
	readonly type: string;
	/**
	 * Any parameters to pass into the docker cache backend configuration.
	 * Refer to https://docs.docker.com/build/cache/backends/ for cache backend configuration.
	 * @default {} No options provided
	 *
	 * @example
	 * declare const branch: string;
	 *
	 * const params = {
	 *   ref: `12345678.dkr.ecr.us-west-2.amazonaws.com/cache:${branch}`,
	 *   mode: "max",
	 * };
	 */
	readonly params?: {
		[key: string]: string;
	};
}
interface ContainerImageAssetMetadataEntry extends BaseAssetMetadataEntry {
	/**
	 * Type of asset
	 */
	readonly packaging: "container-image";
	/**
	 * ECR Repository name and repo digest (separated by "@sha256:") where this
	 * image is stored.
	 *
	 * @default undefined If not specified, `repositoryName` and `imageTag` are
	 * required because otherwise how will the stack know where to find the asset,
	 * ha?
	 * @deprecated specify `repositoryName` and `imageTag` instead, and then you
	 * know where the image will go.
	 */
	readonly imageNameParameter?: string;
	/**
	 * ECR repository name, if omitted a default name based on the asset's ID is
	 * used instead. Specify this property if you need to statically address the
	 * image, e.g. from a Kubernetes Pod. Note, this is only the repository name,
	 * without the registry and the tag parts.
	 *
	 * @default - this parameter is REQUIRED after 1.21.0
	 */
	readonly repositoryName?: string;
	/**
	 * The docker image tag to use for tagging pushed images. This field is
	 * required if `imageParameterName` is ommited (otherwise, the app won't be
	 * able to find the image).
	 *
	 * @default - this parameter is REQUIRED after 1.21.0
	 */
	readonly imageTag?: string;
	/**
	 * Build args to pass to the `docker build` command
	 *
	 * @default no build args are passed
	 */
	readonly buildArgs?: {
		[key: string]: string;
	};
	/**
	 * SSH agent socket or keys to pass to the `docker build` command
	 *
	 * @default no ssh arg is passed
	 */
	readonly buildSsh?: string;
	/**
	 * Build secrets to pass to the `docker build` command
	 *
	 * @default no build secrets are passed
	 */
	readonly buildSecrets?: {
		[key: string]: string;
	};
	/**
	 * Docker target to build to
	 *
	 * @default no build target
	 */
	readonly target?: string;
	/**
	 * Path to the Dockerfile (relative to the directory).
	 *
	 * @default - no file is passed
	 */
	readonly file?: string;
	/**
	 * Networking mode for the RUN commands during build.
	 *
	 * @default - no networking mode specified
	 */
	readonly networkMode?: string;
	/**
	 * Platform to build for. _Requires Docker Buildx_.
	 *
	 * @default - current machine platform
	 */
	readonly platform?: string;
	/**
	 * Outputs to pass to the `docker build` command.
	 *
	 * @default - no outputs are passed to the build command (default outputs are used)
	 * @see https://docs.docker.com/engine/reference/commandline/build/#custom-build-outputs
	 */
	readonly outputs?: string[];
	/**
	 * Cache from options to pass to the `docker build` command.
	 *
	 * @default - no cache from options are passed to the build command
	 * @see https://docs.docker.com/build/cache/backends/
	 */
	readonly cacheFrom?: ContainerImageAssetCacheOption[];
	/**
	 * Cache to options to pass to the `docker build` command.
	 *
	 * @default - no cache to options are passed to the build command
	 * @see https://docs.docker.com/build/cache/backends/
	 */
	readonly cacheTo?: ContainerImageAssetCacheOption;
	/**
	 * Disable the cache and pass `--no-cache` to the `docker build` command.
	 *
	 * @default - cache is used
	 */
	readonly cacheDisabled?: boolean;
}
type AssetMetadataEntry = FileAssetMetadataEntry | ContainerImageAssetMetadataEntry;
type LogMessageMetadataEntry = string;
type LogicalIdMetadataEntry = string;
type StackTagsMetadataEntry = Tag[];
type PrimitiveType = boolean | number | string;
type MetadataEntryData = AssetMetadataEntry | LogMessageMetadataEntry | LogicalIdMetadataEntry | StackTagsMetadataEntry | PrimitiveType;
interface MetadataEntry {
	/**
	 * The type of the metadata entry.
	 */
	readonly type: string;
	/**
	 * The data.
	 *
	 * @default - no data.
	 */
	readonly data?: MetadataEntryData;
	/**
	 * A stack trace for when the entry was created.
	 *
	 * @default - no trace.
	 */
	readonly trace?: string[];
}
declare enum ContextProvider {
	/**
	 * AMI provider
	 */
	AMI_PROVIDER = "ami",
	/**
	 * AZ provider
	 */
	AVAILABILITY_ZONE_PROVIDER = "availability-zones",
	/**
	 * Route53 Hosted Zone provider
	 */
	HOSTED_ZONE_PROVIDER = "hosted-zone",
	/**
	 * SSM Parameter Provider
	 */
	SSM_PARAMETER_PROVIDER = "ssm",
	/**
	 * VPC Provider
	 */
	VPC_PROVIDER = "vpc-provider",
	/**
	 * VPC Endpoint Service AZ Provider
	 */
	ENDPOINT_SERVICE_AVAILABILITY_ZONE_PROVIDER = "endpoint-service-availability-zones",
	/**
	 * Load balancer provider
	 */
	LOAD_BALANCER_PROVIDER = "load-balancer",
	/**
	 * Load balancer listener provider
	 */
	LOAD_BALANCER_LISTENER_PROVIDER = "load-balancer-listener",
	/**
	 * Security group provider
	 */
	SECURITY_GROUP_PROVIDER = "security-group",
	/**
	 * KMS Key Provider
	 */
	KEY_PROVIDER = "key-provider",
	/**
	 * CCAPI Provider
	 */
	CC_API_PROVIDER = "cc-api-provider",
	/**
	 * A plugin provider (the actual plugin name will be in the properties)
	 */
	PLUGIN = "plugin"
}
interface ContextLookupRoleOptions {
	/**
	 * Query account
	 */
	readonly account: string;
	/**
	 * Query region
	 */
	readonly region: string;
	/**
	 * The ARN of the role that should be used to look up the missing values
	 *
	 * @default - None
	 */
	readonly lookupRoleArn?: string;
	/**
	 * The ExternalId that needs to be supplied while assuming this role
	 *
	 * @default - No ExternalId will be supplied
	 */
	readonly lookupRoleExternalId?: string;
	/**
	 * Additional options to pass to STS when assuming the lookup role.
	 *
	 * - `RoleArn` should not be used. Use the dedicated `lookupRoleArn` property instead.
	 * - `ExternalId` should not be used. Use the dedicated `lookupRoleExternalId` instead.
	 *
	 * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property
	 * @default - No additional options.
	 */
	readonly assumeRoleAdditionalOptions?: {
		[key: string]: any;
	};
}
interface AmiContextQuery extends ContextLookupRoleOptions {
	/**
	 * Owners to DescribeImages call
	 *
	 * @default - All owners
	 */
	readonly owners?: string[];
	/**
	 * Filters to DescribeImages call
	 */
	readonly filters: {
		[key: string]: string[];
	};
}
interface AvailabilityZonesContextQuery extends ContextLookupRoleOptions {
}
interface HostedZoneContextQuery extends ContextLookupRoleOptions {
	/**
	 * The domain name e.g. example.com to lookup
	 */
	readonly domainName: string;
	/**
	 * True if the zone you want to find is a private hosted zone
	 *
	 * @default false
	 */
	readonly privateZone?: boolean;
	/**
	 * The VPC ID to that the private zone must be associated with
	 *
	 * If you provide VPC ID and privateZone is false, this will return no results
	 * and raise an error.
	 *
	 * @default - Required if privateZone=true
	 */
	readonly vpcId?: string;
}
interface SSMParameterContextQuery extends ContextLookupRoleOptions {
	/**
	 * Parameter name to query
	 */
	readonly parameterName: string;
}
interface VpcContextQuery extends ContextLookupRoleOptions {
	/**
	 * Filters to apply to the VPC
	 *
	 * Filter parameters are the same as passed to DescribeVpcs.
	 *
	 * @see https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html
	 */
	readonly filter: {
		[key: string]: string;
	};
	/**
	 * Whether to populate the subnetGroups field of the `VpcContextResponse`,
	 * which contains potentially asymmetric subnet groups.
	 *
	 * @default false
	 */
	readonly returnAsymmetricSubnets?: boolean;
	/**
	 * Optional tag for subnet group name.
	 * If not provided, we'll look at the aws-cdk:subnet-name tag.
	 * If the subnet does not have the specified tag,
	 * we'll use its type as the name.
	 *
	 * @default 'aws-cdk:subnet-name'
	 */
	readonly subnetGroupNameTag?: string;
	/**
	 * Whether to populate the `vpnGatewayId` field of the `VpcContextResponse`,
	 * which contains the VPN Gateway ID, if one exists. You can explicitly
	 * disable this in order to avoid the lookup if you know the VPC does not have
	 * a VPN Gatway attached.
	 *
	 * @default true
	 */
	readonly returnVpnGateways?: boolean;
}
interface EndpointServiceAvailabilityZonesContextQuery extends ContextLookupRoleOptions {
	/**
	 * Query service name
	 */
	readonly serviceName: string;
}
declare enum LoadBalancerType {
	/**
	 * Network load balancer
	 */
	NETWORK = "network",
	/**
	 * Application load balancer
	 */
	APPLICATION = "application"
}
interface LoadBalancerFilter extends ContextLookupRoleOptions {
	/**
	 * Filter load balancers by their type
	 */
	readonly loadBalancerType: LoadBalancerType;
	/**
	 * Find by load balancer's ARN
	 * @default - does not search by load balancer arn
	 */
	readonly loadBalancerArn?: string;
	/**
	 * Match load balancer tags
	 * @default - does not match load balancers by tags
	 */
	readonly loadBalancerTags?: Tag[];
}
interface LoadBalancerContextQuery extends LoadBalancerFilter {
}
declare enum LoadBalancerListenerProtocol {
	/**
	 * HTTP protocol
	 */
	HTTP = "HTTP",
	/**
	 * HTTPS protocol
	 */
	HTTPS = "HTTPS",
	/**
	 * TCP protocol
	 */
	TCP = "TCP",
	/**
	 * TLS protocol
	 */
	TLS = "TLS",
	/**
	 * UDP protocol
	 * */
	UDP = "UDP",
	/**
	 * TCP and UDP protocol
	 * */
	TCP_UDP = "TCP_UDP"
}
interface LoadBalancerListenerContextQuery extends LoadBalancerFilter {
	/**
	 * Find by listener's arn
	 * @default - does not find by listener arn
	 */
	readonly listenerArn?: string;
	/**
	 * Filter by listener protocol
	 * @default - does not filter by listener protocol
	 */
	readonly listenerProtocol?: LoadBalancerListenerProtocol;
	/**
	 * Filter listeners by listener port
	 * @default - does not filter by a listener port
	 */
	readonly listenerPort?: number;
}
interface SecurityGroupContextQuery extends ContextLookupRoleOptions {
	/**
	 * Security group id
	 *
	 * @default - None
	 */
	readonly securityGroupId?: string;
	/**
	 * Security group name
	 *
	 * @default - None
	 */
	readonly securityGroupName?: string;
	/**
	 * VPC ID
	 *
	 * @default - None
	 */
	readonly vpcId?: string;
}
interface KeyContextQuery extends ContextLookupRoleOptions {
	/**
	 * Alias name used to search the Key
	 */
	readonly aliasName: string;
}
interface CcApiContextQuery extends ContextLookupRoleOptions {
	/**
	 * The CloudFormation resource type.
	 * See https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/supported-resources.html
	 */
	readonly typeName: string;
	/**
	 * Identifier of the resource to look up using `GetResource`.
	 *
	 * Specifying exactIdentifier will return exactly one result, or throw an error
	 * unless `ignoreErrorOnMissingContext` is set.
	 *
	 * @default - Either exactIdentifier or propertyMatch should be specified.
	 */
	readonly exactIdentifier?: string;
	/**
	 * Returns any resources matching these properties, using `ListResources`.
	 *
	 * By default, specifying propertyMatch will successfully return 0 or more
	 * results. To throw an error if the number of results is unexpected (and
	 * prevent the query results from being committed to context), specify
	 * `expectedMatchCount`.
	 *
	 * ## Notes on property completeness
	 *
	 * CloudControl API's `ListResources` may return fewer properties than
	 * `GetResource` would, depending on the resource implementation.
	 *
	 * The resources that `propertyMatch` matches against will *only ever* be the
	 * properties returned by the `ListResources` call.
	 *
	 * @default - Either exactIdentifier or propertyMatch should be specified.
	 */
	readonly propertyMatch?: Record<string, unknown>;
	/**
	 * This is a set of properties returned from CC API that we want to return from ContextQuery.
	 *
	 * If any properties listed here are absent from the target resource, an error will be thrown.
	 *
	 * The returned object will always include the key `Identifier` with the CC-API returned
	 * field `Identifier`.
	 *
	 * ## Notes on property completeness
	 *
	 * CloudControl API's `ListResources` may return fewer properties than
	 * `GetResource` would, depending on the resource implementation.
	 *
	 * The returned properties here are *currently* selected from the response
	 * object that CloudControl API returns to the CDK CLI.
	 *
	 * However, if we find there is need to do so, we may decide to change this
	 * behavior in the future: we might change it to perform an additional
	 * `GetResource` call for resources matched by `propertyMatch`.
	 */
	readonly propertiesToReturn: string[];
	/**
	 * Expected count of results if `propertyMatch` is specified.
	 *
	 * If the expected result count does not match the actual count,
	 * by default an error is produced and the result is not committed to cached
	 * context, and the user can correct the situation and try again without
	 * having to manually clear out the context key using `cdk context --remove`
	 *
	 * If the value of * `ignoreErrorOnMissingContext` is `true`, the value of
	 * `expectedMatchCount` is `at-least-one | exactly-one` and the number
	 * of found resources is 0, `dummyValue` is returned and committed to context
	 * instead.
	 *
	 * @default 'any'
	 */
	readonly expectedMatchCount?: "any" | "at-least-one" | "at-most-one" | "exactly-one";
	/**
	 * The value to return if the resource was not found and `ignoreErrorOnMissingContext` is true.
	 *
	 * If supplied, `dummyValue` should be an array of objects.
	 *
	 * `dummyValue` does not have to have elements, and it may have objects with
	 * different properties than the properties in `propertiesToReturn`, but it
	 * will be easiest for downstream code if the `dummyValue` conforms to
	 * the expected response shape.
	 *
	 * @default - No dummy value available
	 */
	readonly dummyValue?: any;
	/**
	 * Ignore an error and return the `dummyValue` instead if the resource was not found.
	 *
	 * - In case of an `exactIdentifier` lookup, return the `dummyValue` if the resource with
	 *   that identifier was not found.
	 * - In case of a `propertyMatch` lookup, return the `dummyValue` if `expectedMatchCount`
	 *   is `at-least-one | exactly-one` and the number of resources found was 0.
	 *
	 * if `ignoreErrorOnMissingContext` is set, `dummyValue` should be set and be an array.
	 *
	 * @default false
	 */
	readonly ignoreErrorOnMissingContext?: boolean;
}
interface PluginContextQuery {
	/**
	 * The name of the plugin
	 */
	readonly pluginName: string;
	/**
	 * Arbitrary other arguments for the plugin.
	 *
	 * This index signature is not usable in non-TypeScript/JavaScript languages.
	 *
	 * @jsii ignore
	 */
	[key: string]: any;
}
type ContextQueryProperties = AmiContextQuery | AvailabilityZonesContextQuery | HostedZoneContextQuery | SSMParameterContextQuery | VpcContextQuery | EndpointServiceAvailabilityZonesContextQuery | LoadBalancerContextQuery | LoadBalancerListenerContextQuery | SecurityGroupContextQuery | KeyContextQuery | CcApiContextQuery | PluginContextQuery;
declare enum ArtifactType {
	/**
	 * Stub required because of JSII.
	 */
	NONE = "none",// required due to a jsii bug
	/**
	 * The artifact is an AWS CloudFormation stack.
	 */
	AWS_CLOUDFORMATION_STACK = "aws:cloudformation:stack",
	/**
	 * The artifact contains the CDK application's construct tree.
	 */
	CDK_TREE = "cdk:tree",
	/**
	 * Manifest for all assets in the Cloud Assembly
	 */
	ASSET_MANIFEST = "cdk:asset-manifest",
	/**
	 * Nested Cloud Assembly
	 */
	NESTED_CLOUD_ASSEMBLY = "cdk:cloud-assembly"
}
interface RuntimeInfo {
	/**
	 * The list of libraries loaded in the application, associated with their versions.
	 */
	readonly libraries: {
		[name: string]: string;
	};
}
interface MissingContext {
	/**
	 * The missing context key.
	 */
	readonly key: string;
	/**
	 * The provider from which we expect this context key to be obtained.
	 */
	readonly provider: ContextProvider;
	/**
	 * A set of provider-specific options.
	 */
	readonly props: ContextQueryProperties;
}
interface ArtifactManifest {
	/**
	 * The type of artifact.
	 */
	readonly type: ArtifactType;
	/**
	 * The environment into which this artifact is deployed.
	 *
	 * @default - no envrionment.
	 */
	readonly environment?: string;
	/**
	 * Associated metadata.
	 *
	 * @default - no metadata.
	 */
	readonly metadata?: {
		[path: string]: MetadataEntry[];
	};
	/**
	 * IDs of artifacts that must be deployed before this artifact.
	 *
	 * @default - no dependencies.
	 */
	readonly dependencies?: string[];
	/**
	 * The set of properties for this artifact (depends on type)
	 *
	 * @default - no properties.
	 */
	readonly properties?: ArtifactProperties;
	/**
	 * A string that can be shown to a user to uniquely identify this artifact inside a cloud assembly tree
	 *
	 * Is used by the CLI to present a list of stacks to the user in a way that
	 * makes sense to them. Even though the property name "display name" doesn't
	 * imply it, this field is used to select stacks as well, so all stacks should
	 * have a unique display name.
	 *
	 * @default - no display name
	 */
	readonly displayName?: string;
}
interface AssemblyManifest {
	/**
	 * Protocol version
	 */
	readonly version: string;
	/**
	 * Required CLI version, if available
	 *
	 * If the manifest producer knows, it can put the minimum version of the CLI
	 * here that supports reading this assembly.
	 *
	 * If set, it can be used to show a more informative error message to users.
	 *
	 * @default - Minimum CLI version unknown
	 */
	readonly minimumCliVersion?: string;
	/**
	 * The set of artifacts in this assembly.
	 *
	 * @default - no artifacts.
	 */
	readonly artifacts?: {
		[id: string]: ArtifactManifest;
	};
	/**
	 * Missing context information. If this field has values, it means that the
	 * cloud assembly is not complete and should not be deployed.
	 *
	 * @default - no missing context.
	 */
	readonly missing?: MissingContext[];
	/**
	 * Runtime information.
	 *
	 * @default - no info.
	 */
	readonly runtime?: RuntimeInfo;
}
interface ICloudAssembly {
	/**
	 * The directory of the cloud assembly.
	 *
	 * This directory will be used to read the Cloud Assembly from.
	 * Its contents (in particular `manifest.json`) must comply with the schema defined in this package.
	 */
	readonly directory: string;
}
interface LoadManifestOptions {
	/**
	 * Skip the version check
	 *
	 * This means you may read a newer cloud assembly than the CX API is designed
	 * to support, and your application may not be aware of all features that in use
	 * in the Cloud Assembly.
	 *
	 * @default false
	 */
	readonly skipVersionCheck?: boolean;
	/**
	 * Skip enum checks
	 *
	 * This means you may read enum values you don't know about yet. Make sure to always
	 * check the values of enums you encounter in the manifest.
	 *
	 * @default false
	 */
	readonly skipEnumCheck?: boolean;
	/**
	 * Topologically sort all artifacts
	 *
	 * This parameter is only respected by the constructor of `CloudAssembly`. The
	 * property lives here for backwards compatibility reasons.
	 *
	 * @default true
	 */
	readonly topoSort?: boolean;
}
/**
 * Represents a general toolkit error in the AWS CDK Toolkit.
 */
export declare class ToolkitError extends Error {
	/**
	 * Determines if a given error is an instance of ToolkitError.
	 */
	static isToolkitError(x: any): x is ToolkitError;
	/**
	 * Determines if a given error is an instance of AuthenticationError.
	 */
	static isAuthenticationError(x: any): x is AuthenticationError;
	/**
	 * Determines if a given error is an instance of AssemblyError.
	 */
	static isAssemblyError(x: any): x is AssemblyError;
	/**
	 * Determines if a given error is an instance of AssemblyError.
	 */
	static isContextProviderError(x: any): x is ContextProviderError;
	/**
	 * An AssemblyError with an original error as cause
	 */
	static withCause(message: string, error: unknown): ToolkitError;
	/**
	 * The type of the error, defaults to "toolkit".
	 */
	readonly type: string;
	/**
	 * Denotes the source of the error as the toolkit.
	 */
	readonly source: "toolkit" | "user";
	/**
	 * The specific original cause of the error, if available
	 */
	readonly cause?: unknown;
	constructor(message: string, type?: string, cause?: unknown);
}
/**
 * Represents an authentication-specific error in the AWS CDK Toolkit.
 */
export declare class AuthenticationError extends ToolkitError {
	/**
	 * Denotes the source of the error as user.
	 */
	readonly source = "user";
	constructor(message: string);
}
/**
 * Represents an error causes by cloud assembly synthesis
 *
 * This includes errors thrown during app execution, as well as failing annotations.
 */
export declare class AssemblyError extends ToolkitError {
	/**
	 * An AssemblyError with an original error as cause
	 */
	static withCause(message: string, error: unknown): AssemblyError;
	/**
	 * An AssemblyError with a list of stacks as cause
	 */
	static withStacks(message: string, stacks?: cxapi.CloudFormationStackArtifact[]): AssemblyError;
	/**
	 * Denotes the source of the error as user.
	 */
	readonly source = "user";
	/**
	 * The stacks that caused the error, if available
	 *
	 * The `messages` property of each `cxapi.CloudFormationStackArtifact` will contain the respective errors.
	 * Absence indicates synthesis didn't fully complete.
	 */
	readonly stacks?: cxapi.CloudFormationStackArtifact[];
	private constructor();
}
declare class ContextProviderError extends ToolkitError {
	/**
	 * Denotes the source of the error as user.
	 */
	readonly source = "user";
	constructor(message: string);
}
/**
 * Which stacks should be selected from a cloud assembly
 */
export declare enum StackSelectionStrategy {
	/**
	 * Returns all stacks in the app regardless of patterns,
	 * including stacks inside nested assemblies.
	 */
	ALL_STACKS = "all-stacks",
	/**
	 * Returns all stacks in the main (top level) assembly only.
	 */
	MAIN_ASSEMBLY = "main-assembly",
	/**
	 * If the assembly includes a single stack, returns it.
	 * Otherwise throws an exception.
	 */
	ONLY_SINGLE = "only-single",
	/**
	 * Return stacks matched by patterns.
	 * If no stacks are found, execution is halted successfully.
	 * Most likely you don't want to use this but `StackSelectionStrategy.MUST_MATCH_PATTERN`
	 */
	PATTERN_MATCH = "pattern-match",
	/**
	 * Return stacks matched by patterns.
	 * Throws an exception if the patterns don't match at least one stack in the assembly.
	 */
	PATTERN_MUST_MATCH = "pattern-must-match",
	/**
	 * Returns if exactly one stack is matched by the pattern(s).
	 * Throws an exception if no stack, or more than exactly one stack are matched.
	 */
	PATTERN_MUST_MATCH_SINGLE = "pattern-must-match-single"
}
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
export declare enum ExpandStackSelection {
	/**
	 * Don't select any extra stacks
	 */
	NONE = "none",
	/**
	 * Include stacks that this stack depends on
	 */
	UPSTREAM = "upstream",
	/**
	 * Include stacks that depend on this stack
	 */
	DOWNSTREAM = "downstream"
}
/**
 * A specification of which stacks should be selected
 */
export interface StackSelector {
	/**
	 * The behavior if if no selectors are provided.
	 */
	strategy: StackSelectionStrategy;
	/**
	 * A list of patterns to match the stack hierarchical ids
	 * Only used with `PATTERN_*` selection strategies.
	 */
	patterns?: string[];
	/**
	 * Expand the selection to upstream/downstream stacks.
	 * @default ExpandStackSelection.None only select the specified/matched stacks
	 */
	expand?: ExpandStackSelection;
	/**
	 * By default, we throw an exception if the assembly contains no stacks.
	 * Set to `false`, to halt execution for empty assemblies without error.
	 *
	 * Note that actions can still throw if a stack selection result is empty,
	 * but the assembly contains stacks in principle.
	 *
	 * @default true
	 */
	failOnEmpty?: boolean;
}
/**
 * The current action being performed by the CLI. 'none' represents the absence of an action.
 */
export type ToolkitAction = "assembly" | "bootstrap" | "synth" | "list" | "diff" | "deploy" | "rollback" | "watch" | "destroy" | "doctor" | "gc" | "import" | "metadata" | "init" | "migrate" | "refactor";
/**
 * The reporting level of the message.
 * All messages are always reported, it's up to the IoHost to decide what to log.
 */
export type IoMessageLevel = "error" | "result" | "warn" | "info" | "debug" | "trace";
/**
 * A valid message code.
 */
export type IoMessageCode = `CDK_${string}_${"E" | "W" | "I"}${number}${number}${number}${number}`;
/**
 * An IO message emitted.
 */
export interface IoMessage<T> {
	/**
	 * The time the message was emitted.
	 */
	readonly time: Date;
	/**
	 * The recommended log level of the message.
	 *
	 * This is an indicative level and should not be used to explicitly match messages, instead match the `code`.
	 * The level of a message may change without notice.
	 */
	readonly level: IoMessageLevel;
	/**
	 * The action that triggered the message.
	 */
	readonly action: ToolkitAction;
	/**
	 * A short message code uniquely identifying a message type using the format CDK_[CATEGORY]_[E/W/I][0000-9999].
	 *
	 * The level indicator follows these rules:
	 * - 'E' for error level messages
	 * - 'W' for warning level messages
	 * - 'I' for info/debug/trace level messages
	 *
	 * Codes ending in 000 0 are generic messages, while codes ending in 0001-9999 are specific to a particular message.
	 * The following are examples of valid and invalid message codes:
	 * ```ts
	 * 'CDK_ASSETS_I0000'       // valid: generic assets info message
	 * 'CDK_TOOLKIT_E0002'      // valid: specific toolkit error message
	 * 'CDK_SDK_W0023'          // valid: specific sdk warning message
	 * ```
	 *
	 * @see https://github.com/aws/aws-cdk-cli/blob/main/packages/%40aws-cdk/toolkit-lib/CODE_REGISTRY.md
	 */
	readonly code: IoMessageCode;
	/**
	 * The message text.
	 * This is safe to print to an end-user.
	 */
	readonly message: string;
	/**
	 * Identifies the message span, this message belongs to.
	 *
	 * A message span, groups multiple messages together that semantically related to the same operation.
	 * This is an otherwise meaningless identifier.
	 *
	 * A message without a `spanId`, does not belong to a span.
	 */
	readonly span?: string;
	/**
	 * The data attached to the message.
	 */
	readonly data: T;
}
/**
 * An IO request emitted.
 */
export interface IoRequest<T, U> extends IoMessage<T> {
	/**
	 * The default response that will be used if no data is returned.
	 */
	readonly defaultResponse: U;
}
export interface IIoHost {
	/**
	 * Notifies the host of a message.
	 * The caller waits until the notification completes.
	 */
	notify(msg: IoMessage<unknown>): Promise<void>;
	/**
	 * Notifies the host of a message that requires a response.
	 *
	 * If the host does not return a response the suggested
	 * default response from the input message will be used.
	 */
	requestResponse<T, U>(msg: IoRequest<T, U>): Promise<U>;
}
type ForReading = 0;
type ForWriting = 1;
interface CredentialProviderSource {
	name: string;
	/**
	 * Whether the credential provider is even online
	 *
	 * Guaranteed to be called before any of the other functions are called.
	 */
	isAvailable(): Promise<boolean>;
	/**
	 * Whether the credential provider can provide credentials for the given account.
	 */
	canProvideCredentials(accountId: string): Promise<boolean>;
	/**
	 * Construct a credential provider for the given account and the given access mode
	 *
	 * Guaranteed to be called only if canProvideCredentials() returned true at some point.
	 *
	 * While it is possible for the plugin to return a static set of credentials, it is
	 * recommended to return a provider.
	 */
	getProvider(accountId: string, mode: ForReading | ForWriting, options?: PluginProviderOptions): Promise<PluginProviderResult>;
}
interface IPluginHost {
	/**
	 * Registers a credential provider source. If, in the authentication process,
	 * the CLI decides to try credentials from the plugins, it will go through the
	 * sources registered in this way, in the same order as they were registered.
	 */
	registerCredentialProviderSource(source: CredentialProviderSource): void;
}
interface PluginProviderOptions {
	/**
	 * Whether or not this implementation of the CLI will recognize the `SDKv3CompatibleCredentialProvider` return variant
	 *
	 * Unless otherwise indicated, the CLI version will only support SDKv3
	 * credentials, not SDKv3 providers. You should avoid returning types that the
	 * consuming CLI will not understand, because it will most likely crash.
	 *
	 * @default false
	 */
	readonly supportsV3Providers?: boolean;
}
type PluginProviderResult = SDKv2CompatibleCredentials | SDKv3CompatibleCredentialProvider | SDKv3CompatibleCredentials;
interface SDKv2CompatibleCredentials {
	/**
	 * AWS access key ID.
	 */
	accessKeyId: string;
	/**
	 * Time when credentials should be considered expired.
	 * Used in conjunction with expired.
	 */
	expireTime?: Date | null;
	/**
	 * AWS secret access key.
	 */
	secretAccessKey: string;
	/**
	 * AWS session token.
	 */
	sessionToken?: string;
	/**
	 * Gets the existing credentials, refreshing them if necessary, and returns
	 * a promise that will be fulfilled immediately (if no refresh is necessary)
	 * or when the refresh has completed.
	 */
	getPromise(): Promise<void>;
}
type SDKv3CompatibleCredentialProvider = (identityProperties?: Record<string, any>) => Promise<SDKv3CompatibleCredentials>;
interface SDKv3CompatibleCredentials {
	/**
	 * AWS access key ID
	 */
	readonly accessKeyId: string;
	/**
	 * AWS secret access key
	 */
	readonly secretAccessKey: string;
	/**
	 * A security or session token to use with these credentials. Usually
	 * present for temporary credentials.
	 */
	readonly sessionToken?: string;
	/**
	 * A `Date` when the identity or credential will no longer be accepted.
	 */
	readonly expiration?: Date;
}
interface ContextProviderPlugin {
	getValue(args: {
		[key: string]: any;
	}): Promise<any>;
}
/**
 * Class to manage a plugin collection
 *
 * It provides a `load()` function that loads a JavaScript
 * module from disk, and gives it access to the `IPluginHost` interface
 * to register itself.
 */
export declare class PluginHost implements IPluginHost {
	/**
	 * Access the currently registered CredentialProviderSources. New sources can
	 * be registered using the +registerCredentialProviderSource+ method.
	 */
	readonly credentialProviderSources: CredentialProviderSource[];
	readonly contextProviderPlugins: Record<string, ContextProviderPlugin>;
	ioHost?: IIoHost;
	private readonly alreadyLoaded;
	/**
	 * Loads a plug-in into this PluginHost.
	 *
	 * Will use `require.resolve()` to get the most accurate representation of what
	 * code will get loaded in error messages. As such, it will not work in
	 * unit tests with Jest virtual modules becauase of <https://github.com/jestjs/jest/issues/9543>.
	 *
	 * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
	 * @param ioHost the I/O host to use for printing progress information
	 */
	load(moduleSpec: string, ioHost?: IIoHost): void;
	/**
	 * Allows plug-ins to register new CredentialProviderSources.
	 *
	 * @param source a new CredentialProviderSource to register.
	 */
	registerCredentialProviderSource(source: CredentialProviderSource): void;
	/**
	 * (EXPERIMENTAL) Allow plugins to register context providers
	 *
	 * Context providers are objects with the following method:
	 *
	 * ```ts
	 *   getValue(args: {[key: string]: any}): Promise<any>;
	 * ```
	 *
	 * Currently, they cannot reuse the CDK's authentication mechanisms, so they
	 * must be prepared to either not make AWS calls or use their own source of
	 * AWS credentials.
	 *
	 * This feature is experimental, and only intended to be used internally at Amazon
	 * as a trial.
	 *
	 * After registering with 'my-plugin-name', the provider must be addressed as follows:
	 *
	 * ```ts
	 * const value = ContextProvider.getValue(this, {
	 *   providerName: 'plugin',
	 *   props: {
	 *     pluginName: 'my-plugin-name',
	 *     myParameter1: 'xyz',
	 *   },
	 *   includeEnvironment: true | false,
	 *   dummyValue: 'what-to-return-on-the-first-pass',
	 * })
	 * ```
	 *
	 * @experimental
	 */
	registerContextProviderAlpha(pluginProviderName: string, provider: ContextProviderPlugin): void;
}
export interface BootstrapEnvironmentProgress {
	/**
	 * The total number of environments being deployed
	 */
	readonly total: number;
	/**
	 * The count of the environment currently bootstrapped
	 *
	 * This is counting value, not an identifier.
	 */
	readonly current: number;
	/**
	 * The environment that's currently being bootstrapped
	 */
	readonly environment: cxapi.Environment;
}
interface IManifestEntry {
	/**
	 * The identifier of the asset and its destination
	 */
	readonly id: DestinationIdentifier;
	/**
	 * The type of asset
	 */
	readonly type: string;
	/**
	 * Type-dependent source data
	 */
	readonly genericSource: unknown;
	/**
	 * Type-dependent destination data
	 */
	readonly genericDestination: unknown;
	/**
	 * Return a display name for this asset
	 *
	 * The `includeDestination` parameter controls whether or not to include the
	 * destination ID in the display name.
	 *
	 * - Pass `false` if you are displaying notifications about building the
	 *   asset, or if you are describing the work of building the asset and publishing
	 *   to all destinations at the same time.
	 * - Pass `true` if you are displaying notifications about publishing to a
	 *   specific destination.
	 */
	displayName(includeDestination: boolean): string;
}
declare class DestinationIdentifier {
	/**
	 * Identifies the asset, by source.
	 *
	 * The assetId will be the same between assets that represent
	 * the same physical file or image.
	 */
	readonly assetId: string;
	/**
	 * Identifies the destination where this asset will be published
	 */
	readonly destinationId: string;
	constructor(assetId: string, destinationId: string);
	/**
	 * Return a string representation for this asset identifier
	 */
	toString(): string;
}
/**
 * Assembly data returned in the payload of an IO Message.
 */
export interface AssemblyData {
	/**
	 * The path to the assembly directory
	 */
	readonly assemblyDirectory: string;
	/**
	 * The number of stacks actioned on
	 */
	readonly stacksCount: number;
	/**
	 * The stack IDs
	 */
	readonly stackIds: string[];
}
/**
 * Stack data returned in the payload of an IO Message.
 */
export interface StackData {
	/**
	 * The stack name
	 */
	readonly stackName: string;
	/**
	 * The stack ID
	 */
	readonly hierarchicalId: string;
	/**
	 * The stack template
	 */
	readonly template: any;
	/**
	 * The stack template converted to JSON format
	 */
	readonly stringifiedJson: string;
	/**
	 * The stack template converted to YAML format
	 */
	readonly stringifiedYaml: string;
}
/**
 * Stack data returned in the payload of an IO Message.
 */
export interface StackAndAssemblyData extends AssemblyData {
	/**
	 * Stack Data
	 */
	readonly stack: StackData;
}
/**
 * Duration information returned in the payload of an IO Message.
 */
export interface Duration {
	/**
	 * The duration of the action.
	 */
	readonly duration: number;
}
/**
 * Generic payload of error IoMessages that pass on an instance of `Error`
 */
export interface ErrorPayload {
	/**
	 * The error that occurred
	 */
	readonly error: Error;
}
/**
 * Generic payload of a simple yes/no question.
 *
 * The expectation is that 'yes' means moving on,
 * and 'no' means aborting the current action.
 */
export interface ConfirmationRequest {
	/**
	 * Some additional motivation for the confirmation that may be used as context for the user.
	 */
	readonly motivation: string;
	/**
	 * Number of on-going concurrent operations
	 * If more than one operations is on-going, a client might decide that asking the user
	 * for input is too complex, as the confirmation might not easily be attributed to a specific request.
	 *
	 * @default - no concurrency
	 */
	readonly concurrency?: number;
}
export interface ContextProviderMessageSource {
	/**
	 * The name of the context provider sending the message
	 */
	readonly provider: string;
}
/**
 * Different types of permission related changes in a diff
 */
export declare enum PermissionChangeType {
	/**
	 * No permission changes
	 */
	NONE = "none",
	/**
	 * Permissions are broadening
	 */
	BROADENING = "broadening",
	/**
	 * Permissions are changed but not broadening
	 */
	NON_BROADENING = "non-broadening"
}
/**
 * Output of the diff command
 */
export interface DiffResult extends Duration {
	/**
	 * Stack diff formatted as a string
	 */
	readonly formattedStackDiff: string;
	/**
	 * Security diff formatted as a string
	 */
	readonly formattedSecurityDiff: string;
}
export type DeployStackResult = SuccessfulDeployStackResult | NeedRollbackFirstDeployStackResult | ReplacementRequiresRollbackStackResult;
/** Successfully deployed a stack */
export interface SuccessfulDeployStackResult {
	readonly type: "did-deploy-stack";
	readonly noOp: boolean;
	readonly outputs: {
		[name: string]: string;
	};
	readonly stackArn: string;
}
/** The stack is currently in a failpaused state, and needs to be rolled back before the deployment */
export interface NeedRollbackFirstDeployStackResult {
	readonly type: "failpaused-need-rollback-first";
	readonly reason: "not-norollback" | "replacement";
	readonly status: string;
}
/** The upcoming change has a replacement, which requires deploying with --rollback */
export interface ReplacementRequiresRollbackStackResult {
	readonly type: "replacement-requires-rollback";
}
export interface StackDeployProgress {
	/**
	 * The total number of stacks being deployed
	 */
	readonly total: number;
	/**
	 * The count of the stack currently attempted to be deployed
	 *
	 * This is counting value, not an identifier.
	 */
	readonly current: number;
	/**
	 * The stack that's currently being deployed
	 */
	readonly stack: CloudFormationStackArtifact;
}
/**
 * Payload for a yes/no confirmation in deploy. Includes information on
 * what kind of change is being made.
 */
export interface DeployConfirmationRequest extends ConfirmationRequest {
	/**
	 * The type of change being made to the IAM permissions.
	 */
	readonly permissionChangeType: PermissionChangeType;
}
export interface StackDeployProgress {
	/**
	 * The total number of stacks being deployed
	 */
	readonly total: number;
	/**
	 * The count of the stack currently attempted to be deployed
	 *
	 * This is counting value, not an identifier.
	 */
	readonly current: number;
	/**
	 * The stack that's currently being deployed
	 */
	readonly stack: CloudFormationStackArtifact;
}
/**
 * Payload for a yes/no confirmation in deploy. Includes information on
 * what kind of change is being made.
 */
export interface DeployConfirmationRequest extends ConfirmationRequest {
	/**
	 * The type of change being made to the IAM permissions.
	 */
	readonly permissionChangeType: PermissionChangeType;
}
export interface BuildAsset {
	/**
	 * The asset that is build
	 */
	readonly asset: IManifestEntry;
}
export interface PublishAsset {
	/**
	 * The asset that is published
	 */
	readonly asset: IManifestEntry;
}
export interface StackDestroy {
	/**
	 * The stacks that will be destroyed
	 */
	readonly stacks: CloudFormationStackArtifact[];
}
export interface StackDestroyProgress {
	/**
	 * The total number of stacks being destroyed
	 */
	readonly total: number;
	/**
	 * The count of the stack currently attempted to be destroyed
	 *
	 * This is counting value, not an identifier.
	 */
	readonly current: number;
	/**
	 * The stack that's currently being destroyed
	 */
	readonly stack: CloudFormationStackArtifact;
}
/**
 * The dependencies of a stack.
 */
export interface StackDependency {
	id: string;
	dependencies: StackDependency[];
}
/**
 * Details of a stack.
 */
export interface StackDetails {
	id: string;
	name: string;
	environment: cxapi.Environment;
	dependencies: StackDependency[];
}
export interface StackDetailsPayload {
	readonly stacks: StackDetails[];
}
/**
 * An SDK logging trace.
 *
 * Only info, warn and error level messages are emitted.
 * SDK traces are emitted as traces to the IoHost, but contain the original SDK logging level.
 */
export interface SdkTrace {
	/**
	 * The level the SDK has emitted the original message with
	 */
	readonly sdkLevel: "info" | "warn" | "error";
	/**
	 * The content of the SDK trace
	 *
	 * This will include the request and response data for API calls, including potentially sensitive information.
	 *
	 * @see https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/logging-sdk-calls.html
	 */
	readonly content: any;
}
interface MissingContext$1 {
	missingKeys: string[];
}
export interface UpdatedContext {
	contextFile: string;
	context: {
		[key: string]: any;
	};
}
export interface StackRollbackProgress {
	/**
	 * The total number of stacks being rolled back
	 */
	readonly total: number;
	/**
	 * The count of the stack currently attempted to be rolled back
	 *
	 * This is counting value, not an identifier.
	 */
	readonly current: number;
	/**
	 * The stack that's currently being rolled back
	 */
	readonly stack: CloudFormationStackArtifact;
}
export interface StackProgress {
	/**
	 * The total number of progress monitored resources.
	 */
	readonly total?: number;
	/**
	 * The number of completed resources.
	 */
	readonly completed: number;
	/**
	 * The current progress as a [34/42] string, or just [34] if the total is unknown.
	 */
	readonly formatted: string;
}
interface ResourceMetadata {
	/**
	 * The resource's metadata as declared in the cloud assembly
	 */
	readonly entry: MetadataEntry;
	/**
	 * The construct path of the resource
	 */
	readonly constructPath: string;
}
/**
 * Payload when stack monitoring is starting or stopping for a given stack deployment.
 */
export interface StackMonitoringControlEvent {
	/**
	 * A unique identifier for a specific stack deployment.
	 *
	 * Use this value to attribute stack activities received for concurrent deployments.
	 */
	readonly deployment: string;
	/**
	 * The stack artifact that is getting deployed
	 */
	readonly stack: CloudFormationStackArtifact;
	/**
	 * The name of the Stack that is getting deployed
	 */
	readonly stackName: string;
	/**
	 * Total number of resources taking part in this deployment
	 *
	 * The number might not always be known or accurate.
	 * Only use for informational purposes and handle the case when it's unavailable.
	 */
	readonly resourcesTotal?: number;
}
export interface StackActivity {
	/**
	 * A unique identifier for a specific stack deployment.
	 *
	 * Use this value to attribute stack activities received for concurrent deployments.
	 */
	readonly deployment: string;
	/**
	 * The Stack Event as received from CloudFormation
	 */
	readonly event: StackEvent;
	/**
	 * Additional resource metadata
	 *
	 * This information is only available if the information is available in the current cloud assembly.
	 * I.e. no `metadata` will not be available for resource deletion events.
	 */
	readonly metadata?: ResourceMetadata;
	/**
	 * The stack progress
	 */
	readonly progress: StackProgress;
}
export interface StackSelectionDetails {
	/**
	 * The selected stacks, if any
	 */
	readonly stacks: StackSelector;
}
interface IDifference<ValueType> {
	readonly oldValue: ValueType | undefined;
	readonly newValue: ValueType | undefined;
	readonly isDifferent: boolean;
	readonly isAddition: boolean;
	readonly isRemoval: boolean;
	readonly isUpdate: boolean;
}
declare class Difference<ValueType> implements IDifference<ValueType> {
	readonly oldValue: ValueType | undefined;
	readonly newValue: ValueType | undefined;
	/**
	 * Whether this is an actual different or the values are actually the same
	 *
	 * isDifferent => (isUpdate | isRemoved | isUpdate)
	 */
	isDifferent: boolean;
	/**
	 * @param oldValue the old value, cannot be equal (to the sense of +deepEqual+) to +newValue+.
	 * @param newValue the new value, cannot be equal (to the sense of +deepEqual+) to +oldValue+.
	 */
	constructor(oldValue: ValueType | undefined, newValue: ValueType | undefined);
	/** @returns +true+ if the element is new to the template. */
	get isAddition(): boolean;
	/** @returns +true+ if the element was removed from the template. */
	get isRemoval(): boolean;
	/** @returns +true+ if the element was already in the template and is updated. */
	get isUpdate(): boolean;
}
declare class PropertyDifference<ValueType> extends Difference<ValueType> {
	changeImpact?: ResourceImpact;
	constructor(oldValue: ValueType | undefined, newValue: ValueType | undefined, args: {
		changeImpact?: ResourceImpact;
	});
}
declare enum ResourceImpact {
	/** The existing physical resource will be updated */
	WILL_UPDATE = "WILL_UPDATE",
	/** A new physical resource will be created */
	WILL_CREATE = "WILL_CREATE",
	/** The existing physical resource will be replaced */
	WILL_REPLACE = "WILL_REPLACE",
	/** The existing physical resource may be replaced */
	MAY_REPLACE = "MAY_REPLACE",
	/** The existing physical resource will be destroyed */
	WILL_DESTROY = "WILL_DESTROY",
	/** The existing physical resource will be removed from CloudFormation supervision */
	WILL_ORPHAN = "WILL_ORPHAN",
	/** The existing physical resource will be added to CloudFormation supervision */
	WILL_IMPORT = "WILL_IMPORT",
	/** There is no change in this resource */
	NO_CHANGE = "NO_CHANGE"
}
interface Resource {
	Type: string;
	Properties?: {
		[name: string]: any;
	};
	[key: string]: any;
}
interface TypedMapping {
	readonly type: string;
	readonly sourcePath: string;
	readonly destinationPath: string;
}
/**
 * Output of the refactor command
 */
export interface RefactorResult {
	/**
	 * Mappings along with the resource type
	 */
	readonly typedMappings?: TypedMapping[];
	/**
	 * Ambiguous path correspondences, if any
	 */
	readonly ambiguousPaths?: [
		string[],
		string[]
	][];
}
/**
 * The computed file watch settings
 */
export interface WatchSettings {
	/**
	 * The directory observed for file changes
	 */
	readonly watchDir: string;
	/**
	 * List of include patterns for watching files
	 */
	readonly includes: string[];
	/**
	 * List of excludes patterns for watching files
	 */
	readonly excludes: string[];
}
export interface FileWatchEvent {
	/**
	 * The change to the path
	 */
	readonly event: string;
	/**
	 * The path that has an observed event
	 */
	readonly path?: string;
}
/**
 * Payload when stack monitoring is starting or stopping for a given stack deployment.
 */
export interface CloudWatchLogMonitorControlEvent {
	/**
	 * A unique identifier for a monitor
	 *
	 * Use this value to attribute events received for concurrent log monitoring.
	 */
	readonly monitor: string;
	/**
	 * The names of monitored log groups
	 */
	readonly logGroupNames: string[];
}
/**
 * Represents a CloudWatch Log Event that will be
 * printed to the terminal
 */
export interface CloudWatchLogEvent {
	/**
	 * The log event message
	 */
	readonly message: string;
	/**
	 * The name of the log group
	 */
	readonly logGroupName: string;
	/**
	 * The time at which the event occurred
	 */
	readonly timestamp: Date;
}
/**
 * A resource affected by a change
 */
export interface AffectedResource {
	/**
	 * The logical ID of the affected resource in the template
	 */
	readonly logicalId: string;
	/**
	 * The CloudFormation type of the resource
	 * This could be a custom type.
	 */
	readonly resourceType: string;
	/**
	 * The friendly description of the affected resource
	 */
	readonly description?: string;
	/**
	 * The physical name of the resource when deployed.
	 *
	 * A physical name is not always available, e.g. new resources will not have one until after the deployment
	 */
	readonly physicalName?: string;
	/**
	 * Resource metadata attached to the logical id from the cloud assembly
	 *
	 * This is only present if the resource is present in the current Cloud Assembly,
	 * i.e. resource deletions will not have metadata.
	 */
	readonly metadata?: ResourceMetadata;
}
/**
 * Represents a change in a resource
 */
export interface ResourceChange {
	/**
	 * The logical ID of the resource which is being changed
	 */
	readonly logicalId: string;
	/**
	 * The value the resource is being updated from
	 */
	readonly oldValue: Resource;
	/**
	 * The value the resource is being updated to
	 */
	readonly newValue: Resource;
	/**
	 * The changes made to the resource properties
	 */
	readonly propertyUpdates: Record<string, PropertyDifference<unknown>>;
	/**
	 * Resource metadata attached to the logical id from the cloud assembly
	 *
	 * This is only present if the resource is present in the current Cloud Assembly,
	 * i.e. resource deletions will not have metadata.
	 */
	readonly metadata?: ResourceMetadata;
}
/**
 * A change that can be hotswapped
 */
export interface HotswappableChange {
	/**
	 * The resource change that is causing the hotswap.
	 */
	readonly cause: ResourceChange;
	/**
	 * A list of resources that are being hotswapped as part of the change
	 */
	readonly resources: AffectedResource[];
}
export declare enum NonHotswappableReason {
	/**
	 * Tags are not hotswappable
	 */
	TAGS = "tags",
	/**
	 * Changed resource properties are not hotswappable on this resource type
	 */
	PROPERTIES = "properties",
	/**
	 * A stack output has changed
	 */
	OUTPUT = "output",
	/**
	 * A dependant resource is not hotswappable
	 */
	DEPENDENCY_UNSUPPORTED = "dependency-unsupported",
	/**
	 * The resource type is not hotswappable
	 */
	RESOURCE_UNSUPPORTED = "resource-unsupported",
	/**
	 * The resource is created in the deployment
	 */
	RESOURCE_CREATION = "resource-creation",
	/**
	 * The resource is removed in the deployment
	 */
	RESOURCE_DELETION = "resource-deletion",
	/**
	 * The resource identified by the logical id has its type changed
	 */
	RESOURCE_TYPE_CHANGED = "resource-type-changed",
	/**
	 * The nested stack is created in the deployment
	 */
	NESTED_STACK_CREATION = "nested-stack-creation"
}
export interface RejectionSubject {
	/**
	 * The type of the rejection subject, e.g. Resource or Output
	 */
	readonly type: string;
	/**
	 * The logical ID of the change that is not hotswappable
	 */
	readonly logicalId: string;
	/**
	 * Resource metadata attached to the logical id from the cloud assembly
	 *
	 * This is only present if the resource is present in the current Cloud Assembly,
	 * i.e. resource deletions will not have metadata.
	 */
	readonly metadata?: ResourceMetadata;
}
export interface ResourceSubject extends RejectionSubject {
	/**
	 * A rejected resource
	 */
	readonly type: "Resource";
	/**
	 * The type of the rejected resource
	 */
	readonly resourceType: string;
	/**
	 * The list of properties that are cause for the rejection
	 */
	readonly rejectedProperties?: string[];
}
export interface OutputSubject extends RejectionSubject {
	/**
	 * A rejected output
	 */
	readonly type: "Output";
}
/**
 * A change that can not be hotswapped
 */
export interface NonHotswappableChange {
	/**
	 * The subject of the change that was rejected
	 */
	readonly subject: ResourceSubject | OutputSubject;
	/**
	 * Why was this change was deemed non-hotswappable
	 */
	readonly reason: NonHotswappableReason;
	/**
	 * Tells the user exactly why this change was deemed non-hotswappable and what its logical ID is.
	 * If not specified, `displayReason` default to state that the properties listed in `rejectedChanges` are not hotswappable.
	 */
	readonly description: string;
}
export interface HotswapDeploymentAttempt {
	/**
	 * The stack that's currently being deployed
	 */
	readonly stack: cxapi.CloudFormationStackArtifact;
	/**
	 * The mode the hotswap deployment was initiated with.
	 */
	readonly mode: "hotswap-only" | "fall-back";
}
/**
 * Information about a hotswap deployment
 */
export interface HotswapDeploymentDetails {
	/**
	 * The stack that's currently being deployed
	 */
	readonly stack: cxapi.CloudFormationStackArtifact;
	/**
	 * The mode the hotswap deployment was initiated with.
	 */
	readonly mode: "hotswap-only" | "fall-back";
	/**
	 * The changes that were deemed hotswappable
	 */
	readonly hotswappableChanges: HotswappableChange[];
	/**
	 * The changes that were deemed not hotswappable
	 */
	readonly nonHotswappableChanges: NonHotswappableChange[];
}
/**
 * The result of an attempted hotswap deployment
 */
export interface HotswapResult extends Duration, HotswapDeploymentDetails {
	/**
	 * Whether hotswapping happened or not.
	 *
	 * `false` indicates that the deployment could not be hotswapped and full deployment may be attempted as fallback.
	 */
	readonly hotswapped: boolean;
}

export {
	MissingContext$1 as MissingContext,
};

export {};
