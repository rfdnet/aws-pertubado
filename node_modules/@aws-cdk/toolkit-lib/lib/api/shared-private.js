"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result2 = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result2 = (kind ? decorator(target, key, result2) : decorator(result2)) || result2;
  if (kind && result2) __defProp(target, key, result2);
  return result2;
};

// lib/api/shared-private.ts
var shared_private_exports = {};
__export(shared_private_exports, {
  AccountAccessKeyCache: () => AccountAccessKeyCache,
  ActiveAssetCache: () => ActiveAssetCache,
  ActivityPrinterBase: () => ActivityPrinterBase,
  AmbiguityError: () => AmbiguityError,
  AssemblyError: () => AssemblyError,
  AssetManifestBuilder: () => AssetManifestBuilder,
  AuthenticationError: () => AuthenticationError,
  AwsCliCompatible: () => AwsCliCompatible,
  BOOTSTRAP_VARIANT_PARAMETER: () => BOOTSTRAP_VARIANT_PARAMETER,
  BOOTSTRAP_VERSION_OUTPUT: () => BOOTSTRAP_VERSION_OUTPUT,
  BOOTSTRAP_VERSION_RESOURCE: () => BOOTSTRAP_VERSION_RESOURCE,
  BUCKET_DOMAIN_NAME_OUTPUT: () => BUCKET_DOMAIN_NAME_OUTPUT,
  BUCKET_NAME_OUTPUT: () => BUCKET_NAME_OUTPUT,
  BackgroundStackRefresh: () => BackgroundStackRefresh,
  BaseStackAssembly: () => BaseStackAssembly,
  Bootstrapper: () => Bootstrapper,
  CachedDataSource: () => CachedDataSource,
  CfnEvaluationException: () => CfnEvaluationException,
  CloudFormationStack: () => CloudFormationStack,
  CloudWatchLogEventMonitor: () => CloudWatchLogEventMonitor,
  Context: () => Context,
  ContextProviderError: () => ContextProviderError,
  CredentialPlugins: () => CredentialPlugins,
  CurrentActivityPrinter: () => CurrentActivityPrinter,
  DEFAULT_BOOTSTRAP_VARIANT: () => DEFAULT_BOOTSTRAP_VARIANT,
  DEFAULT_TOOLKIT_STACK_NAME: () => DEFAULT_TOOLKIT_STACK_NAME,
  DeploymentState: () => DeploymentState,
  Deployments: () => Deployments,
  DiffFormatter: () => DiffFormatter,
  ECR_ISOLATED_TAG: () => ECR_ISOLATED_TAG,
  EcsHotswapProperties: () => EcsHotswapProperties,
  EnvironmentAccess: () => EnvironmentAccess,
  EnvironmentResources: () => EnvironmentResources,
  EnvironmentResourcesRegistry: () => EnvironmentResourcesRegistry,
  EvaluateCloudFormationTemplate: () => EvaluateCloudFormationTemplate,
  ExpandStackSelection: () => ExpandStackSelection,
  ExtendedStackSelection: () => ExtendedStackSelection,
  FilteredNotice: () => FilteredNotice,
  GarbageCollector: () => GarbageCollector,
  HistoryActivityPrinter: () => HistoryActivityPrinter,
  HotswapMode: () => HotswapMode,
  HotswapPropertyOverrides: () => HotswapPropertyOverrides,
  ICON: () => ICON,
  IO: () => IO,
  ImageAsset: () => ImageAsset,
  IoDefaultMessages: () => IoDefaultMessages,
  IoHelper: () => IoHelper,
  LazyListStackResources: () => LazyListStackResources,
  LazyLookupExport: () => LazyLookupExport,
  LookupExportError: () => LookupExportError,
  Mode: () => Mode,
  NoBootstrapStackEnvironmentResources: () => NoBootstrapStackEnvironmentResources,
  Notices: () => Notices,
  NoticesFilter: () => NoticesFilter,
  ObjectAsset: () => ObjectAsset,
  PROJECT_CONTEXT: () => PROJECT_CONTEXT,
  PluginHost: () => PluginHost,
  ProgressPrinter: () => ProgressPrinter,
  ProxyAgentProvider: () => ProxyAgentProvider,
  REPOSITORY_NAME_OUTPUT: () => REPOSITORY_NAME_OUTPUT,
  RWLock: () => RWLock,
  RequireApproval: () => RequireApproval,
  ResourceImporter: () => ResourceImporter,
  ResourceLocation: () => ResourceLocation,
  ResourceMapping: () => ResourceMapping,
  ResourceMigrator: () => ResourceMigrator,
  RollbackChoice: () => RollbackChoice,
  S3_ISOLATED_TAG: () => S3_ISOLATED_TAG,
  SDK: () => SDK,
  SPAN: () => SPAN,
  SdkProvider: () => SdkProvider,
  SdkToCliLogger: () => SdkToCliLogger,
  Settings: () => Settings,
  SpanMaker: () => SpanMaker,
  StackActivityMonitor: () => StackActivityMonitor,
  StackCollection: () => StackCollection,
  StackEventPoller: () => StackEventPoller,
  StackProgressMonitor: () => StackProgressMonitor,
  StackSelectionStrategy: () => StackSelectionStrategy,
  StackStatus: () => StackStatus,
  TESTING: () => TESTING,
  TRANSIENT_CONTEXT_KEY: () => TRANSIENT_CONTEXT_KEY,
  ToolkitError: () => ToolkitError,
  ToolkitInfo: () => ToolkitInfo,
  WebsiteNoticeDataSource: () => WebsiteNoticeDataSource,
  WorkGraph: () => WorkGraph,
  WorkGraphBuilder: () => WorkGraphBuilder,
  addMetadataAssetsToManifest: () => addMetadataAssetsToManifest,
  ambiguousMovements: () => ambiguousMovements,
  asIoHelper: () => asIoHelper,
  assertIsSuccessfulDeployStackResult: () => assertIsSuccessfulDeployStackResult,
  cached: () => cached,
  cfnApi: () => cfn_api_exports,
  classifyChanges: () => classifyChanges,
  confirm: () => confirm,
  contextproviders: () => context_providers_exports,
  credentialsAboutToExpire: () => credentialsAboutToExpire,
  debug: () => debug,
  defaultCliUserAgent: () => defaultCliUserAgent,
  determineAllowCrossAccountAssetPublishing: () => determineAllowCrossAccountAssetPublishing,
  error: () => error,
  findCloudWatchLogGroups: () => findCloudWatchLogGroups,
  findResourceMovements: () => findResourceMovements,
  formatAmbiguousMappings: () => formatAmbiguousMappings,
  formatSdkLoggerContent: () => formatSdkLoggerContent,
  formatTypedMappings: () => formatTypedMappings,
  getBootstrapStackInfo: () => getBootstrapStackInfo,
  guessExecutable: () => guessExecutable,
  info: () => info,
  initContextProviderSdk: () => initContextProviderSdk,
  isContextProviderPlugin: () => isContextProviderPlugin,
  isMessageRelevantForLevel: () => isMessageRelevantForLevel,
  legacyBootstrapTemplate: () => legacyBootstrapTemplate,
  loadCurrentTemplate: () => loadCurrentTemplate,
  loadCurrentTemplateWithNestedStacks: () => loadCurrentTemplateWithNestedStacks,
  loadTree: () => loadTree,
  loadTreeFromDir: () => loadTreeFromDir,
  makeBodyParameter: () => makeBodyParameter,
  makeRequestHandler: () => makeRequestHandler,
  markTesting: () => markTesting,
  nonHotswappableChange: () => nonHotswappableChange,
  nonHotswappableResource: () => nonHotswappableResource,
  prepareContext: () => prepareContext,
  prepareDefaultEnvironment: () => prepareDefaultEnvironment,
  refreshStacks: () => refreshStacks,
  removeNonImportResources: () => removeNonImportResources,
  replaceEnvPlaceholders: () => replaceEnvPlaceholders,
  resourceMappings: () => resourceMappings,
  resourceMovements: () => resourceMovements,
  result: () => result,
  setSdkTracing: () => setSdkTracing,
  some: () => some,
  spaceAvailableForContext: () => spaceAvailableForContext,
  tagsForStack: () => tagsForStack,
  trace: () => trace,
  tryHotswapDeployment: () => tryHotswapDeployment,
  warn: () => warn
});
module.exports = __toCommonJS(shared_private_exports);

// ../tmp-toolkit-helpers/src/api/io/private/span.ts
var util = __toESM(require("node:util"));
var uuid = __toESM(require("uuid"));

// ../tmp-toolkit-helpers/src/util/archive.ts
var glob = __toESM(require("glob"));

// ../tmp-toolkit-helpers/src/util/format-error.ts
function formatErrorMessage(error2) {
  if (error2 && Array.isArray(error2.errors)) {
    const innerMessages = error2.errors.map((innerError) => innerError?.message || innerError?.toString()).join("\n");
    return `AggregateError: ${innerMessages}`;
  }
  return error2?.message || error2?.toString() || "Unknown error";
}

// ../tmp-toolkit-helpers/src/util/archive.ts
var archiver = require("archiver");

// ../tmp-toolkit-helpers/src/util/arrays.ts
function flatMap(xs, fn) {
  return flatten(xs.map(fn));
}
function flatten(xs) {
  return Array.prototype.concat.apply([], xs);
}

// ../tmp-toolkit-helpers/src/util/bytes.ts
function formatBytes(bytes, decimals = 2) {
  decimals = decimals < 0 ? 0 : decimals;
  if (bytes === 0) {
    return "0 Bytes";
  }
  const k = 1024;
  const sizes = ["Bytes", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;
}

// ../tmp-toolkit-helpers/src/util/cloudformation.ts
function stackEventHasErrorMessage(status) {
  return status.endsWith("_FAILED") || status === "ROLLBACK_IN_PROGRESS" || status === "UPDATE_ROLLBACK_IN_PROGRESS";
}
function maxResourceTypeLength(template, startWidth = "AWS::CloudFormation::Stack".length) {
  const resources = template && template.Resources || {};
  let maxWidth = startWidth;
  for (const id of Object.keys(resources)) {
    const type = resources[id].Type || "";
    if (type.length > maxWidth) {
      maxWidth = type.length;
    }
  }
  return maxWidth;
}

// ../tmp-toolkit-helpers/src/util/content-hash.ts
var crypto = __toESM(require("crypto"));
function contentHash(data) {
  return crypto.createHash("sha256").update(data).digest("hex");
}
function contentHashAny(value) {
  const ret = crypto.createHash("sha256");
  recurse(value);
  return ret.digest("hex");
  function recurse(x) {
    if (typeof x === "string") {
      ret.update(x);
      return;
    }
    if (Array.isArray(x)) {
      ret.update("[");
      for (const e of x) {
        recurse(e);
        ret.update("||");
      }
      ret.update("]");
      return;
    }
    if (x && typeof x === "object") {
      ret.update("{");
      for (const key of Object.keys(x).sort()) {
        ret.update(key);
        ret.update(":");
        recurse(x[key]);
      }
      ret.update("}");
      return;
    }
    ret.update(`${x}${typeof x}`);
  }
}

// ../tmp-toolkit-helpers/src/util/directories.ts
var fs = __toESM(require("fs"));
var os = __toESM(require("os"));
var path = __toESM(require("path"));

// ../tmp-toolkit-helpers/src/api/toolkit-error.ts
var TOOLKIT_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ToolkitError");
var AUTHENTICATION_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AuthenticationError");
var ASSEMBLY_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AssemblyError");
var CONTEXT_PROVIDER_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ContextProviderError");
var ToolkitError = class _ToolkitError extends Error {
  /**
   * Determines if a given error is an instance of ToolkitError.
   */
  static isToolkitError(x) {
    return x !== null && typeof x === "object" && TOOLKIT_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AuthenticationError.
   */
  static isAuthenticationError(x) {
    return this.isToolkitError(x) && AUTHENTICATION_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isAssemblyError(x) {
    return this.isToolkitError(x) && ASSEMBLY_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isContextProviderError(x) {
    return this.isToolkitError(x) && CONTEXT_PROVIDER_ERROR_SYMBOL in x;
  }
  /**
   * An AssemblyError with an original error as cause
   */
  static withCause(message2, error2) {
    return new _ToolkitError(message2, "toolkit", error2);
  }
  /**
   * The type of the error, defaults to "toolkit".
   */
  type;
  /**
   * Denotes the source of the error as the toolkit.
   */
  source;
  /**
   * The specific original cause of the error, if available
   */
  cause;
  constructor(message2, type = "toolkit", cause) {
    super(message2);
    Object.setPrototypeOf(this, _ToolkitError.prototype);
    Object.defineProperty(this, TOOLKIT_ERROR_SYMBOL, { value: true });
    this.name = new.target.name;
    this.type = type;
    this.source = "toolkit";
    this.cause = cause;
  }
};
var AuthenticationError = class _AuthenticationError extends ToolkitError {
  /**
   * Denotes the source of the error as user.
   */
  source = "user";
  constructor(message2) {
    super(message2, "authentication");
    Object.setPrototypeOf(this, _AuthenticationError.prototype);
    Object.defineProperty(this, AUTHENTICATION_ERROR_SYMBOL, { value: true });
  }
};
var AssemblyError = class _AssemblyError extends ToolkitError {
  /**
   * An AssemblyError with an original error as cause
   */
  static withCause(message2, error2) {
    return new _AssemblyError(message2, void 0, error2);
  }
  /**
   * An AssemblyError with a list of stacks as cause
   */
  static withStacks(message2, stacks) {
    return new _AssemblyError(message2, stacks);
  }
  /**
   * Denotes the source of the error as user.
   */
  source = "user";
  /**
   * The stacks that caused the error, if available
   *
   * The `messages` property of each `cxapi.CloudFormationStackArtifact` will contain the respective errors.
   * Absence indicates synthesis didn't fully complete.
   */
  stacks;
  constructor(message2, stacks, cause) {
    super(message2, "assembly", cause);
    Object.setPrototypeOf(this, _AssemblyError.prototype);
    Object.defineProperty(this, ASSEMBLY_ERROR_SYMBOL, { value: true });
    this.stacks = stacks;
  }
};
var ContextProviderError = class _ContextProviderError extends ToolkitError {
  /**
   * Denotes the source of the error as user.
   */
  source = "user";
  constructor(message2) {
    super(message2, "context-provider");
    Object.setPrototypeOf(this, _ContextProviderError.prototype);
    Object.defineProperty(this, CONTEXT_PROVIDER_ERROR_SYMBOL, { value: true });
  }
};

// ../tmp-toolkit-helpers/src/util/directories.ts
function cdkHomeDir() {
  const tmpDir = fs.realpathSync(os.tmpdir());
  let home;
  try {
    let userInfoHome = os.userInfo().homedir;
    if (userInfoHome == "/var/empty") {
      userInfoHome = void 0;
    }
    home = path.join((userInfoHome ?? os.homedir()).trim(), ".cdk");
  } catch {
  }
  return process.env.CDK_HOME ? path.resolve(process.env.CDK_HOME) : home || fs.mkdtempSync(path.join(tmpDir, ".cdk")).trim();
}
function cdkCacheDir() {
  return path.join(cdkHomeDir(), "cache");
}
function bundledPackageRootDir(start, fail) {
  function _rootDir(dirname3) {
    const manifestPath = path.join(dirname3, "package.json");
    if (fs.existsSync(manifestPath)) {
      return dirname3;
    }
    if (path.dirname(dirname3) === dirname3) {
      if (fail ?? true) {
        throw new ToolkitError("Unable to find package manifest");
      }
      return void 0;
    }
    return _rootDir(path.dirname(dirname3));
  }
  return _rootDir(start);
}

// ../tmp-toolkit-helpers/src/util/json.ts
function getResultObj(jsonObject, identifier, propertiesToReturn) {
  const propsObj = {};
  propertiesToReturn.forEach((propName) => {
    Object.assign(propsObj, { [propName]: findJsonValue(jsonObject, propName) });
  });
  Object.assign(propsObj, { ["Identifier"]: identifier });
  return propsObj;
}
function findJsonValue(jsonObject, path13) {
  const paths = path13.split(".");
  let obj = jsonObject;
  paths.forEach((p) => {
    obj = obj[p];
    if (obj === void 0) {
      throw new TypeError(`Cannot read field ${path13}. ${p} is not found.`);
    }
  });
  return obj;
}

// ../tmp-toolkit-helpers/src/util/types.ts
function isObject(x) {
  return x !== null && typeof x === "object" && !isArray(x);
}
var isArray = Array.isArray;

// ../tmp-toolkit-helpers/src/util/objects.ts
function deepClone(x) {
  if (typeof x === "undefined") {
    return void 0;
  }
  if (x === null) {
    return null;
  }
  if (isArray(x)) {
    return x.map(deepClone);
  }
  if (isObject(x)) {
    return makeObject(mapObject(x, (k, v) => [k, deepClone(v)]));
  }
  return x;
}
function mapObject(x, fn) {
  const ret = [];
  Object.keys(x).forEach((key) => {
    ret.push(fn(key, x[key]));
  });
  return ret;
}
function makeObject(pairs) {
  const ret = {};
  for (const pair of pairs) {
    ret[pair[0]] = pair[1];
  }
  return ret;
}
function deepGet(x, path13) {
  path13 = path13.slice();
  while (path13.length > 0 && isObject(x)) {
    const key = path13.shift();
    x = x[key];
  }
  return path13.length === 0 ? x : void 0;
}
function deepSet(x, path13, value) {
  path13 = path13.slice();
  if (path13.length === 0) {
    throw new ToolkitError("Path may not be empty");
  }
  while (path13.length > 1 && isObject(x)) {
    const key = path13.shift();
    if (isPrototypePollutingKey(key)) {
      continue;
    }
    if (!(key in x)) {
      x[key] = {};
    }
    x = x[key];
  }
  if (!isObject(x)) {
    throw new ToolkitError(`Expected an object, got '${x}'`);
  }
  const finalKey = path13[0];
  if (isPrototypePollutingKey(finalKey)) {
    return;
  }
  if (value !== void 0) {
    x[finalKey] = value;
  } else {
    delete x[finalKey];
  }
}
function isPrototypePollutingKey(key) {
  return key === "__proto__" || key === "constructor" || key === "prototype";
}
function deepMerge(...objects) {
  function mergeOne(target, source) {
    for (const key of Object.keys(source)) {
      if (isPrototypePollutingKey(key)) {
        continue;
      }
      const value = source[key];
      if (isObject(value)) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        mergeOne(target[key], value);
      } else if (typeof value !== "undefined") {
        target[key] = value;
      }
    }
  }
  const others = objects.filter((x) => x != null);
  if (others.length === 0) {
    return {};
  }
  const into = others.splice(0, 1)[0];
  others.forEach((other) => mergeOne(into, other));
  return into;
}
function transformObjectKeys(val, transform, exclude = {}) {
  if (val == null || typeof val !== "object") {
    return val;
  }
  if (Array.isArray(val)) {
    return val.map((input) => transformObjectKeys(input, transform, exclude));
  }
  const ret = {};
  for (const [k, v] of Object.entries(val)) {
    const childExclude = exclude[k];
    if (childExclude === true) {
      ret[transform(k)] = v;
    } else {
      ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
    }
  }
  return ret;
}

// ../tmp-toolkit-helpers/src/util/parallel.ts
async function parallelPromises(n, promises) {
  const ret = new Array();
  let count = 0;
  let error2;
  const queue = [...promises];
  return new Promise((ok, ko) => {
    tick();
    function tick() {
      if (count === 0 && error2) {
        ko(error2);
        return;
      }
      if (count === 0 && queue.length === 0) {
        ok(ret);
        return;
      }
      while (count < n && queue.length > 0 && !error2) {
        const next = queue.shift();
        if (next !== void 0) {
          start(next);
        }
      }
    }
    function start(fn) {
      count += 1;
      fn().then((result2) => {
        ret.push(result2);
      }).catch((e) => {
        error2 = e;
      }).finally(() => {
        count -= 1;
        tick();
      });
    }
  });
}

// ../tmp-toolkit-helpers/src/util/serialize.ts
var fs2 = __toESM(require("fs/promises"));

// ../tmp-toolkit-helpers/src/util/yaml-cfn.ts
var yaml = __toESM(require("yaml"));
var yaml_types = __toESM(require("yaml/types"));
function serialize(obj) {
  const oldFold = yaml_types.strOptions.fold.lineWidth;
  try {
    yaml_types.strOptions.fold.lineWidth = 0;
    return yaml.stringify(obj, { schema: "yaml-1.1" });
  } finally {
    yaml_types.strOptions.fold.lineWidth = oldFold;
  }
}
function deserialize(str) {
  return parseYamlStrWithCfnTags(str);
}
function makeTagForCfnIntrinsic(intrinsicName, addFnPrefix) {
  return {
    identify(value) {
      return typeof value === "string";
    },
    tag: `!${intrinsicName}`,
    resolve: (_doc, cstNode) => {
      const ret = {};
      ret[addFnPrefix ? `Fn::${intrinsicName}` : intrinsicName] = // the +1 is to account for the ! the short form begins with
      parseYamlStrWithCfnTags(cstNode.toString().substring(intrinsicName.length + 1));
      return ret;
    }
  };
}
var shortForms = [
  "Base64",
  "Cidr",
  "FindInMap",
  "GetAZs",
  "ImportValue",
  "Join",
  "Sub",
  "Select",
  "Split",
  "Transform",
  "And",
  "Equals",
  "If",
  "Not",
  "Or",
  "GetAtt"
].map((name) => makeTagForCfnIntrinsic(name, true)).concat(
  makeTagForCfnIntrinsic("Ref", false),
  makeTagForCfnIntrinsic("Condition", false)
);
function parseYamlStrWithCfnTags(text) {
  return yaml.parse(text, {
    customTags: shortForms,
    schema: "core"
  });
}

// ../tmp-toolkit-helpers/src/util/serialize.ts
function toYAML(obj) {
  return serialize(obj);
}
function deserializeStructure(str) {
  return deserialize(str);
}
function serializeStructure(object, json) {
  if (json) {
    return JSON.stringify(object, void 0, 2);
  } else {
    return toYAML(object);
  }
}
async function loadStructuredFile(fileName) {
  const contents = await fs2.readFile(fileName, { encoding: "utf-8" });
  return deserializeStructure(contents);
}
function isJsonBuffer(value) {
  return typeof value === "object" && "type" in value && value.type === "Buffer" && "data" in value && Array.isArray(value.data);
}
function replacerBufferWithInfo(_key, value) {
  if (isJsonBuffer(value)) {
    return `<Buffer: ${formatBytes(value.data.length)}>`;
  }
  return value;
}

// ../tmp-toolkit-helpers/src/util/string-manipulation.ts
function padLeft(n, x, char = " ") {
  return char.repeat(Math.max(0, n - x.length)) + x;
}
function padRight(n, x, char = " ") {
  return x + char.repeat(Math.max(0, n - x.length));
}
function formatTime(num) {
  return roundPercentage(millisecondsToSeconds(num));
}
function roundPercentage(num) {
  return Math.round(100 * num) / 100;
}
function millisecondsToSeconds(num) {
  return num / 1e3;
}
function lowerCaseFirstCharacter(str) {
  return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}

// ../tmp-toolkit-helpers/src/util/version-range.ts
var semver = __toESM(require("semver"));

// ../tmp-toolkit-helpers/src/api/io/private/span.ts
var SpanMaker = class {
  definition;
  ioHelper;
  constructor(ioHelper, definition) {
    this.definition = definition;
    this.ioHelper = ioHelper;
  }
  async begin(a, b) {
    const spanId = uuid.v4();
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const notify = (msg) => {
      return this.ioHelper.notify(withSpanId(spanId, msg));
    };
    const startInput = parseArgs(a, b);
    const startMsg = startInput.message ?? `Starting ${this.definition.name} ...`;
    const startPayload = startInput.payload;
    await notify(this.definition.start.msg(
      startMsg,
      startPayload
    ));
    const timingMsgTemplate = "\n\u2728  %s time: %ds\n";
    const time = () => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - startTime;
      return {
        asMs: elapsedTime,
        asSec: formatTime(elapsedTime)
      };
    };
    return {
      elapsedTime: async () => {
        return time();
      },
      notify: async (msg) => {
        await notify(msg);
      },
      timing: async (maker, message2) => {
        const duration = time();
        const timingMsg = message2 ? message2 : util.format(timingMsgTemplate, this.definition.name, duration.asSec);
        await notify(maker.msg(timingMsg, {
          duration: duration.asMs
        }));
        return duration;
      },
      end: async (x, y) => {
        const duration = time();
        const endInput = parseArgs(x, y);
        const endMsg = endInput.message ?? util.format(timingMsgTemplate, this.definition.name, duration.asSec);
        const endPayload = endInput.payload;
        await notify(this.definition.end.msg(
          endMsg,
          {
            duration: duration.asMs,
            ...endPayload
          }
        ));
        return duration;
      }
    };
  }
};
function parseArgs(first, second) {
  const firstIsMessage = typeof first === "string";
  const message2 = firstIsMessage || second ? first : void 0;
  const payload = firstIsMessage || second ? second : first;
  return {
    message: message2,
    payload
  };
}
function withSpanId(span, message2) {
  return {
    ...message2,
    span
  };
}

// ../tmp-toolkit-helpers/src/api/io/private/io-helper.ts
var IoHelper = class _IoHelper {
  static fromIoHost(ioHost, action) {
    return new _IoHelper(ioHost, action);
  }
  ioHost;
  action;
  constructor(ioHost, action) {
    this.ioHost = ioHost;
    this.action = action;
  }
  /**
   * Forward a message to the IoHost, while injection the current action
   */
  notify(msg) {
    return this.ioHost.notify({
      ...msg,
      action: this.action
    });
  }
  /**
   * Forward a request to the IoHost, while injection the current action
   */
  requestResponse(msg) {
    return this.ioHost.requestResponse({
      ...msg,
      action: this.action
    });
  }
  /**
   * Create a new marker from a given registry entry
   */
  span(definition) {
    return new SpanMaker(this, definition);
  }
};
function asIoHelper(ioHost, action) {
  return IoHelper.fromIoHost(ioHost, action);
}

// ../tmp-toolkit-helpers/src/api/io/private/level-priority.ts
var levels = [
  "trace",
  "debug",
  "info",
  "warn",
  "result",
  "error"
];
var orderedLevels = Object.fromEntries(Object.entries(levels).map((a) => a.reverse()));
function compareFn(a, b) {
  return orderedLevels[a] - orderedLevels[b];
}
function isMessageRelevantForLevel(msg, level) {
  return compareFn(msg.level, level) >= 0;
}

// ../tmp-toolkit-helpers/src/api/io/private/message-maker.ts
function message(level, details) {
  const maker = (text, data) => ({
    time: /* @__PURE__ */ new Date(),
    level,
    code: details.code,
    message: text,
    data
  });
  return {
    ...details,
    level,
    msg: maker,
    is: (m) => m.code === details.code
  };
}
var trace = (details) => message("trace", details);
var debug = (details) => message("debug", details);
var info = (details) => message("info", details);
var warn = (details) => message("warn", details);
var error = (details) => message("error", details);
var result = (details) => message("result", details);
function request(level, details) {
  const maker = (text, data) => ({
    time: /* @__PURE__ */ new Date(),
    level,
    code: details.code,
    message: text,
    data,
    defaultResponse: details.defaultResponse
  });
  return {
    ...details,
    level,
    req: maker
  };
}
var confirm = (details) => request("info", {
  ...details,
  defaultResponse: true
});

// ../tmp-toolkit-helpers/src/api/io/private/messages.ts
var IO = {
  // Defaults (0000)
  DEFAULT_TOOLKIT_INFO: info({
    code: "CDK_TOOLKIT_I0000",
    description: "Default info messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_DEBUG: debug({
    code: "CDK_TOOLKIT_I0000",
    description: "Default debug messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_WARN: warn({
    code: "CDK_TOOLKIT_W0000",
    description: "Default warning messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_ERROR: error({
    code: "CDK_TOOLKIT_E0000",
    description: "Default error messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_TRACE: trace({
    code: "CDK_TOOLKIT_I0000",
    description: "Default trace messages emitted from the Toolkit"
  }),
  // warnings & errors
  CDK_TOOLKIT_W0100: warn({
    code: "CDK_TOOLKIT_W0100",
    description: "Credential plugin warnings"
  }),
  // 1: Synth (1xxx)
  CDK_TOOLKIT_I1000: info({
    code: "CDK_TOOLKIT_I1000",
    description: "Provides synthesis times.",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I1001: trace({
    code: "CDK_TOOLKIT_I1001",
    description: "Cloud Assembly synthesis is starting",
    interface: "StackSelectionDetails"
  }),
  CDK_TOOLKIT_I1901: result({
    code: "CDK_TOOLKIT_I1901",
    description: "Provides stack data",
    interface: "StackAndAssemblyData"
  }),
  CDK_TOOLKIT_I1902: result({
    code: "CDK_TOOLKIT_I1902",
    description: "Successfully deployed stacks",
    interface: "AssemblyData"
  }),
  // 2: List (2xxx)
  CDK_TOOLKIT_I2901: result({
    code: "CDK_TOOLKIT_I2901",
    description: "Provides details on the selected stacks and their dependencies",
    interface: "StackDetailsPayload"
  }),
  // 3: Import & Migrate
  CDK_TOOLKIT_E3900: error({
    code: "CDK_TOOLKIT_E3900",
    description: "Resource import failed",
    interface: "ErrorPayload"
  }),
  // 4: Diff (4xxx)
  CDK_TOOLKIT_I4000: trace({
    code: "CDK_TOOLKIT_I4000",
    description: "Diff stacks is starting",
    interface: "StackSelectionDetails"
  }),
  CDK_TOOLKIT_I4001: info({
    code: "CDK_TOOLKIT_I4001",
    description: "Output of the diff command",
    interface: "DiffResult"
  }),
  // 5: Deploy & Watch (5xxx)
  CDK_TOOLKIT_I5000: info({
    code: "CDK_TOOLKIT_I5000",
    description: "Provides deployment times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5001: info({
    code: "CDK_TOOLKIT_I5001",
    description: "Provides total time in deploy action, including synth and rollback",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5002: info({
    code: "CDK_TOOLKIT_I5002",
    description: "Provides time for resource migration",
    interface: "Duration"
  }),
  CDK_TOOLKIT_W5021: warn({
    code: "CDK_TOOLKIT_W5021",
    description: "Empty non-existent stack, deployment is skipped"
  }),
  CDK_TOOLKIT_W5022: warn({
    code: "CDK_TOOLKIT_W5022",
    description: "Empty existing stack, stack will be destroyed"
  }),
  CDK_TOOLKIT_I5031: info({
    code: "CDK_TOOLKIT_I5031",
    description: "Informs about any log groups that are traced as part of the deployment"
  }),
  CDK_TOOLKIT_I5032: debug({
    code: "CDK_TOOLKIT_I5032",
    description: "Start monitoring log groups",
    interface: "CloudWatchLogMonitorControlEvent"
  }),
  CDK_TOOLKIT_I5033: info({
    code: "CDK_TOOLKIT_I5033",
    description: "A log event received from Cloud Watch",
    interface: "CloudWatchLogEvent"
  }),
  CDK_TOOLKIT_I5034: debug({
    code: "CDK_TOOLKIT_I5034",
    description: "Stop monitoring log groups",
    interface: "CloudWatchLogMonitorControlEvent"
  }),
  CDK_TOOLKIT_E5035: error({
    code: "CDK_TOOLKIT_E5035",
    description: "A log monitoring error",
    interface: "ErrorPayload"
  }),
  CDK_TOOLKIT_I5050: confirm({
    code: "CDK_TOOLKIT_I5050",
    description: "Confirm rollback during deployment",
    interface: "ConfirmationRequest"
  }),
  CDK_TOOLKIT_I5060: confirm({
    code: "CDK_TOOLKIT_I5060",
    description: "Confirm deploy security sensitive changes",
    interface: "DeployConfirmationRequest"
  }),
  CDK_TOOLKIT_I5100: info({
    code: "CDK_TOOLKIT_I5100",
    description: "Stack deploy progress",
    interface: "StackDeployProgress"
  }),
  // Assets (52xx)
  CDK_TOOLKIT_I5210: trace({
    code: "CDK_TOOLKIT_I5210",
    description: "Started building a specific asset",
    interface: "BuildAsset"
  }),
  CDK_TOOLKIT_I5211: trace({
    code: "CDK_TOOLKIT_I5211",
    description: "Building the asset has completed",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5220: trace({
    code: "CDK_TOOLKIT_I5220",
    description: "Started publishing a specific asset",
    interface: "PublishAsset"
  }),
  CDK_TOOLKIT_I5221: trace({
    code: "CDK_TOOLKIT_I5221",
    description: "Publishing the asset has completed",
    interface: "Duration"
  }),
  // Watch (53xx)
  CDK_TOOLKIT_I5310: debug({
    code: "CDK_TOOLKIT_I5310",
    description: "The computed settings used for file watching",
    interface: "WatchSettings"
  }),
  CDK_TOOLKIT_I5311: info({
    code: "CDK_TOOLKIT_I5311",
    description: "File watching started",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5312: info({
    code: "CDK_TOOLKIT_I5312",
    description: "File event detected, starting deployment",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5313: info({
    code: "CDK_TOOLKIT_I5313",
    description: "File event detected during active deployment, changes are queued",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5314: info({
    code: "CDK_TOOLKIT_I5314",
    description: "Initial watch deployment started"
  }),
  CDK_TOOLKIT_I5315: info({
    code: "CDK_TOOLKIT_I5315",
    description: "Queued watch deployment started"
  }),
  // Hotswap (54xx)
  CDK_TOOLKIT_I5400: trace({
    code: "CDK_TOOLKIT_I5400",
    description: "Attempting a hotswap deployment",
    interface: "HotswapDeploymentAttempt"
  }),
  CDK_TOOLKIT_I5401: trace({
    code: "CDK_TOOLKIT_I5401",
    description: "Computed details for the hotswap deployment",
    interface: "HotswapDeploymentDetails"
  }),
  CDK_TOOLKIT_I5402: info({
    code: "CDK_TOOLKIT_I5402",
    description: "A hotswappable change is processed as part of a hotswap deployment",
    interface: "HotswappableChange"
  }),
  CDK_TOOLKIT_I5403: info({
    code: "CDK_TOOLKIT_I5403",
    description: "The hotswappable change has completed processing",
    interface: "HotswappableChange"
  }),
  CDK_TOOLKIT_I5410: info({
    code: "CDK_TOOLKIT_I5410",
    description: "Hotswap deployment has ended, a full deployment might still follow if needed",
    interface: "HotswapResult"
  }),
  // Stack Monitor (55xx)
  CDK_TOOLKIT_I5501: info({
    code: "CDK_TOOLKIT_I5501",
    description: "Stack Monitoring: Start monitoring of a single stack",
    interface: "StackMonitoringControlEvent"
  }),
  CDK_TOOLKIT_I5502: info({
    code: "CDK_TOOLKIT_I5502",
    description: "Stack Monitoring: Activity event for a single stack",
    interface: "StackActivity"
  }),
  CDK_TOOLKIT_I5503: info({
    code: "CDK_TOOLKIT_I5503",
    description: "Stack Monitoring: Finished monitoring of a single stack",
    interface: "StackMonitoringControlEvent"
  }),
  // Success (59xx)
  CDK_TOOLKIT_I5900: result({
    code: "CDK_TOOLKIT_I5900",
    description: "Deployment results on success",
    interface: "SuccessfulDeployStackResult"
  }),
  CDK_TOOLKIT_I5901: info({
    code: "CDK_TOOLKIT_I5901",
    description: "Generic deployment success messages"
  }),
  CDK_TOOLKIT_W5400: warn({
    code: "CDK_TOOLKIT_W5400",
    description: "Hotswap disclosure message"
  }),
  CDK_TOOLKIT_E5001: error({
    code: "CDK_TOOLKIT_E5001",
    description: "No stacks found"
  }),
  CDK_TOOLKIT_E5500: error({
    code: "CDK_TOOLKIT_E5500",
    description: "Stack Monitoring error",
    interface: "ErrorPayload"
  }),
  // 6: Rollback (6xxx)
  CDK_TOOLKIT_I6000: info({
    code: "CDK_TOOLKIT_I6000",
    description: "Provides rollback times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I6100: info({
    code: "CDK_TOOLKIT_I6100",
    description: "Stack rollback progress",
    interface: "StackRollbackProgress"
  }),
  CDK_TOOLKIT_E6001: error({
    code: "CDK_TOOLKIT_E6001",
    description: "No stacks found"
  }),
  CDK_TOOLKIT_E6900: error({
    code: "CDK_TOOLKIT_E6900",
    description: "Rollback failed",
    interface: "ErrorPayload"
  }),
  // 7: Destroy (7xxx)
  CDK_TOOLKIT_I7000: info({
    code: "CDK_TOOLKIT_I7000",
    description: "Provides destroy times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I7001: trace({
    code: "CDK_TOOLKIT_I7001",
    description: "Provides destroy time for a single stack",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I7010: confirm({
    code: "CDK_TOOLKIT_I7010",
    description: "Confirm destroy stacks",
    interface: "ConfirmationRequest"
  }),
  CDK_TOOLKIT_I7100: info({
    code: "CDK_TOOLKIT_I7100",
    description: "Stack destroy progress",
    interface: "StackDestroyProgress"
  }),
  CDK_TOOLKIT_I7101: trace({
    code: "CDK_TOOLKIT_I7101",
    description: "Start stack destroying",
    interface: "StackDestroy"
  }),
  CDK_TOOLKIT_I7900: result({
    code: "CDK_TOOLKIT_I7900",
    description: "Stack deletion succeeded",
    interface: "cxapi.CloudFormationStackArtifact"
  }),
  CDK_TOOLKIT_E7010: error({
    code: "CDK_TOOLKIT_E7010",
    description: "Action was aborted due to negative confirmation of request"
  }),
  CDK_TOOLKIT_E7900: error({
    code: "CDK_TOOLKIT_E7900",
    description: "Stack deletion failed",
    interface: "ErrorPayload"
  }),
  // 8. Refactor (8xxx)
  CDK_TOOLKIT_I8900: result({
    code: "CDK_TOOLKIT_I8900",
    description: "Refactor result",
    interface: "RefactorResult"
  }),
  CDK_TOOLKIT_W8010: warn({
    code: "CDK_TOOLKIT_W8010",
    description: "Refactor execution not yet supported"
  }),
  // 9: Bootstrap (9xxx)
  CDK_TOOLKIT_I9000: info({
    code: "CDK_TOOLKIT_I9000",
    description: "Provides bootstrap times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I9100: info({
    code: "CDK_TOOLKIT_I9100",
    description: "Bootstrap progress",
    interface: "BootstrapEnvironmentProgress"
  }),
  CDK_TOOLKIT_I9900: result({
    code: "CDK_TOOLKIT_I9900",
    description: "Bootstrap results on success",
    interface: "cxapi.Environment"
  }),
  CDK_TOOLKIT_E9900: error({
    code: "CDK_TOOLKIT_E9900",
    description: "Bootstrap failed",
    interface: "ErrorPayload"
  }),
  // Notices
  CDK_TOOLKIT_I0100: info({
    code: "CDK_TOOLKIT_I0100",
    description: "Notices decoration (the header or footer of a list of notices)"
  }),
  CDK_TOOLKIT_W0101: warn({
    code: "CDK_TOOLKIT_W0101",
    description: "A notice that is marked as a warning"
  }),
  CDK_TOOLKIT_E0101: error({
    code: "CDK_TOOLKIT_E0101",
    description: "A notice that is marked as an error"
  }),
  CDK_TOOLKIT_I0101: info({
    code: "CDK_TOOLKIT_I0101",
    description: "A notice that is marked as informational"
  }),
  // Assembly codes
  DEFAULT_ASSEMBLY_TRACE: trace({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default trace messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_DEBUG: debug({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default debug messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_INFO: info({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default info messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_WARN: warn({
    code: "CDK_ASSEMBLY_W0000",
    description: "Default warning messages emitted from Cloud Assembly operations"
  }),
  CDK_ASSEMBLY_I0010: debug({
    code: "CDK_ASSEMBLY_I0010",
    description: "Generic environment preparation debug messages"
  }),
  CDK_ASSEMBLY_W0010: warn({
    code: "CDK_ASSEMBLY_W0010",
    description: "Emitted if the found framework version does not support context overflow"
  }),
  CDK_ASSEMBLY_I0042: debug({
    code: "CDK_ASSEMBLY_I0042",
    description: "Writing updated context",
    interface: "UpdatedContext"
  }),
  CDK_ASSEMBLY_I0240: debug({
    code: "CDK_ASSEMBLY_I0240",
    description: "Context lookup was stopped as no further progress was made. ",
    interface: "MissingContext"
  }),
  CDK_ASSEMBLY_I0241: debug({
    code: "CDK_ASSEMBLY_I0241",
    description: "Fetching missing context. This is an iterative message that may appear multiple times with different missing keys.",
    interface: "MissingContext"
  }),
  CDK_ASSEMBLY_I1000: debug({
    code: "CDK_ASSEMBLY_I1000",
    description: "Cloud assembly output starts"
  }),
  CDK_ASSEMBLY_I1001: info({
    code: "CDK_ASSEMBLY_I1001",
    description: "Output lines emitted by the cloud assembly to stdout"
  }),
  CDK_ASSEMBLY_E1002: error({
    code: "CDK_ASSEMBLY_E1002",
    description: "Output lines emitted by the cloud assembly to stderr"
  }),
  CDK_ASSEMBLY_I1003: info({
    code: "CDK_ASSEMBLY_I1003",
    description: "Cloud assembly output finished"
  }),
  CDK_ASSEMBLY_E1111: error({
    code: "CDK_ASSEMBLY_E1111",
    description: "Incompatible CDK CLI version. Upgrade needed.",
    interface: "ErrorPayload"
  }),
  CDK_ASSEMBLY_I0150: debug({
    code: "CDK_ASSEMBLY_I0150",
    description: "Indicates the use of a pre-synthesized cloud assembly directory"
  }),
  CDK_ASSEMBLY_I0300: info({
    code: "CDK_ASSEMBLY_I0300",
    description: "An info message emitted by a Context Provider",
    interface: "ContextProviderMessageSource"
  }),
  CDK_ASSEMBLY_I0301: debug({
    code: "CDK_ASSEMBLY_I0301",
    description: "A debug message emitted by a Context Provider",
    interface: "ContextProviderMessageSource"
  }),
  // Assembly Annotations
  CDK_ASSEMBLY_I9999: info({
    code: "CDK_ASSEMBLY_I9999",
    description: "Annotations emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  CDK_ASSEMBLY_W9999: warn({
    code: "CDK_ASSEMBLY_W9999",
    description: "Warnings emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  CDK_ASSEMBLY_E9999: error({
    code: "CDK_ASSEMBLY_E9999",
    description: "Errors emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  // SDK codes
  DEFAULT_SDK_TRACE: trace({
    code: "CDK_SDK_I0000",
    description: "An SDK trace message."
  }),
  DEFAULT_SDK_DEBUG: debug({
    code: "CDK_SDK_I0000",
    description: "An SDK debug message."
  }),
  DEFAULT_SDK_WARN: warn({
    code: "CDK_SDK_W0000",
    description: "An SDK warning message."
  }),
  CDK_SDK_I0100: trace({
    code: "CDK_SDK_I0100",
    description: "An SDK trace. SDK traces are emitted as traces to the IoHost, but contain the original SDK logging level.",
    interface: "SdkTrace"
  })
};
var SPAN = {
  SYNTH_ASSEMBLY: {
    name: "Synthesis",
    start: IO.CDK_TOOLKIT_I1001,
    end: IO.CDK_TOOLKIT_I1000
  },
  DEPLOY_STACK: {
    name: "Deployment",
    start: IO.CDK_TOOLKIT_I5100,
    end: IO.CDK_TOOLKIT_I5001
  },
  ROLLBACK_STACK: {
    name: "Rollback",
    start: IO.CDK_TOOLKIT_I6100,
    end: IO.CDK_TOOLKIT_I6000
  },
  DIFF_STACK: {
    name: "Diff",
    start: IO.CDK_TOOLKIT_I4000,
    end: IO.CDK_TOOLKIT_I4001
  },
  DESTROY_STACK: {
    name: "Destroy",
    start: IO.CDK_TOOLKIT_I7100,
    end: IO.CDK_TOOLKIT_I7001
  },
  DESTROY_ACTION: {
    name: "Destroy",
    start: IO.CDK_TOOLKIT_I7101,
    end: IO.CDK_TOOLKIT_I7000
  },
  BOOTSTRAP_SINGLE: {
    name: "Bootstrap",
    start: IO.CDK_TOOLKIT_I9100,
    end: IO.CDK_TOOLKIT_I9000
  },
  BUILD_ASSET: {
    name: "Build Asset",
    start: IO.CDK_TOOLKIT_I5210,
    end: IO.CDK_TOOLKIT_I5211
  },
  PUBLISH_ASSET: {
    name: "Publish Asset",
    start: IO.CDK_TOOLKIT_I5220,
    end: IO.CDK_TOOLKIT_I5221
  },
  HOTSWAP: {
    name: "hotswap-deployment",
    start: IO.CDK_TOOLKIT_I5400,
    end: IO.CDK_TOOLKIT_I5410
  }
};

// ../tmp-toolkit-helpers/src/api/io/private/io-default-messages.ts
var util2 = __toESM(require("util"));
var IoDefaultMessages = class {
  constructor(ioHelper) {
    this.ioHelper = ioHelper;
  }
  notify(msg) {
    return this.ioHelper.notify(msg);
  }
  requestResponse(msg) {
    return this.ioHelper.requestResponse(msg);
  }
  error(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_ERROR, input, ...args);
  }
  warn(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_WARN, input, ...args);
  }
  warning(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_WARN, input, ...args);
  }
  info(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_INFO, input, ...args);
  }
  debug(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_DEBUG, input, ...args);
  }
  trace(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_TRACE, input, ...args);
  }
  result(input, ...args) {
    const message2 = args.length > 0 ? util2.format(input, ...args) : input;
    void this.ioHelper.notify({
      time: /* @__PURE__ */ new Date(),
      code: IO.DEFAULT_TOOLKIT_INFO.code,
      level: "result",
      message: message2,
      data: void 0
    });
  }
  emitMessage(maker, input, ...args) {
    const message2 = args.length > 0 ? util2.format(input, ...args) : input;
    void this.ioHelper.notify(maker.msg(message2));
  }
};

// ../tmp-toolkit-helpers/src/private/activity-printer/base.ts
var ActivityPrinterBase = class {
  constructor(props) {
    this.props = props;
    this.stream = props.stream;
  }
  static TIMESTAMP_WIDTH = 12;
  static STATUS_WIDTH = 20;
  /**
   * Stream to write to
   */
  stream;
  /**
   * The with of the "resource type" column.
   */
  resourceTypeColumnWidth = maxResourceTypeLength({});
  /**
   * A list of resource IDs which are currently being processed
   */
  resourcesInProgress = {};
  stackProgress;
  rollingBack = false;
  failures = new Array();
  hookFailureMap = /* @__PURE__ */ new Map();
  /**
   * Receive a stack activity message
   */
  notify(msg) {
    switch (true) {
      case IO.CDK_TOOLKIT_I5501.is(msg):
        this.start(msg.data);
        break;
      case IO.CDK_TOOLKIT_I5502.is(msg):
        this.activity(msg.data);
        break;
      case IO.CDK_TOOLKIT_I5503.is(msg):
        this.stop();
        break;
      default:
        break;
    }
  }
  start({ stack }) {
    this.resourceTypeColumnWidth = maxResourceTypeLength(stack.template);
  }
  activity(activity) {
    this.addActivity(activity);
    this.print();
  }
  stop() {
    this.print();
  }
  addActivity(activity) {
    const status = activity.event.ResourceStatus;
    const hookStatus = activity.event.HookStatus;
    const hookType = activity.event.HookType;
    if (!status || !activity.event.LogicalResourceId) {
      return;
    }
    this.stackProgress = activity.progress;
    if (status === "ROLLBACK_IN_PROGRESS" || status === "UPDATE_ROLLBACK_IN_PROGRESS") {
      this.rollingBack = true;
    }
    if (status.endsWith("_IN_PROGRESS")) {
      this.resourcesInProgress[activity.event.LogicalResourceId] = activity;
    }
    if (stackEventHasErrorMessage(status)) {
      const isCancelled = (activity.event.ResourceStatusReason ?? "").indexOf("cancelled") > -1;
      if (!isCancelled) {
        this.failures.push(activity);
      }
    }
    if (status.endsWith("_COMPLETE") || status.endsWith("_FAILED")) {
      delete this.resourcesInProgress[activity.event.LogicalResourceId];
    }
    if (hookStatus !== void 0 && hookStatus.endsWith("_COMPLETE_FAILED") && activity.event.LogicalResourceId !== void 0 && hookType !== void 0) {
      if (this.hookFailureMap.has(activity.event.LogicalResourceId)) {
        this.hookFailureMap.get(activity.event.LogicalResourceId)?.set(hookType, activity.event.HookStatusReason ?? "");
      } else {
        this.hookFailureMap.set(activity.event.LogicalResourceId, /* @__PURE__ */ new Map());
        this.hookFailureMap.get(activity.event.LogicalResourceId)?.set(hookType, activity.event.HookStatusReason ?? "");
      }
    }
  }
  failureReason(activity) {
    const resourceStatusReason = activity.event.ResourceStatusReason ?? "";
    const logicalResourceId = activity.event.LogicalResourceId ?? "";
    const hookFailureReasonMap = this.hookFailureMap.get(logicalResourceId);
    if (hookFailureReasonMap !== void 0) {
      for (const hookType of hookFailureReasonMap.keys()) {
        if (resourceStatusReason.includes(hookType)) {
          return resourceStatusReason + " : " + hookFailureReasonMap.get(hookType);
        }
      }
    }
    return resourceStatusReason;
  }
  /**
   * Is the activity a meta activity for the stack itself.
   */
  isActivityForTheStack(activity) {
    return activity.event.PhysicalResourceId === activity.event.StackId;
  }
};

// ../tmp-toolkit-helpers/src/private/activity-printer/history.ts
var util3 = __toESM(require("util"));
var chalk = __toESM(require("chalk"));
var HistoryActivityPrinter = class _HistoryActivityPrinter extends ActivityPrinterBase {
  /**
   * Last time we printed something to the console.
   *
   * Used to measure timeout for progress reporting.
   */
  lastPrintTime = Date.now();
  lastPrinted;
  /**
   * Number of ms of change absence before we tell the user about the resources that are currently in progress.
   */
  inProgressDelay = 3e4;
  printable = new Array();
  constructor(props) {
    super(props);
  }
  activity(activity) {
    this.printable.push(activity);
    super.activity(activity);
  }
  stop() {
    super.stop();
    if (this.failures.length > 0) {
      this.stream.write("\nFailed resources:\n");
      for (const failure of this.failures) {
        if (this.isActivityForTheStack(failure)) {
          continue;
        }
        this.printOne(failure, false);
      }
    }
  }
  print() {
    for (const activity of this.printable) {
      this.printOne(activity);
      this.lastPrinted = activity;
    }
    this.printable.splice(0, this.printable.length);
    this.printInProgress(this.lastPrinted?.progress.formatted);
  }
  printOne(activity, progress) {
    const event = activity.event;
    const color = colorFromStatusResult(event.ResourceStatus);
    let reasonColor = chalk.cyan;
    let stackTrace = "";
    const metadata = activity.metadata;
    if (event.ResourceStatus && event.ResourceStatus.indexOf("FAILED") !== -1) {
      if (progress == void 0 || progress) {
        event.ResourceStatusReason = event.ResourceStatusReason ? this.failureReason(activity) : "";
      }
      if (metadata) {
        stackTrace = metadata.entry.trace ? `
	${metadata.entry.trace.join("\n	\\_ ")}` : "";
      }
      reasonColor = chalk.red;
    }
    const resourceName = metadata ? metadata.constructPath : event.LogicalResourceId || "";
    const logicalId = resourceName !== event.LogicalResourceId ? `(${event.LogicalResourceId}) ` : "";
    this.stream.write(
      util3.format(
        "%s | %s%s | %s | %s | %s %s%s%s\n",
        event.StackName,
        progress !== false ? `${activity.progress.formatted} | ` : "",
        new Date(event.Timestamp).toLocaleTimeString(),
        color(padRight(_HistoryActivityPrinter.STATUS_WIDTH, (event.ResourceStatus || "").slice(0, _HistoryActivityPrinter.STATUS_WIDTH))),
        // pad left and trim
        padRight(this.resourceTypeColumnWidth, event.ResourceType || ""),
        color(chalk.bold(resourceName)),
        logicalId,
        reasonColor(chalk.bold(event.ResourceStatusReason ? event.ResourceStatusReason : "")),
        reasonColor(stackTrace)
      )
    );
    this.lastPrintTime = Date.now();
  }
  /**
   * If some resources are taking a while to create, notify the user about what's currently in progress
   */
  printInProgress(progress) {
    if (!progress || Date.now() < this.lastPrintTime + this.inProgressDelay) {
      return;
    }
    if (Object.keys(this.resourcesInProgress).length > 0) {
      this.stream.write(
        util3.format(
          "%s Currently in progress: %s\n",
          progress,
          chalk.bold(Object.keys(this.resourcesInProgress).join(", "))
        )
      );
    }
    this.lastPrintTime = Infinity;
  }
};
function colorFromStatusResult(status) {
  if (!status) {
    return chalk.reset;
  }
  if (status.indexOf("FAILED") !== -1) {
    return chalk.red;
  }
  if (status.indexOf("ROLLBACK") !== -1) {
    return chalk.yellow;
  }
  if (status.indexOf("COMPLETE") !== -1) {
    return chalk.green;
  }
  return chalk.reset;
}

// ../tmp-toolkit-helpers/src/private/activity-printer/current.ts
var util4 = __toESM(require("util"));
var chalk2 = __toESM(require("chalk"));

// ../tmp-toolkit-helpers/src/private/activity-printer/display.ts
var wrapAnsi = require("wrap-ansi");
var RewritableBlock = class {
  constructor(stream) {
    this.stream = stream;
  }
  lastHeight = 0;
  trailingEmptyLines = 0;
  get width() {
    return this.stream.columns;
  }
  get height() {
    return this.stream.rows;
  }
  displayLines(lines) {
    lines = terminalWrap(this.width, expandNewlines(lines));
    lines = lines.slice(0, getMaxBlockHeight(this.height, this.lastHeight, lines));
    this.stream.write(cursorUp(this.lastHeight));
    for (const line of lines) {
      this.stream.write(cll() + line + "\n");
    }
    this.trailingEmptyLines = Math.max(0, this.lastHeight - lines.length);
    for (let i = 0; i < this.trailingEmptyLines; i++) {
      this.stream.write(cll() + "\n");
    }
    this.lastHeight = Math.max(this.lastHeight, lines.length);
  }
  removeEmptyLines() {
    this.stream.write(cursorUp(this.trailingEmptyLines));
  }
};
var ESC = "\x1B";
function cursorUp(n) {
  n = typeof n === "number" ? n : 1;
  return n > 0 ? ESC + "[" + n + "A" : "";
}
function cll() {
  return ESC + "[K";
}
function terminalWrap(width, lines) {
  if (width === void 0) {
    return lines;
  }
  return lines.flatMap((line) => wrapAnsi(line, width - 1, {
    hard: true,
    trim: true,
    wordWrap: false
  }).split("\n"));
}
function expandNewlines(lines) {
  return lines.flatMap((line) => line.split("\n"));
}
function getMaxBlockHeight(windowHeight, lastHeight, lines) {
  if (windowHeight === void 0) {
    return Math.max(lines.length, lastHeight);
  }
  return lines.length < windowHeight ? lines.length : windowHeight - 1;
}

// ../tmp-toolkit-helpers/src/private/activity-printer/current.ts
var CurrentActivityPrinter = class _CurrentActivityPrinter extends ActivityPrinterBase {
  /**
   * Continuously write to the same output block.
   */
  block;
  constructor(props) {
    super(props);
    this.block = new RewritableBlock(this.stream);
  }
  print() {
    const lines = [];
    const progressWidth = Math.max(
      Math.min((this.block.width ?? 80) - PROGRESSBAR_EXTRA_SPACE - 1, MAX_PROGRESSBAR_WIDTH),
      MIN_PROGRESSBAR_WIDTH
    );
    const prog = this.progressBar(progressWidth);
    if (prog) {
      lines.push("  " + prog, "");
    }
    const toPrint = [...this.failures, ...Object.values(this.resourcesInProgress)];
    toPrint.sort((a, b) => a.event.Timestamp.getTime() - b.event.Timestamp.getTime());
    lines.push(
      ...toPrint.map((res) => {
        const color = colorFromStatusActivity(res.event.ResourceStatus);
        const resourceName = res.metadata?.constructPath ?? res.event.LogicalResourceId ?? "";
        return util4.format(
          "%s | %s | %s | %s%s",
          padLeft(_CurrentActivityPrinter.TIMESTAMP_WIDTH, new Date(res.event.Timestamp).toLocaleTimeString()),
          color(padRight(_CurrentActivityPrinter.STATUS_WIDTH, (res.event.ResourceStatus || "").slice(0, _CurrentActivityPrinter.STATUS_WIDTH))),
          padRight(this.resourceTypeColumnWidth, res.event.ResourceType || ""),
          color(chalk2.bold(shorten(40, resourceName))),
          this.failureReasonOnNextLine(res)
        );
      })
    );
    this.block.displayLines(lines);
  }
  stop() {
    super.stop();
    const lines = new Array();
    for (const failure of this.failures) {
      if (this.isActivityForTheStack(failure)) {
        continue;
      }
      lines.push(
        util4.format(
          chalk2.red("%s | %s | %s | %s%s") + "\n",
          padLeft(_CurrentActivityPrinter.TIMESTAMP_WIDTH, new Date(failure.event.Timestamp).toLocaleTimeString()),
          padRight(_CurrentActivityPrinter.STATUS_WIDTH, (failure.event.ResourceStatus || "").slice(0, _CurrentActivityPrinter.STATUS_WIDTH)),
          padRight(this.resourceTypeColumnWidth, failure.event.ResourceType || ""),
          shorten(40, failure.event.LogicalResourceId ?? ""),
          this.failureReasonOnNextLine(failure)
        )
      );
      const trace2 = failure.metadata?.entry?.trace;
      if (trace2) {
        lines.push(chalk2.red(`	${trace2.join("\n	\\_ ")}
`));
      }
    }
    this.block.displayLines(lines);
    this.block.removeEmptyLines();
  }
  progressBar(width) {
    if (!this.stackProgress || !this.stackProgress.total) {
      return "";
    }
    const fraction = Math.min(this.stackProgress.completed / this.stackProgress.total, 1);
    const innerWidth = Math.max(1, width - 2);
    const chars = innerWidth * fraction;
    const remainder = chars - Math.floor(chars);
    const fullChars = FULL_BLOCK.repeat(Math.floor(chars));
    const partialChar = PARTIAL_BLOCK[Math.floor(remainder * PARTIAL_BLOCK.length)];
    const filler = "\xB7".repeat(innerWidth - Math.floor(chars) - (partialChar ? 1 : 0));
    const color = this.rollingBack ? chalk2.yellow : chalk2.green;
    return "[" + color(fullChars + partialChar) + filler + `] (${this.stackProgress.completed}/${this.stackProgress.total})`;
  }
  failureReasonOnNextLine(activity) {
    return stackEventHasErrorMessage(activity.event.ResourceStatus ?? "") ? `
${" ".repeat(_CurrentActivityPrinter.TIMESTAMP_WIDTH + _CurrentActivityPrinter.STATUS_WIDTH + 6)}${chalk2.red(this.failureReason(activity) ?? "")}` : "";
  }
};
var FULL_BLOCK = "\u2588";
var PARTIAL_BLOCK = ["", "\u258F", "\u258E", "\u258D", "\u258C", "\u258B", "\u258A", "\u2589"];
var MAX_PROGRESSBAR_WIDTH = 60;
var MIN_PROGRESSBAR_WIDTH = 10;
var PROGRESSBAR_EXTRA_SPACE = 2 + 2 + 4 + 6;
function colorFromStatusActivity(status) {
  if (!status) {
    return chalk2.reset;
  }
  if (status.endsWith("_FAILED")) {
    return chalk2.red;
  }
  if (status.startsWith("CREATE_") || status.startsWith("UPDATE_") || status.startsWith("IMPORT_")) {
    return chalk2.green;
  }
  if (status.indexOf("ROLLBACK_") !== -1) {
    return chalk2.yellow;
  }
  if (status.startsWith("DELETE_")) {
    return chalk2.yellow;
  }
  return chalk2.reset;
}
function shorten(maxWidth, p) {
  if (p.length <= maxWidth) {
    return p;
  }
  const half = Math.floor((maxWidth - 3) / 2);
  return p.slice(0, half) + "..." + p.slice(-half);
}

// ../tmp-toolkit-helpers/src/api/aws-auth/proxy-agent.ts
var fs3 = __toESM(require("fs-extra"));
var import_proxy_agent = require("proxy-agent");
var ProxyAgentProvider = class {
  ioHelper;
  constructor(ioHelper) {
    this.ioHelper = ioHelper;
  }
  async create(options) {
    const getProxyForUrl = options.proxyAddress != null ? () => Promise.resolve(options.proxyAddress) : void 0;
    return new import_proxy_agent.ProxyAgent({
      ca: await this.tryGetCACert(options.caBundlePath),
      getProxyForUrl
    });
  }
  async tryGetCACert(bundlePath) {
    const path13 = bundlePath || this.caBundlePathFromEnvironment();
    if (path13) {
      await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(`Using CA bundle path: ${path13}`));
      try {
        if (!fs3.pathExistsSync(path13)) {
          return void 0;
        }
        return fs3.readFileSync(path13, { encoding: "utf-8" });
      } catch (e) {
        await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(String(e)));
        return void 0;
      }
    }
    return void 0;
  }
  /**
   * Find and return a CA certificate bundle path to be passed into the SDK.
   */
  caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
      return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
      return process.env.AWS_CA_BUNDLE;
    }
    return void 0;
  }
};

// ../tmp-toolkit-helpers/src/api/aws-auth/sdk.ts
var import_client_appsync = require("@aws-sdk/client-appsync");
var import_client_cloudcontrol = require("@aws-sdk/client-cloudcontrol");
var import_client_cloudformation = require("@aws-sdk/client-cloudformation");
var import_client_cloudwatch_logs = require("@aws-sdk/client-cloudwatch-logs");
var import_client_codebuild = require("@aws-sdk/client-codebuild");
var import_client_ec2 = require("@aws-sdk/client-ec2");
var import_client_ecr = require("@aws-sdk/client-ecr");
var import_client_ecs = require("@aws-sdk/client-ecs");
var import_client_elastic_load_balancing_v2 = require("@aws-sdk/client-elastic-load-balancing-v2");
var import_client_iam = require("@aws-sdk/client-iam");
var import_client_kms = require("@aws-sdk/client-kms");
var import_client_lambda = require("@aws-sdk/client-lambda");
var import_client_route_53 = require("@aws-sdk/client-route-53");
var import_client_s3 = require("@aws-sdk/client-s3");
var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
var import_client_sfn = require("@aws-sdk/client-sfn");
var import_client_ssm = require("@aws-sdk/client-ssm");
var import_client_sts = require("@aws-sdk/client-sts");
var import_lib_storage = require("@aws-sdk/lib-storage");
var import_middleware_endpoint = require("@smithy/middleware-endpoint");
var import_util_retry = require("@smithy/util-retry");

// ../tmp-toolkit-helpers/src/api/aws-auth/account-cache.ts
var path2 = __toESM(require("path"));
var fs4 = __toESM(require("fs-extra"));
var AccountAccessKeyCache = class _AccountAccessKeyCache {
  /**
   * Max number of entries in the cache, after which the cache will be reset.
   */
  static MAX_ENTRIES = 1e3;
  /**
   * The default path used for the accounts access key cache
   */
  static get DEFAULT_PATH() {
    return path2.join(cdkCacheDir(), "accounts_partitions.json");
  }
  cacheFile;
  debug;
  /**
   * @param filePath Path to the cache file
   */
  constructor(filePath = _AccountAccessKeyCache.DEFAULT_PATH, debugFn) {
    this.cacheFile = filePath;
    this.debug = debugFn;
  }
  /**
   * Tries to fetch the account ID from cache. If it's not in the cache, invokes
   * the resolver function which should retrieve the account ID and return it.
   * Then, it will be stored into disk cache returned.
   *
   * Example:
   *
   *    const accountId = cache.fetch(accessKey, async () => {
   *      return await fetchAccountIdFromSomewhere(accessKey);
   *    });
   */
  async fetch(accessKeyId, resolver) {
    const cached2 = await this.get(accessKeyId);
    if (cached2) {
      await this.debug(`Retrieved account ID ${cached2.accountId} from disk cache`);
      return cached2;
    }
    const account = await resolver();
    if (account) {
      await this.put(accessKeyId, account);
    }
    return account;
  }
  /** Get the account ID from an access key or undefined if not in cache */
  async get(accessKeyId) {
    const map = await this.loadMap();
    return map[accessKeyId];
  }
  /** Put a mapping between access key and account ID */
  async put(accessKeyId, account) {
    let map = await this.loadMap();
    if (Object.keys(map).length >= _AccountAccessKeyCache.MAX_ENTRIES) {
      map = {};
    }
    map[accessKeyId] = account;
    await this.saveMap(map);
  }
  async loadMap() {
    try {
      return await fs4.readJson(this.cacheFile);
    } catch (e) {
      if (e.code === "ENOENT" || e.code === "EACCES") {
        return {};
      }
      if (e instanceof SyntaxError) {
        return {};
      }
      throw e;
    }
  }
  async saveMap(map) {
    try {
      await fs4.ensureFile(this.cacheFile);
      await fs4.writeJson(this.cacheFile, map, { spaces: 2 });
    } catch (e) {
      if (e.code === "ENOENT" || e.code === "EACCES" || e.code === "EROFS") {
        return;
      }
      throw e;
    }
  }
};

// ../tmp-toolkit-helpers/src/api/aws-auth/cached.ts
function cached(obj, sym, fn) {
  if (!(sym in obj)) {
    obj[sym] = fn();
  }
  return obj[sym];
}
async function cachedAsync(obj, sym, fn) {
  if (!(sym in obj)) {
    obj[sym] = await fn();
  }
  return obj[sym];
}

// ../tmp-toolkit-helpers/src/api/aws-auth/tracing.ts
var ENABLED = false;
var INDENT = 0;
function setSdkTracing(enabled) {
  ENABLED = enabled;
}
function callTrace(fn, className, logger) {
  if (!ENABLED || !logger) {
    return;
  }
  logger.info(`[trace] ${" ".repeat(INDENT)}${className || "(anonymous)"}#${fn}()`);
}
function traceCall(receiver, _propertyKey, descriptor, parentClassName) {
  const fn = descriptor.value;
  const className = typeof receiver === "function" ? receiver.name : parentClassName;
  descriptor.value = function(...args) {
    const logger = this.logger;
    if (!ENABLED || typeof logger?.info !== "function") {
      return fn.apply(this, args);
    }
    logger.info.apply(logger, [`[trace] ${" ".repeat(INDENT)}${className || this.constructor.name || "(anonymous)"}#${fn.name}()`]);
    INDENT += 2;
    const ret = fn.apply(this, args);
    if (ret instanceof Promise) {
      return ret.finally(() => {
        INDENT -= 2;
      });
    } else {
      INDENT -= 2;
      return ret;
    }
  };
  return descriptor;
}
function traceMemberMethods(constructor) {
  for (const [name, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(constructor.prototype))) {
    if (typeof descriptor.value !== "function") {
      continue;
    }
    const newDescriptor = traceCall(constructor.prototype, name, descriptor, constructor.name) ?? descriptor;
    Object.defineProperty(constructor.prototype, name, newDescriptor);
  }
}

// ../tmp-toolkit-helpers/src/api/aws-auth/user-agent.ts
var path3 = __toESM(require("path"));

// ../tmp-toolkit-helpers/src/api/aws-auth/util.ts
var fs5 = __toESM(require("fs-extra"));
function readIfPossible(filename) {
  try {
    if (!fs5.pathExistsSync(filename)) {
      return void 0;
    }
    return fs5.readFileSync(filename, { encoding: "utf-8" });
  } catch (e) {
    return void 0;
  }
}

// ../tmp-toolkit-helpers/src/api/aws-auth/user-agent.ts
function defaultCliUserAgent() {
  const root = bundledPackageRootDir(__dirname, false);
  const pkg = JSON.parse((root ? readIfPossible(path3.join(root, "package.json")) : void 0) ?? "{}");
  const name = pkg.name ?? path3.basename(process.argv[1] ?? "cdk-cli");
  const version = pkg.version ?? "<unknown>";
  return `${name}/${version}`;
}

// ../tmp-toolkit-helpers/src/api/aws-auth/sdk.ts
var SDK = class {
  constructor(credProvider, region, requestHandler, ioHelper, logger) {
    this.credProvider = credProvider;
    const debugFn = async (msg) => ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(msg));
    this.accountCache = new AccountAccessKeyCache(AccountAccessKeyCache.DEFAULT_PATH, debugFn);
    this.debug = debugFn;
    this.config = {
      region,
      credentials: credProvider,
      requestHandler,
      retryStrategy: new import_util_retry.ConfiguredRetryStrategy(7, (attempt) => 300 * 2 ** attempt),
      customUserAgent: defaultCliUserAgent(),
      logger
    };
    this.logger = logger;
    this.currentRegion = region;
  }
  currentRegion;
  config;
  logger;
  accountCache;
  /**
   * STS is used to check credential validity, don't do too many retries.
   */
  stsRetryStrategy = new import_util_retry.ConfiguredRetryStrategy(3, (attempt) => 100 * 2 ** attempt);
  /**
   * Whether we have proof that the credentials have not expired
   *
   * We need to do some manual plumbing around this because the JS SDKv2 treats `ExpiredToken`
   * as retriable and we have hefty retries on CFN calls making the CLI hang for a good 15 minutes
   * if the credentials have expired.
   */
  _credentialsValidated = false;
  /**
   * A function to create debug messages
   */
  debug;
  appendCustomUserAgent(userAgentData) {
    if (!userAgentData) {
      return;
    }
    const currentCustomUserAgent = this.config.customUserAgent;
    this.config.customUserAgent = currentCustomUserAgent ? `${currentCustomUserAgent} ${userAgentData}` : userAgentData;
  }
  removeCustomUserAgent(userAgentData) {
    this.config.customUserAgent = this.config.customUserAgent?.replace(userAgentData, "");
  }
  appsync() {
    const client = new import_client_appsync.AppSyncClient(this.config);
    return {
      getSchemaCreationStatus: (input) => client.send(new import_client_appsync.GetSchemaCreationStatusCommand(input)),
      startSchemaCreation: (input) => client.send(new import_client_appsync.StartSchemaCreationCommand(input)),
      updateApiKey: (input) => client.send(new import_client_appsync.UpdateApiKeyCommand(input)),
      updateFunction: (input) => client.send(new import_client_appsync.UpdateFunctionCommand(input)),
      updateResolver: (input) => client.send(new import_client_appsync.UpdateResolverCommand(input)),
      // Pagination Functions
      listFunctions: async (input) => {
        const functions = Array();
        const paginator = (0, import_client_appsync.paginateListFunctions)({ client }, input);
        for await (const page of paginator) {
          functions.push(...page.functions || []);
        }
        return functions;
      }
    };
  }
  cloudControl() {
    const client = new import_client_cloudcontrol.CloudControlClient(this.config);
    return {
      listResources: (input) => client.send(new import_client_cloudcontrol.ListResourcesCommand(input)),
      getResource: (input) => client.send(new import_client_cloudcontrol.GetResourceCommand(input))
    };
  }
  cloudFormation() {
    const client = new import_client_cloudformation.CloudFormationClient({
      ...this.config,
      retryStrategy: new import_util_retry.ConfiguredRetryStrategy(11, (attempt) => 1e3 * 2 ** attempt)
    });
    return {
      continueUpdateRollback: async (input) => client.send(new import_client_cloudformation.ContinueUpdateRollbackCommand(input)),
      createChangeSet: (input) => client.send(new import_client_cloudformation.CreateChangeSetCommand(input)),
      createGeneratedTemplate: (input) => client.send(new import_client_cloudformation.CreateGeneratedTemplateCommand(input)),
      createStack: (input) => client.send(new import_client_cloudformation.CreateStackCommand(input)),
      deleteChangeSet: (input) => client.send(new import_client_cloudformation.DeleteChangeSetCommand(input)),
      deleteGeneratedTemplate: (input) => client.send(new import_client_cloudformation.DeleteGeneratedTemplateCommand(input)),
      deleteStack: (input) => client.send(new import_client_cloudformation.DeleteStackCommand(input)),
      describeChangeSet: (input) => client.send(new import_client_cloudformation.DescribeChangeSetCommand(input)),
      describeGeneratedTemplate: (input) => client.send(new import_client_cloudformation.DescribeGeneratedTemplateCommand(input)),
      describeResourceScan: (input) => client.send(new import_client_cloudformation.DescribeResourceScanCommand(input)),
      describeStacks: (input) => client.send(new import_client_cloudformation.DescribeStacksCommand(input)),
      describeStackResources: (input) => client.send(new import_client_cloudformation.DescribeStackResourcesCommand(input)),
      executeChangeSet: (input) => client.send(new import_client_cloudformation.ExecuteChangeSetCommand(input)),
      getGeneratedTemplate: (input) => client.send(new import_client_cloudformation.GetGeneratedTemplateCommand(input)),
      getTemplate: (input) => client.send(new import_client_cloudformation.GetTemplateCommand(input)),
      getTemplateSummary: (input) => client.send(new import_client_cloudformation.GetTemplateSummaryCommand(input)),
      listExports: (input) => client.send(new import_client_cloudformation.ListExportsCommand(input)),
      listResourceScanRelatedResources: (input) => client.send(new import_client_cloudformation.ListResourceScanRelatedResourcesCommand(input)),
      listResourceScanResources: (input) => client.send(new import_client_cloudformation.ListResourceScanResourcesCommand(input)),
      listResourceScans: (input) => client.send(new import_client_cloudformation.ListResourceScansCommand(input)),
      listStacks: (input) => client.send(new import_client_cloudformation.ListStacksCommand(input)),
      rollbackStack: (input) => client.send(new import_client_cloudformation.RollbackStackCommand(input)),
      startResourceScan: (input) => client.send(new import_client_cloudformation.StartResourceScanCommand(input)),
      updateStack: (input) => client.send(new import_client_cloudformation.UpdateStackCommand(input)),
      updateTerminationProtection: (input) => client.send(new import_client_cloudformation.UpdateTerminationProtectionCommand(input)),
      describeStackEvents: (input) => {
        return client.send(new import_client_cloudformation.DescribeStackEventsCommand(input));
      },
      listStackResources: async (input) => {
        const stackResources = Array();
        const paginator = (0, import_client_cloudformation.paginateListStackResources)({ client }, input);
        for await (const page of paginator) {
          stackResources.push(...page?.StackResourceSummaries || []);
        }
        return stackResources;
      },
      paginatedListStacks: async (input) => {
        const stackResources = Array();
        const paginator = (0, import_client_cloudformation.paginateListStacks)({ client }, input);
        for await (const page of paginator) {
          stackResources.push(...page?.StackSummaries || []);
        }
        return stackResources;
      }
    };
  }
  cloudWatchLogs() {
    const client = new import_client_cloudwatch_logs.CloudWatchLogsClient(this.config);
    return {
      describeLogGroups: (input) => client.send(new import_client_cloudwatch_logs.DescribeLogGroupsCommand(input)),
      filterLogEvents: (input) => client.send(new import_client_cloudwatch_logs.FilterLogEventsCommand(input))
    };
  }
  codeBuild() {
    const client = new import_client_codebuild.CodeBuildClient(this.config);
    return {
      updateProject: (input) => client.send(new import_client_codebuild.UpdateProjectCommand(input))
    };
  }
  ec2() {
    const client = new import_client_ec2.EC2Client(this.config);
    return {
      describeAvailabilityZones: (input) => client.send(new import_client_ec2.DescribeAvailabilityZonesCommand(input)),
      describeImages: (input) => client.send(new import_client_ec2.DescribeImagesCommand(input)),
      describeInstances: (input) => client.send(new import_client_ec2.DescribeInstancesCommand(input)),
      describeRouteTables: (input) => client.send(new import_client_ec2.DescribeRouteTablesCommand(input)),
      describeSecurityGroups: (input) => client.send(new import_client_ec2.DescribeSecurityGroupsCommand(input)),
      describeSubnets: (input) => client.send(new import_client_ec2.DescribeSubnetsCommand(input)),
      describeVpcEndpointServices: (input) => client.send(new import_client_ec2.DescribeVpcEndpointServicesCommand(input)),
      describeVpcs: (input) => client.send(new import_client_ec2.DescribeVpcsCommand(input)),
      describeVpnGateways: (input) => client.send(new import_client_ec2.DescribeVpnGatewaysCommand(input))
    };
  }
  ecr() {
    const client = new import_client_ecr.ECRClient(this.config);
    return {
      batchDeleteImage: (input) => client.send(new import_client_ecr.BatchDeleteImageCommand(input)),
      batchGetImage: (input) => client.send(new import_client_ecr.BatchGetImageCommand(input)),
      createRepository: (input) => client.send(new import_client_ecr.CreateRepositoryCommand(input)),
      describeImages: (input) => client.send(new import_client_ecr.DescribeImagesCommand(input)),
      describeRepositories: (input) => client.send(new import_client_ecr.DescribeRepositoriesCommand(input)),
      getAuthorizationToken: (input) => client.send(new import_client_ecr.GetAuthorizationTokenCommand(input)),
      listImages: (input) => client.send(new import_client_ecr.ListImagesCommand(input)),
      putImage: (input) => client.send(new import_client_ecr.PutImageCommand(input)),
      putImageScanningConfiguration: (input) => client.send(new import_client_ecr.PutImageScanningConfigurationCommand(input))
    };
  }
  ecs() {
    const client = new import_client_ecs.ECSClient(this.config);
    return {
      listClusters: (input) => client.send(new import_client_ecs.ListClustersCommand(input)),
      registerTaskDefinition: (input) => client.send(new import_client_ecs.RegisterTaskDefinitionCommand(input)),
      updateService: (input) => client.send(new import_client_ecs.UpdateServiceCommand(input)),
      // Waiters
      waitUntilServicesStable: (input) => {
        return (0, import_client_ecs.waitUntilServicesStable)(
          {
            client,
            maxWaitTime: 600,
            minDelay: 6,
            maxDelay: 6
          },
          input
        );
      }
    };
  }
  elbv2() {
    const client = new import_client_elastic_load_balancing_v2.ElasticLoadBalancingV2Client(this.config);
    return {
      describeListeners: (input) => client.send(new import_client_elastic_load_balancing_v2.DescribeListenersCommand(input)),
      describeLoadBalancers: (input) => client.send(new import_client_elastic_load_balancing_v2.DescribeLoadBalancersCommand(input)),
      describeTags: (input) => client.send(new import_client_elastic_load_balancing_v2.DescribeTagsCommand(input)),
      // Pagination Functions
      paginateDescribeListeners: async (input) => {
        const listeners = Array();
        const paginator = (0, import_client_elastic_load_balancing_v2.paginateDescribeListeners)({ client }, input);
        for await (const page of paginator) {
          listeners.push(...page?.Listeners || []);
        }
        return listeners;
      },
      paginateDescribeLoadBalancers: async (input) => {
        const loadBalancers = Array();
        const paginator = (0, import_client_elastic_load_balancing_v2.paginateDescribeLoadBalancers)({ client }, input);
        for await (const page of paginator) {
          loadBalancers.push(...page?.LoadBalancers || []);
        }
        return loadBalancers;
      }
    };
  }
  iam() {
    const client = new import_client_iam.IAMClient(this.config);
    return {
      createPolicy: (input) => client.send(new import_client_iam.CreatePolicyCommand(input)),
      getPolicy: (input) => client.send(new import_client_iam.GetPolicyCommand(input)),
      getRole: (input) => client.send(new import_client_iam.GetRoleCommand(input))
    };
  }
  kms() {
    const client = new import_client_kms.KMSClient(this.config);
    return {
      describeKey: (input) => client.send(new import_client_kms.DescribeKeyCommand(input)),
      listAliases: (input) => client.send(new import_client_kms.ListAliasesCommand(input))
    };
  }
  lambda() {
    const client = new import_client_lambda.LambdaClient(this.config);
    return {
      invokeCommand: (input) => client.send(new import_client_lambda.InvokeCommand(input)),
      publishVersion: (input) => client.send(new import_client_lambda.PublishVersionCommand(input)),
      updateAlias: (input) => client.send(new import_client_lambda.UpdateAliasCommand(input)),
      updateFunctionCode: (input) => client.send(new import_client_lambda.UpdateFunctionCodeCommand(input)),
      updateFunctionConfiguration: (input) => client.send(new import_client_lambda.UpdateFunctionConfigurationCommand(input)),
      // Waiters
      waitUntilFunctionUpdated: (delaySeconds, input) => {
        return (0, import_client_lambda.waitUntilFunctionUpdatedV2)(
          {
            client,
            maxDelay: delaySeconds,
            minDelay: delaySeconds,
            maxWaitTime: delaySeconds * 60
          },
          input
        );
      }
    };
  }
  route53() {
    const client = new import_client_route_53.Route53Client(this.config);
    return {
      getHostedZone: (input) => client.send(new import_client_route_53.GetHostedZoneCommand(input)),
      listHostedZones: (input) => client.send(new import_client_route_53.ListHostedZonesCommand(input)),
      listHostedZonesByName: (input) => client.send(new import_client_route_53.ListHostedZonesByNameCommand(input))
    };
  }
  s3() {
    const client = new import_client_s3.S3Client(this.config);
    return {
      deleteObjects: (input) => client.send(new import_client_s3.DeleteObjectsCommand({
        ...input,
        ChecksumAlgorithm: "SHA256"
      })),
      deleteObjectTagging: (input) => client.send(new import_client_s3.DeleteObjectTaggingCommand(input)),
      getBucketEncryption: (input) => client.send(new import_client_s3.GetBucketEncryptionCommand(input)),
      getBucketLocation: (input) => client.send(new import_client_s3.GetBucketLocationCommand(input)),
      getObject: (input) => client.send(new import_client_s3.GetObjectCommand(input)),
      getObjectTagging: (input) => client.send(new import_client_s3.GetObjectTaggingCommand(input)),
      listObjectsV2: (input) => client.send(new import_client_s3.ListObjectsV2Command(input)),
      putObjectTagging: (input) => client.send(new import_client_s3.PutObjectTaggingCommand({
        ...input,
        ChecksumAlgorithm: "SHA256"
      })),
      upload: (input) => {
        try {
          const upload = new import_lib_storage.Upload({
            client,
            params: { ...input, ChecksumAlgorithm: "SHA256" }
          });
          return upload.done();
        } catch (e) {
          throw new AuthenticationError(`Upload failed: ${formatErrorMessage(e)}`);
        }
      }
    };
  }
  secretsManager() {
    const client = new import_client_secrets_manager.SecretsManagerClient(this.config);
    return {
      getSecretValue: (input) => client.send(new import_client_secrets_manager.GetSecretValueCommand(input))
    };
  }
  ssm() {
    const client = new import_client_ssm.SSMClient(this.config);
    return {
      getParameter: (input) => client.send(new import_client_ssm.GetParameterCommand(input))
    };
  }
  stepFunctions() {
    const client = new import_client_sfn.SFNClient(this.config);
    return {
      updateStateMachine: (input) => client.send(new import_client_sfn.UpdateStateMachineCommand(input))
    };
  }
  /**
   * The AWS SDK v3 requires a client config and a command in order to get an endpoint for
   * any given service.
   */
  async getUrlSuffix(region) {
    const cfn = new import_client_cloudformation.CloudFormationClient({ region });
    const endpoint = await (0, import_middleware_endpoint.getEndpointFromInstructions)({}, import_client_cloudformation.DescribeStackResourcesCommand, { ...cfn.config });
    return endpoint.url.hostname.split(`${region}.`).pop();
  }
  async currentAccount() {
    return cachedAsync(this, CURRENT_ACCOUNT_KEY, async () => {
      const creds = await this.credProvider();
      return this.accountCache.fetch(creds.accessKeyId, async () => {
        await this.debug("Looking up default account ID from STS");
        const client = new import_client_sts.STSClient({
          ...this.config,
          retryStrategy: this.stsRetryStrategy
        });
        const command = new import_client_sts.GetCallerIdentityCommand({});
        const result2 = await client.send(command);
        const accountId = result2.Account;
        const partition2 = result2.Arn.split(":")[1];
        if (!accountId) {
          throw new AuthenticationError("STS didn't return an account ID");
        }
        await this.debug(`Default account ID: ${accountId}`);
        this._credentialsValidated = true;
        return { accountId, partition: partition2 };
      });
    });
  }
  /**
   * Make sure the the current credentials are not expired
   */
  async validateCredentials() {
    if (this._credentialsValidated) {
      return;
    }
    const client = new import_client_sts.STSClient({ ...this.config, retryStrategy: this.stsRetryStrategy });
    await client.send(new import_client_sts.GetCallerIdentityCommand({}));
    this._credentialsValidated = true;
  }
};
SDK = __decorateClass([
  traceMemberMethods
], SDK);
var CURRENT_ACCOUNT_KEY = Symbol("current_account_key");

// ../tmp-toolkit-helpers/src/api/aws-auth/sdk-provider.ts
var os2 = __toESM(require("os"));
var import_cx_api = require("@aws-cdk/cx-api");
var import_credential_providers2 = require("@aws-sdk/credential-providers");

// ../tmp-toolkit-helpers/src/api/aws-auth/awscli-compatible.ts
var import_node_util = require("node:util");
var import_credential_providers = require("@aws-sdk/credential-providers");
var import_ec2_metadata_service = require("@aws-sdk/ec2-metadata-service");
var import_shared_ini_file_loader = require("@smithy/shared-ini-file-loader");
var promptly = __toESM(require("promptly"));

// ../tmp-toolkit-helpers/src/api/aws-auth/provider-caching.ts
var import_property_provider = require("@smithy/property-provider");
function makeCachingProvider(provider) {
  return (0, import_property_provider.memoize)(
    provider,
    credentialsAboutToExpire,
    (token) => !!token.expiration
  );
}
function credentialsAboutToExpire(token) {
  const expiryMarginSecs = 5;
  return !!token.expiration && token.expiration.getTime() - Date.now() < expiryMarginSecs * 1e3;
}

// ../tmp-toolkit-helpers/src/api/aws-auth/awscli-compatible.ts
var DEFAULT_CONNECTION_TIMEOUT = 1e4;
var DEFAULT_TIMEOUT = 3e5;
var AwsCliCompatible = class {
  ioHelper;
  requestHandler;
  logger;
  constructor(ioHelper, requestHandler, logger) {
    this.ioHelper = ioHelper;
    this.requestHandler = requestHandler;
    this.logger = logger;
  }
  async baseConfig(profile) {
    const credentialProvider = await this.credentialChainBuilder({
      profile,
      logger: this.logger
    });
    const defaultRegion = await this.region(profile);
    return { credentialProvider, defaultRegion };
  }
  /**
   * Build an AWS CLI-compatible credential chain provider
   *
   * The credential chain returned by this function is always caching.
   */
  async credentialChainBuilder(options = {}) {
    const clientConfig = {
      requestHandler: this.requestHandler,
      customUserAgent: "aws-cdk",
      logger: options.logger
    };
    const parentClientConfig = {
      region: await this.region(options.profile)
    };
    if (options.profile) {
      return makeCachingProvider((0, import_credential_providers.fromIni)({
        profile: options.profile,
        ignoreCache: true,
        mfaCodeProvider: this.tokenCodeFn.bind(this),
        clientConfig,
        parentClientConfig,
        logger: options.logger
      }));
    }
    const envProfile = process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE;
    const nodeProviderChain = (0, import_credential_providers.fromNodeProviderChain)({
      profile: envProfile,
      clientConfig,
      parentClientConfig,
      logger: options.logger,
      mfaCodeProvider: this.tokenCodeFn.bind(this),
      ignoreCache: true
    });
    return shouldPrioritizeEnv() ? (0, import_credential_providers.createCredentialChain)((0, import_credential_providers.fromEnv)(), nodeProviderChain).expireAfter(60 * 6e4) : nodeProviderChain;
  }
  /**
   * Attempts to get the region from a number of sources and falls back to us-east-1 if no region can be found,
   * as is done in the AWS CLI.
   *
   * The order of priority is the following:
   *
   * 1. Environment variables specifying region, with both an AWS prefix and AMAZON prefix
   *    to maintain backwards compatibility, and without `DEFAULT` in the name because
   *    Lambda and CodeBuild set the $AWS_REGION variable.
   * 2. Regions listed in the Shared Ini Files - First checking for the profile provided
   *    and then checking for the default profile.
   * 3. IMDS instance identity region from the Metadata Service.
   * 4. us-east-1
   */
  async region(maybeProfile) {
    const defaultRegion = "us-east-1";
    const profile = maybeProfile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || "default";
    const region = process.env.AWS_REGION || process.env.AMAZON_REGION || process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION || await this.getRegionFromIni(profile) || await this.regionFromMetadataService();
    if (!region) {
      const usedProfile = !profile ? "" : ` (profile: "${profile}")`;
      await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(
        `Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${defaultRegion}'`
      ));
      return defaultRegion;
    }
    return region;
  }
  /**
   * The MetadataService class will attempt to fetch the instance identity document from
   * IMDSv2 first, and then will attempt v1 as a fallback.
   *
   * If this fails, we will use us-east-1 as the region so no error should be thrown.
   * @returns The region for the instance identity
   */
  async regionFromMetadataService() {
    await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg("Looking up AWS region in the EC2 Instance Metadata Service (IMDS)."));
    try {
      const metadataService = new import_ec2_metadata_service.MetadataService({
        httpOptions: {
          timeout: 1e3
        }
      });
      await metadataService.fetchMetadataToken();
      const document = await metadataService.request("/latest/dynamic/instance-identity/document", {});
      return JSON.parse(document).region;
    } catch (e) {
      await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(`Unable to retrieve AWS region from IMDS: ${e}`));
    }
  }
  /**
   * Looks up the region of the provided profile. If no region is present,
   * it will attempt to lookup the default region.
   * @param profile The profile to use to lookup the region
   * @returns The region for the profile or default profile, if present. Otherwise returns undefined.
   */
  async getRegionFromIni(profile) {
    const sharedFiles = await (0, import_shared_ini_file_loader.loadSharedConfigFiles)({ ignoreCache: true });
    return this.getRegionFromIniFile(profile, sharedFiles.credentialsFile) ?? this.getRegionFromIniFile(profile, sharedFiles.configFile) ?? this.getRegionFromIniFile("default", sharedFiles.credentialsFile) ?? this.getRegionFromIniFile("default", sharedFiles.configFile);
  }
  getRegionFromIniFile(profile, data) {
    return data?.[profile]?.region;
  }
  /**
   * Ask user for MFA token for given serial
   *
   * Result is send to callback function for SDK to authorize the request
   */
  async tokenCodeFn(serialArn) {
    const debugFn = (msg, ...args) => this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg((0, import_node_util.format)(msg, ...args)));
    await debugFn("Require MFA token for serial ARN", serialArn);
    try {
      const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
        trim: true,
        default: ""
      });
      await debugFn("Successfully got MFA token from user");
      return token;
    } catch (err) {
      await debugFn("Failed to get MFA token", err);
      const e = new AuthenticationError(`Error fetching MFA token: ${err.message ?? err}`);
      e.name = "SharedIniFileCredentialsProviderFailure";
      throw e;
    }
  }
};
function shouldPrioritizeEnv() {
  const id = process.env.AWS_ACCESS_KEY_ID || process.env.AMAZON_ACCESS_KEY_ID;
  const key = process.env.AWS_SECRET_ACCESS_KEY || process.env.AMAZON_SECRET_ACCESS_KEY;
  if (!!id && !!key) {
    process.env.AWS_ACCESS_KEY_ID = id;
    process.env.AWS_SECRET_ACCESS_KEY = key;
    const sessionToken = process.env.AWS_SESSION_TOKEN ?? process.env.AMAZON_SESSION_TOKEN;
    if (sessionToken) {
      process.env.AWS_SESSION_TOKEN = sessionToken;
    }
    return true;
  }
  return false;
}
async function makeRequestHandler(ioHelper, options = {}) {
  const agent = await new ProxyAgentProvider(ioHelper).create(options);
  return {
    connectionTimeout: DEFAULT_CONNECTION_TIMEOUT,
    requestTimeout: DEFAULT_TIMEOUT,
    httpsAgent: agent,
    httpAgent: agent
  };
}

// ../tmp-toolkit-helpers/src/api/aws-auth/credential-plugins.ts
var import_util9 = require("util");
var CredentialPlugins = class {
  constructor(host, ioHelper) {
    this.host = host;
    this.ioHelper = ioHelper;
  }
  cache = {};
  async fetchCredentialsFor(awsAccountId, mode) {
    const key = `${awsAccountId}-${mode}`;
    if (!(key in this.cache)) {
      this.cache[key] = await this.lookupCredentials(awsAccountId, mode);
    }
    return this.cache[key];
  }
  get availablePluginNames() {
    return this.host.credentialProviderSources.map((s) => s.name);
  }
  async lookupCredentials(awsAccountId, mode) {
    const triedSources = [];
    for (const source of this.host.credentialProviderSources) {
      let available;
      try {
        available = await source.isAvailable();
      } catch (e) {
        await this.ioHelper.notify(IO.CDK_TOOLKIT_W0100.msg(`Uncaught exception in ${source.name}: ${formatErrorMessage(e)}`));
        available = false;
      }
      if (!available) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Credentials source ${source.name} is not available, ignoring it.`));
        continue;
      }
      triedSources.push(source);
      let canProvide;
      try {
        canProvide = await source.canProvideCredentials(awsAccountId);
      } catch (e) {
        await this.ioHelper.notify(IO.CDK_TOOLKIT_W0100.msg(`Uncaught exception in ${source.name}: ${formatErrorMessage(e)}`));
        canProvide = false;
      }
      if (!canProvide) {
        continue;
      }
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Using ${source.name} credentials for account ${awsAccountId}`));
      return {
        credentials: await v3ProviderFromPlugin(() => source.getProvider(awsAccountId, mode, {
          supportsV3Providers: true
        })),
        pluginName: source.name
      };
    }
    return void 0;
  }
};
async function v3ProviderFromPlugin(producer) {
  const initial = await producer();
  if (isV3Provider(initial)) {
    return makeCachingProvider(initial);
  } else if (isV3Credentials(initial) && initial.expiration === void 0) {
    return () => Promise.resolve(initial);
  } else if (isV3Credentials(initial) && initial.expiration !== void 0) {
    return refreshFromPluginProvider(initial, producer);
  } else if (isV2Credentials(initial)) {
    return v3ProviderFromV2Credentials(initial);
  } else {
    throw new AuthenticationError(`Plugin returned a value that doesn't resemble AWS credentials: ${(0, import_util9.inspect)(initial)}`);
  }
}
function v3ProviderFromV2Credentials(x) {
  return async () => {
    await x.getPromise();
    return {
      accessKeyId: x.accessKeyId,
      secretAccessKey: x.secretAccessKey,
      sessionToken: x.sessionToken,
      expiration: x.expireTime ?? void 0
    };
  };
}
function refreshFromPluginProvider(current, producer) {
  return async () => {
    if (credentialsAboutToExpire(current)) {
      const newCreds = await producer();
      if (!isV3Credentials(newCreds)) {
        throw new AuthenticationError(`Plugin initially returned static V3 credentials but now returned something else: ${(0, import_util9.inspect)(newCreds)}`);
      }
      current = newCreds;
    }
    return current;
  };
}
function isV3Provider(x) {
  return typeof x === "function";
}
function isV2Credentials(x) {
  return !!(x && typeof x === "object" && x.getPromise);
}
function isV3Credentials(x) {
  return !!(x && typeof x === "object" && x.accessKeyId && !isV2Credentials(x));
}

// ../tmp-toolkit-helpers/src/api/plugin/plugin.ts
var import_util11 = require("util");

// ../tmp-toolkit-helpers/src/api/plugin/context-provider-plugin.ts
function isContextProviderPlugin(x) {
  return typeof x === "object" && !!x && !!x.getValue;
}

// ../tmp-toolkit-helpers/src/api/plugin/plugin.ts
var TESTING = false;
function markTesting() {
  TESTING = true;
}
var PluginHost = class {
  /**
   * Access the currently registered CredentialProviderSources. New sources can
   * be registered using the +registerCredentialProviderSource+ method.
   */
  credentialProviderSources = new Array();
  contextProviderPlugins = {};
  ioHost;
  alreadyLoaded = /* @__PURE__ */ new Set();
  /**
   * Loads a plug-in into this PluginHost.
   *
   * Will use `require.resolve()` to get the most accurate representation of what
   * code will get loaded in error messages. As such, it will not work in
   * unit tests with Jest virtual modules becauase of <https://github.com/jestjs/jest/issues/9543>.
   *
   * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
   * @param ioHost the I/O host to use for printing progress information
   */
  load(moduleSpec, ioHost) {
    try {
      const resolved = require.resolve(moduleSpec);
      if (ioHost) {
        new IoDefaultMessages(IoHelper.fromIoHost(ioHost, "init")).debug(`Loading plug-in: ${resolved} from ${moduleSpec}`);
      }
      return this._doLoad(resolved);
    } catch (e) {
      throw new ToolkitError(`Unable to resolve plug-in: Cannot find module '${moduleSpec}': ${e}`);
    }
  }
  /**
   * Do the loading given an already-resolved module name
   *
   * @internal
   */
  _doLoad(resolved) {
    try {
      if (this.alreadyLoaded.has(resolved)) {
        return;
      }
      const plugin = require(resolved);
      if (!isPlugin(plugin)) {
        throw new ToolkitError(`Module ${resolved} is not a valid plug-in, or has an unsupported version.`);
      }
      if (plugin.init) {
        plugin.init(this);
      }
      this.alreadyLoaded.add(resolved);
    } catch (e) {
      throw ToolkitError.withCause(`Unable to load plug-in '${resolved}'`, e);
    }
    function isPlugin(x) {
      return x != null && x.version === "1";
    }
  }
  /**
   * Allows plug-ins to register new CredentialProviderSources.
   *
   * @param source a new CredentialProviderSource to register.
   */
  registerCredentialProviderSource(source) {
    this.credentialProviderSources.push(source);
  }
  /**
   * (EXPERIMENTAL) Allow plugins to register context providers
   *
   * Context providers are objects with the following method:
   *
   * ```ts
   *   getValue(args: {[key: string]: any}): Promise<any>;
   * ```
   *
   * Currently, they cannot reuse the CDK's authentication mechanisms, so they
   * must be prepared to either not make AWS calls or use their own source of
   * AWS credentials.
   *
   * This feature is experimental, and only intended to be used internally at Amazon
   * as a trial.
   *
   * After registering with 'my-plugin-name', the provider must be addressed as follows:
   *
   * ```ts
   * const value = ContextProvider.getValue(this, {
   *   providerName: 'plugin',
   *   props: {
   *     pluginName: 'my-plugin-name',
   *     myParameter1: 'xyz',
   *   },
   *   includeEnvironment: true | false,
   *   dummyValue: 'what-to-return-on-the-first-pass',
   * })
   * ```
   *
   * @experimental
   */
  registerContextProviderAlpha(pluginProviderName, provider) {
    if (!isContextProviderPlugin(provider)) {
      throw new ToolkitError(`Object you gave me does not look like a ContextProviderPlugin: ${(0, import_util11.inspect)(provider)}`);
    }
    this.contextProviderPlugins[pluginProviderName] = provider;
  }
};

// ../tmp-toolkit-helpers/src/api/plugin/mode.ts
var Mode = /* @__PURE__ */ ((Mode2) => {
  Mode2[Mode2["ForReading"] = 0] = "ForReading";
  Mode2[Mode2["ForWriting"] = 1] = "ForWriting";
  return Mode2;
})(Mode || {});

// ../tmp-toolkit-helpers/src/api/aws-auth/sdk-provider.ts
var CACHED_ACCOUNT = Symbol("cached_account");
var SdkProvider = class {
  /**
   * Create a new SdkProvider which gets its defaults in a way that behaves like the AWS CLI does
   *
   * The AWS SDK for JS behaves slightly differently from the AWS CLI in a number of ways; see the
   * class `AwsCliCompatible` for the details.
   */
  static async withAwsCliCompatibleDefaults(options) {
    callTrace(SdkProvider.withAwsCliCompatibleDefaults.name, SdkProvider.constructor.name, options.logger);
    const config = await new AwsCliCompatible(options.ioHelper, options.requestHandler ?? {}, options.logger).baseConfig(options.profile);
    return new SdkProvider(config.credentialProvider, config.defaultRegion, options);
  }
  defaultRegion;
  defaultCredentialProvider;
  plugins;
  requestHandler;
  ioHelper;
  logger;
  constructor(defaultCredentialProvider, defaultRegion, services) {
    this.defaultCredentialProvider = defaultCredentialProvider;
    this.defaultRegion = defaultRegion ?? "us-east-1";
    this.requestHandler = services.requestHandler ?? {};
    this.ioHelper = services.ioHelper;
    this.logger = services.logger;
    this.plugins = new CredentialPlugins(services.pluginHost ?? new PluginHost(), this.ioHelper);
  }
  /**
   * Return an SDK which can do operations in the given environment
   *
   * The `environment` parameter is resolved first (see `resolveEnvironment()`).
   */
  async forEnvironment(environment, mode, options, quiet = false) {
    const env = await this.resolveEnvironment(environment);
    const baseCreds = await this.obtainBaseCredentials(env.account, mode);
    if (baseCreds.source === "none") {
      throw new AuthenticationError(fmtObtainCredentialsError(env.account, baseCreds));
    }
    if (options?.assumeRoleArn === void 0) {
      if (baseCreds.source === "incorrectDefault") {
        throw new AuthenticationError(fmtObtainCredentialsError(env.account, baseCreds));
      }
      const sdk = this._makeSdk(baseCreds.credentials, env.region);
      await sdk.validateCredentials();
      return { sdk, didAssumeRole: false };
    }
    try {
      const sdk = await this.withAssumedRole(
        baseCreds,
        options.assumeRoleArn,
        options.assumeRoleExternalId,
        options.assumeRoleAdditionalOptions,
        env.region
      );
      return { sdk, didAssumeRole: true };
    } catch (err) {
      if (err.name === "ExpiredToken") {
        throw err;
      }
      if (baseCreds.source === "correctDefault" || baseCreds.source === "plugin") {
        await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(err.message));
        const maker = quiet ? IO.DEFAULT_SDK_DEBUG : IO.DEFAULT_SDK_WARN;
        await this.ioHelper.notify(maker.msg(
          `${fmtObtainedCredentials(baseCreds)} could not be used to assume '${options.assumeRoleArn}', but are for the right account. Proceeding anyway.`
        ));
        return {
          sdk: this._makeSdk(baseCreds.credentials, env.region),
          didAssumeRole: false
        };
      }
      throw err;
    }
  }
  /**
   * Return the partition that base credentials are for
   *
   * Returns `undefined` if there are no base credentials.
   */
  async baseCredentialsPartition(environment, mode) {
    const env = await this.resolveEnvironment(environment);
    const baseCreds = await this.obtainBaseCredentials(env.account, mode);
    if (baseCreds.source === "none") {
      return void 0;
    }
    return (await this._makeSdk(baseCreds.credentials, env.region).currentAccount()).partition;
  }
  /**
   * Resolve the environment for a stack
   *
   * Replaces the magic values `UNKNOWN_REGION` and `UNKNOWN_ACCOUNT`
   * with the defaults for the current SDK configuration (`~/.aws/config` or
   * otherwise).
   *
   * It is an error if `UNKNOWN_ACCOUNT` is used but the user hasn't configured
   * any SDK credentials.
   */
  async resolveEnvironment(env) {
    const region = env.region !== import_cx_api.UNKNOWN_REGION ? env.region : this.defaultRegion;
    const account = env.account !== import_cx_api.UNKNOWN_ACCOUNT ? env.account : (await this.defaultAccount())?.accountId;
    if (!account) {
      throw new AuthenticationError(
        "Unable to resolve AWS account to use. It must be either configured when you define your CDK Stack, or through the environment"
      );
    }
    return {
      region,
      account,
      name: import_cx_api.EnvironmentUtils.format(account, region)
    };
  }
  /**
   * The account we'd auth into if we used default credentials.
   *
   * Default credentials are the set of ambiently configured credentials using
   * one of the environment variables, or ~/.aws/credentials, or the *one*
   * profile that was passed into the CLI.
   *
   * Might return undefined if there are no default/ambient credentials
   * available (in which case the user should better hope they have
   * credential plugins configured).
   *
   * Uses a cache to avoid STS calls if we don't need 'em.
   */
  async defaultAccount() {
    return cached(this, CACHED_ACCOUNT, async () => {
      try {
        return await this._makeSdk(this.defaultCredentialProvider, this.defaultRegion).currentAccount();
      } catch (e) {
        if (e.name === "ExpiredToken") {
          await this.ioHelper.notify(IO.DEFAULT_SDK_WARN.msg(
            "There are expired AWS credentials in your environment. The CDK app will synth without current account information."
          ));
          return void 0;
        }
        await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(`Unable to determine the default AWS account (${e.name}): ${formatErrorMessage(e)}`));
        return void 0;
      }
    });
  }
  /**
   * Get credentials for the given account ID in the given mode
   *
   * 1. Use the default credentials if the destination account matches the
   *    current credentials' account.
   * 2. Otherwise try all credential plugins.
   * 3. Fail if neither of these yield any credentials.
   * 4. Return a failure if any of them returned credentials
   */
  async obtainBaseCredentials(accountId, mode) {
    const defaultAccountId = (await this.defaultAccount())?.accountId;
    if (defaultAccountId === accountId) {
      return {
        source: "correctDefault",
        credentials: await this.defaultCredentialProvider
      };
    }
    const pluginCreds = await this.plugins.fetchCredentialsFor(accountId, mode);
    if (pluginCreds) {
      return { source: "plugin", ...pluginCreds };
    }
    if (defaultAccountId !== void 0) {
      return {
        source: "incorrectDefault",
        accountId: defaultAccountId,
        credentials: await this.defaultCredentialProvider,
        unusedPlugins: this.plugins.availablePluginNames
      };
    }
    return {
      source: "none",
      unusedPlugins: this.plugins.availablePluginNames
    };
  }
  /**
   * Return an SDK which uses assumed role credentials
   *
   * The base credentials used to retrieve the assumed role credentials will be the
   * same credentials returned by obtainCredentials if an environment and mode is passed,
   * otherwise it will be the current credentials.
   */
  async withAssumedRole(mainCredentials, roleArn, externalId, additionalOptions, region) {
    await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(`Assuming role '${roleArn}'.`));
    region = region ?? this.defaultRegion;
    const sourceDescription = fmtObtainedCredentials(mainCredentials);
    try {
      const credentials = await makeCachingProvider((0, import_credential_providers2.fromTemporaryCredentials)({
        masterCredentials: mainCredentials.credentials,
        params: {
          RoleArn: roleArn,
          ExternalId: externalId,
          RoleSessionName: `aws-cdk-${safeUsername()}`,
          ...additionalOptions,
          TransitiveTagKeys: additionalOptions?.Tags ? additionalOptions.Tags.map((t) => t.Key) : void 0
        },
        clientConfig: {
          region,
          requestHandler: this.requestHandler,
          customUserAgent: "aws-cdk",
          logger: this.logger
        },
        logger: this.logger
      }));
      await credentials();
      return this._makeSdk(credentials, region);
    } catch (err) {
      if (err.name === "ExpiredToken") {
        throw err;
      }
      await this.ioHelper.notify(IO.DEFAULT_SDK_DEBUG.msg(`Assuming role failed: ${err.message}`));
      throw new AuthenticationError(
        [
          "Could not assume role in target account",
          ...sourceDescription ? [`using ${sourceDescription}`] : [],
          err.message,
          ". Please make sure that this role exists in the account. If it doesn't exist, (re)-bootstrap the environment with the right '--trust', using the latest version of the CDK CLI."
        ].join(" ")
      );
    }
  }
  /**
   * Factory function that creates a new SDK instance
   *
   * This is a function here, instead of all the places where this is used creating a `new SDK`
   * instance, so that it is trivial to mock from tests.
   *
   * Use like this:
   *
   * ```ts
   * const mockSdk = jest.spyOn(SdkProvider.prototype, '_makeSdk').mockReturnValue(new MockSdk());
   * // ...
   * mockSdk.mockRestore();
   * ```
   *
   * @internal
   */
  _makeSdk(credProvider, region) {
    return new SDK(credProvider, region, this.requestHandler, this.ioHelper, this.logger);
  }
};
SdkProvider = __decorateClass([
  traceMemberMethods
], SdkProvider);
function safeUsername() {
  try {
    return os2.userInfo().username.replace(/[^\w+=,.@-]/g, "@");
  } catch {
    return "noname";
  }
}
function fmtObtainCredentialsError(targetAccountId, obtainResult) {
  const msg = [`Need to perform AWS calls for account ${targetAccountId}`];
  switch (obtainResult.source) {
    case "incorrectDefault":
      msg.push(`but the current credentials are for ${obtainResult.accountId}`);
      break;
    case "none":
      msg.push("but no credentials have been configured");
  }
  if (obtainResult.unusedPlugins.length > 0) {
    msg.push(`and none of these plugins found any: ${obtainResult.unusedPlugins.join(", ")}`);
  }
  return msg.join(", ");
}
function fmtObtainedCredentials(obtainResult) {
  switch (obtainResult.source) {
    case "correctDefault":
      return "current credentials";
    case "plugin":
      return `credentials returned by plugin '${obtainResult.pluginName}'`;
    case "incorrectDefault":
      const msg = [];
      msg.push(`current credentials (which are for account ${obtainResult.accountId}`);
      if (obtainResult.unusedPlugins.length > 0) {
        msg.push(`, and none of the following plugins provided credentials: ${obtainResult.unusedPlugins.join(", ")}`);
      }
      msg.push(")");
      return msg.join("");
  }
}
async function initContextProviderSdk(aws, options) {
  const account = options.account;
  const region = options.region;
  const creds = {
    assumeRoleArn: options.lookupRoleArn,
    assumeRoleExternalId: options.lookupRoleExternalId,
    assumeRoleAdditionalOptions: options.assumeRoleAdditionalOptions
  };
  return (await aws.forEnvironment(import_cx_api.EnvironmentUtils.make(account, region), 0 /* ForReading */, creds)).sdk;
}

// ../tmp-toolkit-helpers/src/api/aws-auth/sdk-logger.ts
var import_util13 = require("util");
var SdkToCliLogger = class {
  ioHelper;
  constructor(ioHelper) {
    this.ioHelper = ioHelper;
  }
  notify(level, ...content) {
    void this.ioHelper.notify(IO.CDK_SDK_I0100.msg((0, import_util13.format)("[SDK %s] %s", level, formatSdkLoggerContent(content)), {
      sdkLevel: level,
      content
    }));
  }
  trace(..._content) {
  }
  debug(..._content) {
  }
  /**
   * Info is called mostly (exclusively?) for successful API calls
   *
   * Payload:
   *
   * (Note the input contains entire CFN templates, for example)
   *
   * ```
   * {
   *   clientName: 'S3Client',
   *   commandName: 'GetBucketLocationCommand',
   *   input: {
   *     Bucket: '.....',
   *     ExpectedBucketOwner: undefined
   *   },
   *   output: { LocationConstraint: 'eu-central-1' },
   *   metadata: {
   *     httpStatusCode: 200,
   *     requestId: '....',
   *     extendedRequestId: '...',
   *     cfId: undefined,
   *     attempts: 1,
   *     totalRetryDelay: 0
   *   }
   * }
   * ```
   */
  info(...content) {
    this.notify("info", ...content);
  }
  warn(...content) {
    this.notify("warn", ...content);
  }
  /**
   * Error is called mostly (exclusively?) for failing API calls
   *
   * Payload (input would be the entire API call arguments).
   *
   * ```
   * {
   *   clientName: 'STSClient',
   *   commandName: 'GetCallerIdentityCommand',
   *   input: {},
   *   error: AggregateError [ECONNREFUSED]:
   *       at internalConnectMultiple (node:net:1121:18)
   *       at afterConnectMultiple (node:net:1688:7) {
   *     code: 'ECONNREFUSED',
   *     '$metadata': { attempts: 3, totalRetryDelay: 600 },
   *     [errors]: [ [Error], [Error] ]
   *   },
   *   metadata: { attempts: 3, totalRetryDelay: 600 }
   * }
   * ```
   */
  error(...content) {
    this.notify("error", ...content);
  }
};
function formatSdkLoggerContent(content) {
  if (content.length === 1) {
    const apiFmt = formatApiCall(content[0]);
    if (apiFmt) {
      return apiFmt;
    }
  }
  return content.map((x) => typeof x === "string" ? x : (0, import_util13.inspect)(x)).join("");
}
function formatApiCall(content) {
  if (!isSdkApiCallSuccess(content) && !isSdkApiCallError(content)) {
    return void 0;
  }
  const service = content.clientName.replace(/Client$/, "");
  const api = content.commandName.replace(/Command$/, "");
  const parts = [];
  if ((content.metadata?.attempts ?? 0) > 1) {
    parts.push(`[${content.metadata?.attempts} attempts, ${content.metadata?.totalRetryDelay}ms retry]`);
  }
  parts.push(`${service}.${api}(${JSON.stringify(content.input, replacerBufferWithInfo)})`);
  if (isSdkApiCallSuccess(content)) {
    parts.push("-> OK");
  } else {
    parts.push(`-> ${content.error}`);
  }
  return parts.join(" ");
}
function isSdkApiCallSuccess(x) {
  return x && typeof x === "object" && x.commandName && x.output;
}
function isSdkApiCallError(x) {
  return x && typeof x === "object" && x.commandName && x.error;
}

// ../tmp-toolkit-helpers/src/api/bootstrap/bootstrap-environment.ts
var path10 = __toESM(require("path"));

// ../tmp-toolkit-helpers/src/api/bootstrap/deploy-bootstrap.ts
var os3 = __toESM(require("os"));
var path9 = __toESM(require("path"));
var import_cloud_assembly_schema2 = require("@aws-cdk/cloud-assembly-schema");
var import_cx_api6 = require("@aws-cdk/cx-api");
var fs10 = __toESM(require("fs-extra"));

// ../tmp-toolkit-helpers/src/api/bootstrap/bootstrap-props.ts
var BUCKET_NAME_OUTPUT = "BucketName";
var REPOSITORY_NAME_OUTPUT = "ImageRepositoryName";
var BUCKET_DOMAIN_NAME_OUTPUT = "BucketDomainName";
var BOOTSTRAP_VERSION_OUTPUT = "BootstrapVersion";
var BOOTSTRAP_VERSION_RESOURCE = "CdkBootstrapVersion";
var BOOTSTRAP_VARIANT_PARAMETER = "BootstrapVariant";
var DEFAULT_BOOTSTRAP_VARIANT = "AWS CDK: Default Resources";

// ../tmp-toolkit-helpers/src/api/deployments/deployments.ts
var import_crypto = require("crypto");
var cdk_assets = __toESM(require("cdk-assets"));
var chalk8 = __toESM(require("chalk"));

// ../tmp-toolkit-helpers/src/api/deployments/asset-manifest-builder.ts
var cxschema = __toESM(require("@aws-cdk/cloud-assembly-schema"));
var import_cdk_assets = require("cdk-assets");
var AssetManifestBuilder = class {
  manifest = {
    version: cxschema.Manifest.version(),
    files: {},
    dockerImages: {}
  };
  addFileAsset(id, source, destination) {
    this.manifest.files[id] = {
      source,
      destinations: {
        current: destination
      }
    };
  }
  addDockerImageAsset(id, source, destination) {
    this.manifest.dockerImages[id] = {
      source,
      destinations: {
        current: destination
      }
    };
  }
  toManifest(directory) {
    return new import_cdk_assets.AssetManifest(directory, this.manifest);
  }
};

// ../tmp-toolkit-helpers/src/api/deployments/asset-publishing.ts
var import_cx_api2 = require("@aws-cdk/cx-api");
var import_cdk_assets2 = require("cdk-assets");
async function publishAssets(manifest, sdk, targetEnv, options, ioHelper) {
  if (targetEnv.account === void 0 || targetEnv.account === import_cx_api2.UNKNOWN_ACCOUNT || targetEnv.region === void 0 || targetEnv.account === import_cx_api2.UNKNOWN_REGION) {
    throw new ToolkitError(`Asset publishing requires resolved account and region, got ${JSON.stringify(targetEnv)}`);
  }
  const publisher = new import_cdk_assets2.AssetPublishing(manifest, {
    aws: new PublishingAws(sdk, targetEnv),
    progressListener: new PublishingProgressListener(ioHelper),
    throwOnError: false,
    publishInParallel: options.parallel ?? true,
    buildAssets: true,
    publishAssets: true,
    quiet: false
  });
  await publisher.publish({ allowCrossAccount: options.allowCrossAccount });
  if (publisher.hasFailures) {
    throw new ToolkitError("Failed to publish one or more assets. See the error messages above for more information.");
  }
}
var PublishingAws = class {
  constructor(aws, targetEnv) {
    this.aws = aws;
    this.targetEnv = targetEnv;
  }
  sdkCache = /* @__PURE__ */ new Map();
  async discoverPartition() {
    return await this.aws.baseCredentialsPartition(this.targetEnv, 1 /* ForWriting */) ?? "aws";
  }
  async discoverDefaultRegion() {
    return this.targetEnv.region;
  }
  async discoverCurrentAccount() {
    const account = await this.aws.defaultAccount();
    return account ?? {
      accountId: "<unknown account>",
      partition: "aws"
    };
  }
  async discoverTargetAccount(options) {
    return (await this.sdk(options)).currentAccount();
  }
  async s3Client(options) {
    return (await this.sdk(options)).s3();
  }
  async ecrClient(options) {
    return (await this.sdk(options)).ecr();
  }
  async secretsManagerClient(options) {
    return (await this.sdk(options)).secretsManager();
  }
  /**
   * Get an SDK appropriate for the given client options
   */
  async sdk(options) {
    const env = {
      ...this.targetEnv,
      region: options.region ?? this.targetEnv.region
      // Default: same region as the stack
    };
    const cacheKeyMap = {
      env,
      // region, name, account
      assumeRuleArn: options.assumeRoleArn,
      assumeRoleExternalId: options.assumeRoleExternalId,
      quiet: options.quiet
    };
    if (options.assumeRoleAdditionalOptions) {
      cacheKeyMap.assumeRoleAdditionalOptions = options.assumeRoleAdditionalOptions;
    }
    const cacheKey = JSON.stringify(cacheKeyMap);
    const maybeSdk = this.sdkCache.get(cacheKey);
    if (maybeSdk) {
      return maybeSdk;
    }
    const sdk = (await this.aws.forEnvironment(
      env,
      1 /* ForWriting */,
      {
        assumeRoleArn: options.assumeRoleArn,
        assumeRoleExternalId: options.assumeRoleExternalId,
        assumeRoleAdditionalOptions: options.assumeRoleAdditionalOptions
      },
      options.quiet
    )).sdk;
    this.sdkCache.set(cacheKey, sdk);
    return sdk;
  }
};
var EVENT_TO_MSG_MAKER = {
  build: IO.DEFAULT_TOOLKIT_DEBUG,
  cached: IO.DEFAULT_TOOLKIT_DEBUG,
  check: IO.DEFAULT_TOOLKIT_DEBUG,
  debug: IO.DEFAULT_TOOLKIT_DEBUG,
  fail: IO.DEFAULT_TOOLKIT_ERROR,
  found: IO.DEFAULT_TOOLKIT_DEBUG,
  start: IO.DEFAULT_TOOLKIT_INFO,
  success: IO.DEFAULT_TOOLKIT_INFO,
  upload: IO.DEFAULT_TOOLKIT_DEBUG,
  shell_open: IO.DEFAULT_TOOLKIT_DEBUG,
  shell_stderr: false,
  shell_stdout: false,
  shell_close: false
};
var BasePublishProgressListener = class {
  ioHelper;
  constructor(ioHelper) {
    this.ioHelper = ioHelper;
  }
  onPublishEvent(type, event) {
    const maker = EVENT_TO_MSG_MAKER[type];
    if (maker) {
      void this.ioHelper.notify(maker.msg(this.getMessage(type, event)));
    }
  }
};
var PublishingProgressListener = class extends BasePublishProgressListener {
  getMessage(type, event) {
    return `[${event.percentComplete}%] ${type}: ${event.message}`;
  }
};

// ../tmp-toolkit-helpers/src/api/deployments/cfn-api.ts
var cfn_api_exports = {};
__export(cfn_api_exports, {
  ParameterValues: () => ParameterValues,
  TemplateParameters: () => TemplateParameters,
  changeSetHasNoChanges: () => changeSetHasNoChanges,
  createChangeSet: () => createChangeSet,
  createDiffChangeSet: () => createDiffChangeSet,
  stabilizeStack: () => stabilizeStack,
  uploadStackTemplateAssets: () => uploadStackTemplateAssets,
  waitForChangeSet: () => waitForChangeSet,
  waitForStackDelete: () => waitForStackDelete,
  waitForStackDeploy: () => waitForStackDeploy
});
var import_util21 = require("util");
var cxapi = __toESM(require("@aws-cdk/cx-api"));
var import_cx_api4 = require("@aws-cdk/cx-api");
var import_client_cloudformation3 = require("@aws-sdk/client-cloudformation");
var import_cdk_assets3 = require("cdk-assets");

// ../tmp-toolkit-helpers/src/api/resource-metadata/resource-metadata.ts
var import_cloud_assembly_schema = require("@aws-cdk/cloud-assembly-schema");
function resourceMetadata(stack, logicalId) {
  const metadata = stack.manifest?.metadata;
  if (!metadata) {
    return void 0;
  }
  for (const path13 of Object.keys(metadata)) {
    const entry = metadata[path13].filter((e) => e.type === import_cloud_assembly_schema.ArtifactMetadataEntryType.LOGICAL_ID).find((e) => e.data === logicalId);
    if (entry) {
      return {
        entry,
        constructPath: simplifyConstructPath(path13, stack.stackName)
      };
    }
  }
  return void 0;
}
function simplifyConstructPath(path13, stackName) {
  path13 = path13.replace(/\/Resource$/, "");
  path13 = path13.replace(/^\//, "");
  if (stackName) {
    if (path13.startsWith(stackName + "/")) {
      path13 = path13.slice(stackName.length + 1);
    }
  }
  return path13;
}

// ../tmp-toolkit-helpers/src/api/cloudformation/evaluate-cloudformation-template.ts
var LazyListStackResources = class {
  constructor(sdk, stackName) {
    this.sdk = sdk;
    this.stackName = stackName;
  }
  stackResources;
  async listStackResources() {
    if (this.stackResources === void 0) {
      this.stackResources = this.sdk.cloudFormation().listStackResources({
        StackName: this.stackName
      });
    }
    return this.stackResources;
  }
};
var LookupExportError = class extends Error {
};
var LazyLookupExport = class {
  constructor(sdk) {
    this.sdk = sdk;
  }
  cachedExports = {};
  async lookupExport(name) {
    if (this.cachedExports[name]) {
      return this.cachedExports[name];
    }
    for await (const cfnExport of this.listExports()) {
      if (!cfnExport.Name) {
        continue;
      }
      this.cachedExports[cfnExport.Name] = cfnExport;
      if (cfnExport.Name === name) {
        return cfnExport;
      }
    }
    return void 0;
  }
  // TODO: Paginate
  async *listExports() {
    let nextToken = void 0;
    while (true) {
      const response = await this.sdk.cloudFormation().listExports({ NextToken: nextToken });
      for (const cfnExport of response.Exports ?? []) {
        yield cfnExport;
      }
      if (!response.NextToken) {
        return;
      }
      nextToken = response.NextToken;
    }
  }
};
var CfnEvaluationException = class extends Error {
};
var EvaluateCloudFormationTemplate = class _EvaluateCloudFormationTemplate {
  stackArtifact;
  stackName;
  template;
  context;
  account;
  region;
  partition;
  sdk;
  nestedStacks;
  stackResources;
  lookupExport;
  cachedUrlSuffix;
  constructor(props) {
    this.stackArtifact = props.stackArtifact;
    this.stackName = props.stackName ?? props.stackArtifact.stackName;
    this.template = props.template ?? props.stackArtifact.template;
    this.context = {
      "AWS::AccountId": props.account,
      "AWS::Region": props.region,
      "AWS::Partition": props.partition,
      ...props.parameters
    };
    this.account = props.account;
    this.region = props.region;
    this.partition = props.partition;
    this.sdk = props.sdk;
    this.nestedStacks = props.nestedStacks ?? {};
    this.stackResources = new LazyListStackResources(this.sdk, this.stackName);
    this.lookupExport = new LazyLookupExport(this.sdk);
  }
  // clones current EvaluateCloudFormationTemplate object, but updates the stack name
  async createNestedEvaluateCloudFormationTemplate(stackName, nestedTemplate, nestedStackParameters) {
    const evaluatedParams = await this.evaluateCfnExpression(nestedStackParameters);
    return new _EvaluateCloudFormationTemplate({
      stackArtifact: this.stackArtifact,
      stackName,
      template: nestedTemplate,
      parameters: evaluatedParams,
      account: this.account,
      region: this.region,
      partition: this.partition,
      sdk: this.sdk,
      nestedStacks: this.nestedStacks
    });
  }
  async establishResourcePhysicalName(logicalId, physicalNameInCfnTemplate) {
    if (physicalNameInCfnTemplate != null) {
      try {
        return await this.evaluateCfnExpression(physicalNameInCfnTemplate);
      } catch (e) {
        if (!(e instanceof CfnEvaluationException)) {
          throw e;
        }
      }
    }
    return this.findPhysicalNameFor(logicalId);
  }
  async findPhysicalNameFor(logicalId) {
    const stackResources = await this.stackResources.listStackResources();
    return stackResources.find((sr) => sr.LogicalResourceId === logicalId)?.PhysicalResourceId;
  }
  async findLogicalIdForPhysicalName(physicalName) {
    const stackResources = await this.stackResources.listStackResources();
    return stackResources.find((sr) => sr.PhysicalResourceId === physicalName)?.LogicalResourceId;
  }
  findReferencesTo(logicalId) {
    const ret = new Array();
    for (const [resourceLogicalId, resourceDef] of Object.entries(this.template?.Resources ?? {})) {
      if (logicalId !== resourceLogicalId && this.references(logicalId, resourceDef)) {
        ret.push({
          ...resourceDef,
          LogicalId: resourceLogicalId
        });
      }
    }
    return ret;
  }
  async evaluateCfnExpression(cfnExpression) {
    const self = this;
    class CfnIntrinsics {
      evaluateIntrinsic(intrinsic) {
        const intrinsicFunc = this[intrinsic.name];
        if (!intrinsicFunc) {
          throw new CfnEvaluationException(`CloudFormation function ${intrinsic.name} is not supported`);
        }
        const argsAsArray = Array.isArray(intrinsic.args) ? intrinsic.args : [intrinsic.args];
        return intrinsicFunc.apply(this, argsAsArray);
      }
      async "Fn::Join"(separator, args) {
        const evaluatedArgs = await self.evaluateCfnExpression(args);
        return evaluatedArgs.join(separator);
      }
      async "Fn::Split"(separator, args) {
        const evaluatedArgs = await self.evaluateCfnExpression(args);
        return evaluatedArgs.split(separator);
      }
      async "Fn::Select"(index, args) {
        const evaluatedArgs = await self.evaluateCfnExpression(args);
        return evaluatedArgs[index];
      }
      async Ref(logicalId) {
        const refTarget = await self.findRefTarget(logicalId);
        if (refTarget) {
          return refTarget;
        } else {
          throw new CfnEvaluationException(`Parameter or resource '${logicalId}' could not be found for evaluation`);
        }
      }
      async "Fn::GetAtt"(logicalId, attributeName) {
        const attrValue = await self.findGetAttTarget(logicalId, attributeName);
        if (attrValue) {
          return attrValue;
        } else {
          throw new CfnEvaluationException(
            `Attribute '${attributeName}' of resource '${logicalId}' could not be found for evaluation`
          );
        }
      }
      async "Fn::Sub"(template, explicitPlaceholders) {
        const placeholders = explicitPlaceholders ? await self.evaluateCfnExpression(explicitPlaceholders) : {};
        return asyncGlobalReplace(template, /\${([^}]*)}/g, (key) => {
          if (key in placeholders) {
            return placeholders[key];
          } else {
            const splitKey = key.split(".");
            return splitKey.length === 1 ? this.Ref(key) : this["Fn::GetAtt"](splitKey[0], splitKey.slice(1).join("."));
          }
        });
      }
      async "Fn::ImportValue"(name) {
        const exported = await self.lookupExport.lookupExport(name);
        if (!exported) {
          throw new CfnEvaluationException(`Export '${name}' could not be found for evaluation`);
        }
        if (!exported.Value) {
          throw new CfnEvaluationException(`Export '${name}' exists without a value`);
        }
        return exported.Value;
      }
    }
    if (cfnExpression == null) {
      return cfnExpression;
    }
    if (Array.isArray(cfnExpression)) {
      return Promise.all(cfnExpression.map((expr) => this.evaluateCfnExpression(expr)));
    }
    if (typeof cfnExpression === "object") {
      const intrinsic = this.parseIntrinsic(cfnExpression);
      if (intrinsic) {
        return new CfnIntrinsics().evaluateIntrinsic(intrinsic);
      } else {
        const ret = {};
        for (const [key, val] of Object.entries(cfnExpression)) {
          ret[key] = await this.evaluateCfnExpression(val);
        }
        return ret;
      }
    }
    return cfnExpression;
  }
  getResourceProperty(logicalId, propertyName) {
    return this.template.Resources?.[logicalId]?.Properties?.[propertyName];
  }
  metadataFor(logicalId) {
    return resourceMetadata(this.stackArtifact, logicalId);
  }
  references(logicalId, templateElement) {
    if (typeof templateElement === "string") {
      return logicalId === templateElement;
    }
    if (templateElement == null) {
      return false;
    }
    if (Array.isArray(templateElement)) {
      return templateElement.some((el) => this.references(logicalId, el));
    }
    if (typeof templateElement === "object") {
      return Object.values(templateElement).some((el) => this.references(logicalId, el));
    }
    return false;
  }
  parseIntrinsic(x) {
    const keys = Object.keys(x);
    if (keys.length === 1 && (keys[0].startsWith("Fn::") || keys[0] === "Ref")) {
      return {
        name: keys[0],
        args: x[keys[0]]
      };
    }
    return void 0;
  }
  async findRefTarget(logicalId) {
    if (logicalId === "AWS::URLSuffix") {
      if (!this.cachedUrlSuffix) {
        this.cachedUrlSuffix = await this.sdk.getUrlSuffix(this.region);
      }
      return this.cachedUrlSuffix;
    }
    const parameterTarget = this.context[logicalId];
    if (parameterTarget) {
      return parameterTarget;
    }
    const defaultParameterValue = this.template.Parameters?.[logicalId]?.Default;
    if (defaultParameterValue) {
      return defaultParameterValue;
    }
    return this.findGetAttTarget(logicalId);
  }
  async findGetAttTarget(logicalId, attribute) {
    if (logicalId === "Outputs" && attribute) {
      return this.evaluateCfnExpression(this.template.Outputs[attribute]?.Value);
    }
    const stackResources = await this.stackResources.listStackResources();
    const foundResource = stackResources.find((sr) => sr.LogicalResourceId === logicalId);
    if (!foundResource) {
      return void 0;
    }
    if (foundResource.ResourceType == "AWS::CloudFormation::Stack" && attribute?.startsWith("Outputs.")) {
      const dependantStack = this.findNestedStack(logicalId, this.nestedStacks);
      if (!dependantStack || !dependantStack.physicalName) {
        return void 0;
      }
      const evaluateCfnTemplate = await this.createNestedEvaluateCloudFormationTemplate(
        dependantStack.physicalName,
        dependantStack.generatedTemplate,
        dependantStack.generatedTemplate.Parameters
      );
      return evaluateCfnTemplate.evaluateCfnExpression({
        "Fn::GetAtt": attribute.split(/\.(.*)/s)
      });
    }
    return this.formatResourceAttribute(foundResource, attribute);
  }
  findNestedStack(logicalId, nestedStacks) {
    for (const nestedStackLogicalId of Object.keys(nestedStacks)) {
      if (nestedStackLogicalId === logicalId) {
        return nestedStacks[nestedStackLogicalId];
      }
      const checkInNestedChildStacks = this.findNestedStack(
        logicalId,
        nestedStacks[nestedStackLogicalId].nestedStackTemplates
      );
      if (checkInNestedChildStacks) return checkInNestedChildStacks;
    }
    return void 0;
  }
  formatResourceAttribute(resource, attribute) {
    const physicalId = resource.PhysicalResourceId;
    if (!attribute) {
      return physicalId;
    }
    const resourceTypeFormats = RESOURCE_TYPE_ATTRIBUTES_FORMATS[resource.ResourceType];
    if (!resourceTypeFormats) {
      throw new CfnEvaluationException(
        `We don't support attributes of the '${resource.ResourceType}' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose`
      );
    }
    const attributeFmtFunc = resourceTypeFormats[attribute];
    if (!attributeFmtFunc) {
      throw new CfnEvaluationException(
        `We don't support the '${attribute}' attribute of the '${resource.ResourceType}' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose`
      );
    }
    const service = this.getServiceOfResource(resource);
    const resourceTypeArnPart = this.getResourceTypeArnPartOfResource(resource);
    return attributeFmtFunc({
      partition: this.partition,
      service,
      region: this.region,
      account: this.account,
      resourceType: resourceTypeArnPart,
      resourceName: physicalId
    });
  }
  getServiceOfResource(resource) {
    return resource.ResourceType.split("::")[1].toLowerCase();
  }
  getResourceTypeArnPartOfResource(resource) {
    const resourceType = resource.ResourceType;
    const specialCaseResourceType = RESOURCE_TYPE_SPECIAL_NAMES[resourceType]?.resourceType;
    return specialCaseResourceType ? specialCaseResourceType : (
      // this is the default case
      resourceType.split("::")[2].toLowerCase()
    );
  }
};
var RESOURCE_TYPE_SPECIAL_NAMES = {
  "AWS::Events::EventBus": {
    resourceType: "event-bus"
  }
};
var RESOURCE_TYPE_ATTRIBUTES_FORMATS = {
  "AWS::IAM::Role": { Arn: iamArnFmt },
  "AWS::IAM::User": { Arn: iamArnFmt },
  "AWS::IAM::Group": { Arn: iamArnFmt },
  "AWS::S3::Bucket": { Arn: s3ArnFmt },
  "AWS::Lambda::Function": { Arn: stdColonResourceArnFmt },
  "AWS::Events::EventBus": {
    Arn: stdSlashResourceArnFmt,
    // the name attribute of the EventBus is the same as the Ref
    Name: (parts) => parts.resourceName
  },
  "AWS::DynamoDB::Table": { Arn: stdSlashResourceArnFmt },
  "AWS::AppSync::GraphQLApi": { ApiId: appsyncGraphQlApiApiIdFmt },
  "AWS::AppSync::FunctionConfiguration": {
    FunctionId: appsyncGraphQlFunctionIDFmt
  },
  "AWS::AppSync::DataSource": { Name: appsyncGraphQlDataSourceNameFmt },
  "AWS::KMS::Key": { Arn: stdSlashResourceArnFmt }
};
function iamArnFmt(parts) {
  return `arn:${parts.partition}:${parts.service}::${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function s3ArnFmt(parts) {
  return `arn:${parts.partition}:${parts.service}:::${parts.resourceName}`;
}
function stdColonResourceArnFmt(parts) {
  return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}:${parts.resourceName}`;
}
function stdSlashResourceArnFmt(parts) {
  return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function appsyncGraphQlApiApiIdFmt(parts) {
  return parts.resourceName.split("/")[1];
}
function appsyncGraphQlFunctionIDFmt(parts) {
  return parts.resourceName.split("/")[3];
}
function appsyncGraphQlDataSourceNameFmt(parts) {
  return parts.resourceName.split("/")[3];
}
async function asyncGlobalReplace(str, regex, cb) {
  if (!regex.global) {
    throw new ToolkitError("Regex must be created with /g flag");
  }
  const ret = new Array();
  let start = 0;
  while (true) {
    const match = regex.exec(str);
    if (!match) {
      break;
    }
    ret.push(str.substring(start, match.index));
    ret.push(await cb(match[1]));
    start = regex.lastIndex;
  }
  ret.push(str.slice(start));
  return ret.join("");
}

// ../tmp-toolkit-helpers/src/api/cloudformation/template-body-parameter.ts
var fs6 = __toESM(require("node:fs/promises"));
var path4 = __toESM(require("node:path"));
var util5 = __toESM(require("node:util"));
var import_cx_api3 = require("@aws-cdk/cx-api");
var import_client_s32 = require("@aws-sdk/client-s3");
var import_middleware_endpoint2 = require("@smithy/middleware-endpoint");
var chalk3 = __toESM(require("chalk"));
var LARGE_TEMPLATE_SIZE_KB = 50;
async function makeBodyParameter(ioHelper, stack, resolvedEnvironment, assetManifest, resources, overrideTemplate) {
  if (stack.stackTemplateAssetObjectUrl && !overrideTemplate) {
    return {
      TemplateURL: await restUrlFromManifest(stack.stackTemplateAssetObjectUrl, resolvedEnvironment)
    };
  }
  const templateJson = toYAML(overrideTemplate ?? stack.template);
  if (templateJson.length <= LARGE_TEMPLATE_SIZE_KB * 1024) {
    return { TemplateBody: templateJson };
  }
  const toolkitInfo = await resources.lookupToolkit();
  if (!toolkitInfo.found) {
    await ioHelper.notify(
      IO.DEFAULT_TOOLKIT_ERROR.msg(util5.format(
        `The template for stack "${stack.displayName}" is ${Math.round(templateJson.length / 1024)}KiB. Templates larger than ${LARGE_TEMPLATE_SIZE_KB}KiB must be uploaded to S3.
Run the following command in order to setup an S3 bucket in this environment, and then re-deploy:

`,
        chalk3.blue(`	$ cdk bootstrap ${resolvedEnvironment.name}
`)
      ))
    );
    throw new ToolkitError('Template too large to deploy ("cdk bootstrap" is required)');
  }
  const templateHash = contentHash(templateJson);
  const key = `cdk/${stack.id}/${templateHash}.yml`;
  let templateFile = stack.templateFile;
  if (overrideTemplate) {
    templateFile = `${stack.templateFile}-${templateHash}.yaml`;
    const templateFilePath = path4.join(stack.assembly.directory, templateFile);
    await fs6.writeFile(templateFilePath, templateJson, { encoding: "utf-8" });
  }
  assetManifest.addFileAsset(
    templateHash,
    {
      path: templateFile
    },
    {
      bucketName: toolkitInfo.bucketName,
      objectKey: key
    }
  );
  const templateURL = `${toolkitInfo.bucketUrl}/${key}`;
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Storing template in S3 at: ${templateURL}`));
  return { TemplateURL: templateURL };
}
async function restUrlFromManifest(url, environment) {
  const doNotUseMarker = "**DONOTUSE**";
  const region = environment.region;
  url = import_cx_api3.EnvironmentPlaceholders.replace(url, {
    accountId: environment.account,
    region,
    partition: doNotUseMarker
  });
  if (url.indexOf(doNotUseMarker) > -1) {
    throw new ToolkitError("Cannot use '${AWS::Partition}' in the 'stackTemplateAssetObjectUrl' field");
  }
  const s3Url = url.match(/s3:\/\/([^/]+)\/(.*)$/);
  if (!s3Url) {
    return url;
  }
  const bucketName = s3Url[1];
  const objectKey = s3Url[2];
  const s3 = new import_client_s32.S3Client({ region });
  const endpoint = await (0, import_middleware_endpoint2.getEndpointFromInstructions)({}, import_client_s32.HeadObjectCommand, {
    ...s3.config
  });
  endpoint.url.hostname;
  return `${endpoint.url.origin}/${bucketName}/${objectKey}`;
}

// ../tmp-toolkit-helpers/src/api/cloudformation/nested-stack-helpers.ts
var path5 = __toESM(require("path"));
var fs7 = __toESM(require("fs-extra"));

// ../tmp-toolkit-helpers/src/api/stack-events/stack-activity-monitor.ts
var util7 = __toESM(require("util"));
var uuid2 = __toESM(require("uuid"));

// ../tmp-toolkit-helpers/src/api/stack-events/stack-event-poller.ts
var StackEventPoller = class _StackEventPoller {
  constructor(cfn, props) {
    this.cfn = cfn;
    this.props = props;
  }
  events = [];
  complete = false;
  eventIds = /* @__PURE__ */ new Set();
  nestedStackPollers = {};
  /**
   * From all accumulated events, return only the errors
   */
  get resourceErrors() {
    return this.events.filter((e) => e.event.ResourceStatus?.endsWith("_FAILED") && !e.isStackEvent);
  }
  /**
   * Poll for new stack events
   *
   * Will not return events older than events indicated by the constructor filters.
   *
   * Recurses into nested stacks, and returns events old-to-new.
   */
  async poll() {
    const events = await this.doPoll();
    for (const [logicalId, poller] of Object.entries(this.nestedStackPollers)) {
      events.push(...await poller.poll());
      if (poller.complete) {
        delete this.nestedStackPollers[logicalId];
      }
    }
    events.sort((a, b) => a.event.Timestamp.valueOf() - b.event.Timestamp.valueOf());
    this.events.push(...events);
    return events;
  }
  async doPoll() {
    const events = [];
    try {
      let nextToken;
      let finished = false;
      while (!finished) {
        const page = await this.cfn.describeStackEvents({ StackName: this.props.stackName, NextToken: nextToken });
        for (const event of page?.StackEvents ?? []) {
          if (this.props.startTime !== void 0 && event.Timestamp.valueOf() < this.props.startTime) {
            return events;
          }
          if (this.eventIds.has(event.EventId)) {
            return events;
          }
          this.eventIds.add(event.EventId);
          const isParentStackEvent = event.PhysicalResourceId === event.StackId;
          if (isParentStackEvent && this.props.stackStatuses?.includes(event.ResourceStatus ?? "")) {
            return events;
          }
          const resEvent = {
            event,
            parentStackLogicalIds: this.props.parentStackLogicalIds ?? [],
            isStackEvent: isParentStackEvent
          };
          events.push(resEvent);
          if (!isParentStackEvent && event.ResourceType === "AWS::CloudFormation::Stack" && isStackBeginOperationState(event.ResourceStatus)) {
            this.trackNestedStack(event, [...this.props.parentStackLogicalIds ?? [], event.LogicalResourceId ?? ""]);
          }
          if (isParentStackEvent && isStackTerminalState(event.ResourceStatus)) {
            this.complete = true;
          }
        }
        nextToken = page?.NextToken;
        if (nextToken === void 0) {
          finished = true;
        }
      }
    } catch (e) {
      if (!(e.name === "ValidationError" && formatErrorMessage(e) === `Stack [${this.props.stackName}] does not exist`)) {
        throw e;
      }
    }
    return events;
  }
  /**
   * On the CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, DELETE_IN_PROGRESS event of a nested stack, poll the nested stack updates
   */
  trackNestedStack(event, parentStackLogicalIds) {
    const logicalId = event.LogicalResourceId;
    const physicalResourceId = event.PhysicalResourceId;
    if (!logicalId || !physicalResourceId) {
      return;
    }
    if (!this.nestedStackPollers[logicalId]) {
      this.nestedStackPollers[logicalId] = new _StackEventPoller(this.cfn, {
        stackName: physicalResourceId,
        parentStackLogicalIds,
        startTime: event.Timestamp.valueOf()
      });
    }
  }
};
function isStackBeginOperationState(state) {
  return [
    "CREATE_IN_PROGRESS",
    "UPDATE_IN_PROGRESS",
    "DELETE_IN_PROGRESS",
    "UPDATE_ROLLBACK_IN_PROGRESS",
    "ROLLBACK_IN_PROGRESS"
  ].includes(state ?? "");
}
function isStackTerminalState(state) {
  return !(state ?? "").endsWith("_IN_PROGRESS");
}

// ../tmp-toolkit-helpers/src/api/stack-events/stack-progress-monitor.ts
var util6 = __toESM(require("util"));
var StackProgressMonitor = class {
  /**
   * Previous completion state observed by logical ID
   *
   * We use this to detect that if we see a DELETE_COMPLETE after a
   * CREATE_COMPLETE, it's actually a rollback and we should DECREASE
   * resourcesDone instead of increase it
   */
  resourcesPrevCompleteState = {};
  /**
   * Count of resources that have reported a _COMPLETE status
   */
  resourcesDone = 0;
  /**
   * How many digits we need to represent the total count (for lining up the status reporting)
   */
  resourceDigits = 0;
  /**
   * Number of expected resources in the monitor.
   */
  resourcesTotal;
  constructor(resourcesTotal) {
    this.resourcesTotal = resourcesTotal ? resourcesTotal + 1 : void 0;
    this.resourceDigits = this.resourcesTotal ? Math.ceil(Math.log10(this.resourcesTotal)) : 0;
  }
  /**
   * Report the stack progress
   */
  get progress() {
    return {
      total: this.total,
      completed: this.completed,
      formatted: this.formatted
    };
  }
  /**
   * The total number of progress monitored resources.
   */
  get total() {
    return this.resourcesTotal;
  }
  /**
   * The number of completed resources.
   */
  get completed() {
    return this.resourcesDone;
  }
  /**
   * Report the current progress as a [34/42] string, or just [34] if the total is unknown
   */
  get formatted() {
    if (this.resourcesTotal == null) {
      return padLeft(3, util6.format("%s", this.resourcesDone));
    }
    return util6.format(
      "%s/%s",
      padLeft(this.resourceDigits, this.resourcesDone.toString()),
      padLeft(this.resourceDigits, this.resourcesTotal.toString())
    );
  }
  /**
   * Process as stack event and update the progress state.
   */
  process(event) {
    const status = event.ResourceStatus;
    if (!status || !event.LogicalResourceId) {
      return;
    }
    if (status.endsWith("_COMPLETE_CLEANUP_IN_PROGRESS")) {
      this.resourcesDone++;
    }
    if (status.endsWith("_COMPLETE")) {
      const prevState = this.resourcesPrevCompleteState[event.LogicalResourceId];
      if (!prevState) {
        this.resourcesDone++;
      } else {
        this.resourcesDone--;
        if (this.resourcesDone < 0) {
          this.resourcesDone = 0;
        }
      }
      this.resourcesPrevCompleteState[event.LogicalResourceId] = status;
    }
  }
};

// ../tmp-toolkit-helpers/src/api/stack-events/stack-activity-monitor.ts
var StackActivityMonitor = class {
  /**
   * The poller used to read stack events
   */
  poller;
  /**
   * Fetch new activity every 1 second
   * Printers can decide to update a view less frequently if desired
   */
  pollingInterval;
  errors = [];
  monitorId;
  progressMonitor;
  /**
   * Current tick timer
   */
  tickTimer;
  /**
   * Set to the activity of reading the current events
   */
  readPromise;
  ioHelper;
  stackName;
  stack;
  constructor({
    cfn,
    ioHelper,
    stack,
    stackName,
    resourcesTotal,
    changeSetCreationTime,
    pollingInterval = 2e3
  }) {
    this.ioHelper = ioHelper;
    this.stack = stack;
    this.stackName = stackName;
    this.progressMonitor = new StackProgressMonitor(resourcesTotal);
    this.pollingInterval = pollingInterval;
    this.poller = new StackEventPoller(cfn, {
      stackName,
      startTime: changeSetCreationTime?.getTime() ?? Date.now()
    });
  }
  async start() {
    this.monitorId = uuid2.v4();
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5501.msg(`Deploying ${this.stackName}`, {
      deployment: this.monitorId,
      stack: this.stack,
      stackName: this.stackName,
      resourcesTotal: this.progressMonitor.total
    }));
    this.scheduleNextTick();
    return this;
  }
  async stop() {
    const oldMonitorId = this.monitorId;
    this.monitorId = void 0;
    if (this.tickTimer) {
      clearTimeout(this.tickTimer);
    }
    await this.finalPollToEnd(oldMonitorId);
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5503.msg(`Completed ${this.stackName}`, {
      deployment: oldMonitorId,
      stack: this.stack,
      stackName: this.stackName,
      resourcesTotal: this.progressMonitor.total
    }));
  }
  scheduleNextTick() {
    if (!this.monitorId) {
      return;
    }
    this.tickTimer = setTimeout(() => void this.tick(), this.pollingInterval);
  }
  async tick() {
    if (!this.monitorId) {
      return;
    }
    try {
      this.readPromise = this.readNewEvents(this.monitorId);
      await this.readPromise;
      this.readPromise = void 0;
      if (!this.monitorId) {
        return;
      }
    } catch (e) {
      await this.ioHelper.notify(IO.CDK_TOOLKIT_E5500.msg(
        util7.format("Error occurred while monitoring stack: %s", e),
        { error: e }
      ));
    }
    this.scheduleNextTick();
  }
  findMetadataFor(logicalId) {
    const metadata = this.stack.manifest?.metadata;
    if (!logicalId || !metadata) {
      return void 0;
    }
    return resourceMetadata(this.stack, logicalId);
  }
  /**
   * Reads all new events from the stack history
   *
   * The events are returned in reverse chronological order; we continue to the next page if we
   * see a next page and the last event in the page is new to us (and within the time window).
   * haven't seen the final event
   */
  async readNewEvents(monitorId) {
    const pollEvents = await this.poller.poll();
    for (const resourceEvent of pollEvents) {
      this.progressMonitor.process(resourceEvent.event);
      const activity = {
        deployment: monitorId,
        event: resourceEvent.event,
        metadata: this.findMetadataFor(resourceEvent.event.LogicalResourceId),
        progress: this.progressMonitor.progress
      };
      this.checkForErrors(activity);
      await this.ioHelper.notify(IO.CDK_TOOLKIT_I5502.msg(this.formatActivity(activity, true), activity));
    }
  }
  /**
   * Perform a final poll to the end and flush out all events to the printer
   *
   * Finish any poll currently in progress, then do a final one until we've
   * reached the last page.
   */
  async finalPollToEnd(monitorId) {
    if (this.readPromise) {
      await this.readPromise;
    }
    await this.readNewEvents(monitorId);
  }
  /**
   * Formats a stack activity into a basic string
   */
  formatActivity(activity, progress) {
    const event = activity.event;
    const metadata = activity.metadata;
    const resourceName = metadata ? metadata.constructPath : event.LogicalResourceId || "";
    const logicalId = resourceName !== event.LogicalResourceId ? `(${event.LogicalResourceId}) ` : "";
    return util7.format(
      "%s | %s%s | %s | %s | %s %s%s%s",
      event.StackName,
      progress !== false ? `${activity.progress.formatted} | ` : "",
      new Date(event.Timestamp).toLocaleTimeString(),
      event.ResourceStatus || "",
      event.ResourceType,
      resourceName,
      logicalId,
      event.ResourceStatusReason ? event.ResourceStatusReason : "",
      metadata?.entry.trace ? `
	${metadata.entry.trace.join("\n	\\_ ")}` : ""
    );
  }
  checkForErrors(activity) {
    if (stackEventHasErrorMessage(activity.event.ResourceStatus ?? "")) {
      const isCancelled = (activity.event.ResourceStatusReason ?? "").indexOf("cancelled") > -1;
      if (!isCancelled && activity.event.StackName !== activity.event.LogicalResourceId) {
        this.errors.push(activity.event.ResourceStatusReason ?? "");
      }
    }
  }
};

// ../tmp-toolkit-helpers/src/api/stack-events/stack-status.ts
var import_client_cloudformation2 = require("@aws-sdk/client-cloudformation");
var StackStatus = class _StackStatus2 {
  constructor(name, reason) {
    this.name = name;
    this.reason = reason;
  }
  static fromStackDescription(description) {
    return new _StackStatus2(description.StackStatus, description.StackStatusReason);
  }
  get isCreationFailure() {
    return this.name === import_client_cloudformation2.StackStatus.ROLLBACK_COMPLETE || this.name === import_client_cloudformation2.StackStatus.ROLLBACK_FAILED;
  }
  get isDeleted() {
    return this.name.startsWith("DELETE_");
  }
  get isFailure() {
    return this.name.endsWith("FAILED");
  }
  get isInProgress() {
    return this.name.endsWith("_IN_PROGRESS") && !this.isReviewInProgress;
  }
  get isReviewInProgress() {
    return this.name === import_client_cloudformation2.StackStatus.REVIEW_IN_PROGRESS;
  }
  get isNotFound() {
    return this.name === "NOT_FOUND";
  }
  get isDeploySuccess() {
    return !this.isNotFound && (this.name === import_client_cloudformation2.StackStatus.CREATE_COMPLETE || this.name === import_client_cloudformation2.StackStatus.UPDATE_COMPLETE || this.name === import_client_cloudformation2.StackStatus.IMPORT_COMPLETE);
  }
  get isRollbackSuccess() {
    return this.name === import_client_cloudformation2.StackStatus.ROLLBACK_COMPLETE || this.name === import_client_cloudformation2.StackStatus.UPDATE_ROLLBACK_COMPLETE;
  }
  /**
   * Whether the stack is in a paused state due to `--no-rollback`.
   *
   * The possible actions here are retrying a new `--no-rollback` deployment, or initiating a rollback.
   */
  get rollbackChoice() {
    switch (this.name) {
      case import_client_cloudformation2.StackStatus.CREATE_FAILED:
      case import_client_cloudformation2.StackStatus.UPDATE_FAILED:
        return 0 /* START_ROLLBACK */;
      case import_client_cloudformation2.StackStatus.UPDATE_ROLLBACK_FAILED:
        return 1 /* CONTINUE_UPDATE_ROLLBACK */;
      case import_client_cloudformation2.StackStatus.ROLLBACK_FAILED:
        return 2 /* ROLLBACK_FAILED */;
      default:
        return 3 /* NONE */;
    }
  }
  get isRollbackable() {
    return [0 /* START_ROLLBACK */, 1 /* CONTINUE_UPDATE_ROLLBACK */].includes(this.rollbackChoice);
  }
  toString() {
    return this.name + (this.reason ? ` (${this.reason})` : "");
  }
};
var RollbackChoice = /* @__PURE__ */ ((RollbackChoice2) => {
  RollbackChoice2[RollbackChoice2["START_ROLLBACK"] = 0] = "START_ROLLBACK";
  RollbackChoice2[RollbackChoice2["CONTINUE_UPDATE_ROLLBACK"] = 1] = "CONTINUE_UPDATE_ROLLBACK";
  RollbackChoice2[RollbackChoice2["ROLLBACK_FAILED"] = 2] = "ROLLBACK_FAILED";
  RollbackChoice2[RollbackChoice2["NONE"] = 3] = "NONE";
  return RollbackChoice2;
})(RollbackChoice || {});

// ../tmp-toolkit-helpers/src/api/cloudformation/stack-helpers.ts
var CloudFormationStack = class _CloudFormationStack {
  constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
    this.cfn = cfn;
    this.stackName = stackName;
    this.stack = stack;
    this.retrieveProcessedTemplate = retrieveProcessedTemplate;
  }
  static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
    try {
      const response = await cfn.describeStacks({ StackName: stackName });
      return new _CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
    } catch (e) {
      if (e.name === "ValidationError" && formatErrorMessage(e) === `Stack with id ${stackName} does not exist`) {
        return new _CloudFormationStack(cfn, stackName, void 0);
      }
      throw e;
    }
  }
  /**
   * Return a copy of the given stack that does not exist
   *
   * It's a little silly that it needs arguments to do that, but there we go.
   */
  static doesNotExist(cfn, stackName) {
    return new _CloudFormationStack(cfn, stackName);
  }
  /**
   * From static information (for testing)
   */
  static fromStaticInformation(cfn, stackName, stack) {
    return new _CloudFormationStack(cfn, stackName, stack);
  }
  _template;
  /**
   * Retrieve the stack's deployed template
   *
   * Cached, so will only be retrieved once. Will return an empty
   * structure if the stack does not exist.
   */
  async template() {
    if (!this.exists) {
      return {};
    }
    if (this._template === void 0) {
      const response = await this.cfn.getTemplate({
        StackName: this.stackName,
        TemplateStage: this.retrieveProcessedTemplate ? "Processed" : "Original"
      });
      this._template = response.TemplateBody && deserializeStructure(response.TemplateBody) || {};
    }
    return this._template;
  }
  /**
   * Whether the stack exists
   */
  get exists() {
    return this.stack !== void 0;
  }
  /**
   * The stack's ID (which is the same as its ARN)
   *
   * Throws if the stack doesn't exist.
   */
  get stackId() {
    this.assertExists();
    return this.stack.StackId;
  }
  /**
   * The stack's current outputs
   *
   * Empty object if the stack doesn't exist
   */
  get outputs() {
    if (!this.exists) {
      return {};
    }
    const result2 = {};
    (this.stack.Outputs || []).forEach((output) => {
      result2[output.OutputKey] = output.OutputValue;
    });
    return result2;
  }
  /**
   * The stack's status
   *
   * Special status NOT_FOUND if the stack does not exist.
   */
  get stackStatus() {
    if (!this.exists) {
      return new StackStatus("NOT_FOUND", "Stack not found during lookup");
    }
    return StackStatus.fromStackDescription(this.stack);
  }
  /**
   * The stack's current tags
   *
   * Empty list if the stack does not exist
   */
  get tags() {
    return this.stack?.Tags || [];
  }
  /**
   * SNS Topic ARNs that will receive stack events.
   *
   * Empty list if the stack does not exist
   */
  get notificationArns() {
    return this.stack?.NotificationARNs ?? [];
  }
  /**
   * Return the names of all current parameters to the stack
   *
   * Empty list if the stack does not exist.
   */
  get parameterNames() {
    return Object.keys(this.parameters);
  }
  /**
   * Return the names and values of all current parameters to the stack
   *
   * Empty object if the stack does not exist.
   */
  get parameters() {
    if (!this.exists) {
      return {};
    }
    const ret = {};
    for (const param of this.stack.Parameters ?? []) {
      ret[param.ParameterKey] = param.ResolvedValue ?? param.ParameterValue;
    }
    return ret;
  }
  /**
   * Return the termination protection of the stack
   */
  get terminationProtection() {
    return this.stack?.EnableTerminationProtection;
  }
  assertExists() {
    if (!this.exists) {
      throw new ToolkitError(`No stack named '${this.stackName}'`);
    }
  }
};

// ../tmp-toolkit-helpers/src/api/cloudformation/nested-stack-helpers.ts
async function loadCurrentTemplateWithNestedStacks(rootStackArtifact, sdk, retrieveProcessedTemplate = false) {
  const deployedRootTemplate = await loadCurrentTemplate(rootStackArtifact, sdk, retrieveProcessedTemplate);
  const nestedStacks = await loadNestedStacks(rootStackArtifact, sdk, {
    generatedTemplate: rootStackArtifact.template,
    deployedTemplate: deployedRootTemplate,
    deployedStackName: rootStackArtifact.stackName
  });
  return {
    deployedRootTemplate,
    nestedStacks
  };
}
async function loadCurrentTemplate(stackArtifact, sdk, retrieveProcessedTemplate = false) {
  return loadCurrentStackTemplate(stackArtifact.stackName, sdk, retrieveProcessedTemplate);
}
async function loadCurrentStackTemplate(stackName, sdk, retrieveProcessedTemplate = false) {
  const cfn = sdk.cloudFormation();
  const stack = await CloudFormationStack.lookup(cfn, stackName, retrieveProcessedTemplate);
  return stack.template();
}
async function loadNestedStacks(rootStackArtifact, sdk, parentTemplates) {
  const listStackResources = parentTemplates.deployedStackName ? new LazyListStackResources(sdk, parentTemplates.deployedStackName) : void 0;
  const nestedStacks = {};
  for (const [nestedStackLogicalId, generatedNestedStackResource] of Object.entries(
    parentTemplates.generatedTemplate.Resources ?? {}
  )) {
    if (!isCdkManagedNestedStack(generatedNestedStackResource)) {
      continue;
    }
    const assetPath = generatedNestedStackResource.Metadata["aws:asset:path"];
    const nestedStackTemplates = await getNestedStackTemplates(
      rootStackArtifact,
      assetPath,
      nestedStackLogicalId,
      listStackResources,
      sdk
    );
    nestedStacks[nestedStackLogicalId] = {
      deployedTemplate: nestedStackTemplates.deployedTemplate,
      generatedTemplate: nestedStackTemplates.generatedTemplate,
      physicalName: nestedStackTemplates.deployedStackName,
      nestedStackTemplates: await loadNestedStacks(rootStackArtifact, sdk, nestedStackTemplates)
    };
  }
  return nestedStacks;
}
async function getNestedStackTemplates(rootStackArtifact, nestedTemplateAssetPath, nestedStackLogicalId, listStackResources, sdk) {
  const nestedTemplatePath = path5.join(rootStackArtifact.assembly.directory, nestedTemplateAssetPath);
  const nestedStackArn = await getNestedStackArn(nestedStackLogicalId, listStackResources);
  const deployedStackName = nestedStackArn?.slice(nestedStackArn.indexOf("/") + 1, nestedStackArn.lastIndexOf("/"));
  return {
    generatedTemplate: JSON.parse(fs7.readFileSync(nestedTemplatePath, "utf-8")),
    deployedTemplate: deployedStackName ? await loadCurrentStackTemplate(deployedStackName, sdk) : {},
    deployedStackName
  };
}
async function getNestedStackArn(nestedStackLogicalId, listStackResources) {
  try {
    const stackResources = await listStackResources?.listStackResources();
    return stackResources?.find((sr) => sr.LogicalResourceId === nestedStackLogicalId)?.PhysicalResourceId;
  } catch (e) {
    if (formatErrorMessage(e).startsWith("Stack with id ") && formatErrorMessage(e).endsWith(" does not exist")) {
      return;
    }
    throw e;
  }
}
function isCdkManagedNestedStack(stackResource) {
  return stackResource.Type === "AWS::CloudFormation::Stack" && stackResource.Metadata && stackResource.Metadata["aws:asset:path"];
}

// ../tmp-toolkit-helpers/src/api/deployments/cfn-api.ts
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
  const response = await cfn.describeChangeSet({
    StackName: stackName,
    ChangeSetName: changeSetName
  });
  while (fetchAll && response.NextToken != null) {
    const nextPage = await cfn.describeChangeSet({
      StackName: stackName,
      ChangeSetName: response.ChangeSetId ?? changeSetName,
      NextToken: response.NextToken
    });
    if (nextPage.Changes != null) {
      response.Changes = response.Changes != null ? response.Changes.concat(nextPage.Changes) : nextPage.Changes;
    }
    response.NextToken = nextPage.NextToken;
  }
  return response;
}
async function waitFor(valueProvider, timeout = 5e3) {
  while (true) {
    const result2 = await valueProvider();
    if (result2 === null) {
      return void 0;
    } else if (result2 !== void 0) {
      return result2;
    }
    await new Promise((cb) => setTimeout(cb, timeout));
  }
}
async function waitForChangeSet(cfn, ioHelper, stackName, changeSetName, { fetchAll }) {
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Waiting for changeset %s on stack %s to finish creating...", changeSetName, stackName)));
  const ret = await waitFor(async () => {
    const description = await describeChangeSet(cfn, stackName, changeSetName, {
      fetchAll
    });
    if (description.Status === "CREATE_PENDING" || description.Status === "CREATE_IN_PROGRESS") {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Changeset %s on stack %s is still creating", changeSetName, stackName)));
      return void 0;
    }
    if (description.Status === import_client_cloudformation3.ChangeSetStatus.CREATE_COMPLETE || changeSetHasNoChanges(description)) {
      return description;
    }
    throw new ToolkitError(
      `Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || "NO_STATUS"}, ${description.StatusReason || "no reason provided"}`
    );
  });
  if (!ret) {
    throw new ToolkitError("Change set took too long to be created; aborting");
  }
  return ret;
}
async function createDiffChangeSet(ioHelper, options) {
  for (const resource of Object.values(options.stack.template.Resources ?? {})) {
    if (resource.Type === "AWS::CloudFormation::Stack") {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("This stack contains one or more nested stacks, falling back to template-only diff..."));
      return void 0;
    }
  }
  return uploadBodyParameterAndCreateChangeSet(ioHelper, options);
}
function templatesFromAssetManifestArtifact(artifact) {
  const assets = [];
  const fileName = artifact.file;
  const assetManifest = import_cdk_assets3.AssetManifest.fromFile(fileName);
  assetManifest.entries.forEach((entry) => {
    if (entry.type === "file") {
      const source = entry.source;
      if (source.path && source.path.endsWith(".template.json")) {
        assets.push(entry);
      }
    }
  });
  return [assetManifest, assets];
}
async function uploadBodyParameterAndCreateChangeSet(ioHelper, options) {
  try {
    await uploadStackTemplateAssets(options.stack, options.deployments);
    const env = await options.deployments.envs.accessStackForMutableStackOperations(options.stack);
    const bodyParameter = await makeBodyParameter(
      ioHelper,
      options.stack,
      env.resolvedEnvironment,
      new AssetManifestBuilder(),
      env.resources
    );
    const cfn = env.sdk.cloudFormation();
    const exists = (await CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
    const executionRoleArn = await env.replacePlaceholders(options.stack.cloudFormationExecutionRoleArn);
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(
      "Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n"
    ));
    return await createChangeSet(ioHelper, {
      cfn,
      changeSetName: "cdk-diff-change-set",
      stack: options.stack,
      exists,
      uuid: options.uuid,
      willExecute: options.willExecute,
      bodyParameter,
      parameters: options.parameters,
      resourcesToImport: options.resourcesToImport,
      role: executionRoleArn
    });
  } catch (e) {
    if (!options.failOnError) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(String(e)));
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(
        "Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n"
      ));
      return void 0;
    }
    throw new ToolkitError("Could not create a change set and failOnError is set. (run again with failOnError off to base the diff on template differences)\n", e);
  }
}
async function uploadStackTemplateAssets(stack, deployments) {
  for (const artifact of stack.dependencies) {
    if (!cxapi.AssetManifestArtifact.isAssetManifestArtifact(artifact)) {
      continue;
    }
    const [assetManifest, file_entries] = templatesFromAssetManifestArtifact(artifact);
    for (const entry of file_entries) {
      await deployments.buildSingleAsset(artifact, assetManifest, entry, {
        stack
      });
      await deployments.publishSingleAsset(assetManifest, entry, {
        stack
      });
    }
  }
}
async function createChangeSet(ioHelper, options) {
  await cleanupOldChangeset(options.cfn, ioHelper, options.changeSetName, options.stack.stackName);
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`));
  const templateParams = TemplateParameters.fromTemplate(options.stack.template);
  const stackParams = templateParams.supplyAll(options.parameters);
  const changeSet = await options.cfn.createChangeSet({
    StackName: options.stack.stackName,
    ChangeSetName: options.changeSetName,
    ChangeSetType: options.resourcesToImport ? "IMPORT" : options.exists ? "UPDATE" : "CREATE",
    Description: `CDK Changeset for diff ${options.uuid}`,
    ClientToken: `diff${options.uuid}`,
    TemplateURL: options.bodyParameter.TemplateURL,
    TemplateBody: options.bodyParameter.TemplateBody,
    Parameters: stackParams.apiParameters,
    ResourcesToImport: options.resourcesToImport,
    RoleARN: options.role,
    Tags: toCfnTags(options.stack.tags),
    Capabilities: ["CAPABILITY_IAM", "CAPABILITY_NAMED_IAM", "CAPABILITY_AUTO_EXPAND"]
  });
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Initiated creation of changeset: %s; waiting for it to finish creating...", changeSet.Id)));
  const createdChangeSet = await waitForChangeSet(options.cfn, ioHelper, options.stack.stackName, options.changeSetName, {
    fetchAll: options.willExecute
  });
  await cleanupOldChangeset(options.cfn, ioHelper, options.changeSetName, options.stack.stackName);
  return createdChangeSet;
}
function toCfnTags(tags) {
  return Object.entries(tags).map(([k, v]) => ({
    Key: k,
    Value: v
  }));
}
async function cleanupOldChangeset(cfn, ioHelper, changeSetName, stackName) {
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Removing existing change set with name ${changeSetName} if it exists`));
  await cfn.deleteChangeSet({
    StackName: stackName,
    ChangeSetName: changeSetName
  });
}
function changeSetHasNoChanges(description) {
  const noChangeErrorPrefixes = [
    // Error message for a regular template
    "The submitted information didn't contain changes.",
    // Error message when a Transform is involved (see #10650)
    "No updates are to be performed."
  ];
  return description.Status === "FAILED" && noChangeErrorPrefixes.some((p) => (description.StatusReason ?? "").startsWith(p));
}
async function waitForStackDelete(cfn, ioHelper, stackName) {
  const stack = await stabilizeStack(cfn, ioHelper, stackName);
  if (!stack) {
    return void 0;
  }
  const status = stack.stackStatus;
  if (status.isFailure) {
    throw new ToolkitError(
      `The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`
    );
  } else if (status.isDeleted) {
    return void 0;
  }
  return stack;
}
async function waitForStackDeploy(cfn, ioHelper, stackName) {
  const stack = await stabilizeStack(cfn, ioHelper, stackName);
  if (!stack) {
    return void 0;
  }
  const status = stack.stackStatus;
  if (status.isCreationFailure) {
    throw new ToolkitError(
      `The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`
    );
  } else if (!status.isDeploySuccess) {
    throw new ToolkitError(`The stack named ${stackName} failed to deploy: ${status}`);
  }
  return stack;
}
async function stabilizeStack(cfn, ioHelper, stackName) {
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Waiting for stack %s to finish creating or updating...", stackName)));
  return waitFor(async () => {
    const stack = await CloudFormationStack.lookup(cfn, stackName);
    if (!stack.exists) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Stack %s does not exist", stackName)));
      return null;
    }
    const status = stack.stackStatus;
    if (status.isInProgress) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Stack %s has an ongoing operation in progress and is not stable (%s)", stackName, status)));
      return void 0;
    } else if (status.isReviewInProgress) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util21.format)("Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)", stackName, status)));
    }
    return stack;
  });
}
var TemplateParameters = class _TemplateParameters {
  constructor(params) {
    this.params = params;
  }
  static fromTemplate(template) {
    return new _TemplateParameters(template.Parameters || {});
  }
  /**
   * Calculate stack parameters to pass from the given desired parameter values
   *
   * Will throw if parameters without a Default value or a Previous value are not
   * supplied.
   */
  supplyAll(updates) {
    return new ParameterValues(this.params, updates);
  }
  /**
   * From the template, the given desired values and the current values, calculate the changes to the stack parameters
   *
   * Will take into account parameters already set on the template (will emit
   * 'UsePreviousValue: true' for those unless the value is changed), and will
   * throw if parameters without a Default value or a Previous value are not
   * supplied.
   */
  updateExisting(updates, previousValues) {
    return new ParameterValues(this.params, updates, previousValues);
  }
};
var ParameterValues = class {
  constructor(formalParams, updates, previousValues = {}) {
    this.formalParams = formalParams;
    const missingRequired = new Array();
    for (const [key, formalParam] of Object.entries(this.formalParams)) {
      const updatedValue = updates[key];
      if (updatedValue !== void 0) {
        this.values[key] = updatedValue;
        this.apiParameters.push({
          ParameterKey: key,
          ParameterValue: updates[key]
        });
        continue;
      }
      if (key in previousValues) {
        this.values[key] = previousValues[key];
        this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
        continue;
      }
      if (formalParam.Default !== void 0) {
        this.values[key] = formalParam.Default;
        continue;
      }
      missingRequired.push(key);
    }
    if (missingRequired.length > 0) {
      throw new ToolkitError(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(", ")}`);
    }
    const unknownParam = ([key, _]) => this.formalParams[key] === void 0;
    const hasValue = ([_, value]) => !!value;
    for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
      this.values[key] = value;
      this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
    }
  }
  values = {};
  apiParameters = [];
  /**
   * Whether this set of parameter updates will change the actual stack values
   */
  hasChanges(currentValues) {
    if (Object.values(this.formalParams).some(
      (p) => p.Type.startsWith("AWS::SSM::Parameter::") && !p.Description?.includes(import_cx_api4.SSMPARAM_NO_INVALIDATE)
    )) {
      return "ssm";
    }
    if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
      return true;
    }
    if (Object.keys(this.values).some((key) => !(key in currentValues))) {
      return true;
    }
    return false;
  }
};

// ../tmp-toolkit-helpers/src/api/deployments/checks.ts
async function determineAllowCrossAccountAssetPublishing(sdk, ioHelper, customStackName) {
  try {
    const stackName = customStackName || "CDKToolkit";
    const stackInfo = await getBootstrapStackInfo(sdk, stackName);
    if (!stackInfo.hasStagingBucket) {
      return true;
    }
    if (stackInfo.bootstrapVersion >= 21) {
      return true;
    }
    return false;
  } catch (e) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Error determining cross account asset publishing: ${e}`));
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Defaulting to allowing cross account asset publishing"));
    return true;
  }
}
async function getBootstrapStackInfo(sdk, stackName) {
  try {
    const cfn = sdk.cloudFormation();
    const stackResponse = await cfn.describeStacks({ StackName: stackName });
    if (!stackResponse.Stacks || stackResponse.Stacks.length === 0) {
      throw new ToolkitError(`Toolkit stack ${stackName} not found`);
    }
    const stack = stackResponse.Stacks[0];
    const versionOutput = stack.Outputs?.find((output) => output.OutputKey === "BootstrapVersion");
    if (!versionOutput?.OutputValue) {
      throw new ToolkitError(`Unable to find BootstrapVersion output in the toolkit stack ${stackName}`);
    }
    const bootstrapVersion = parseInt(versionOutput.OutputValue);
    if (isNaN(bootstrapVersion)) {
      throw new ToolkitError(`Invalid BootstrapVersion value: ${versionOutput.OutputValue}`);
    }
    const bucketName = stack.Outputs?.find((output) => output.OutputKey === "BucketName")?.OutputValue;
    const hasStagingBucket = !!(bucketName && bucketName.match(/^[a-z0-9]/) && bucketName.match(/[a-z0-9]$/));
    return {
      hasStagingBucket,
      bootstrapVersion
    };
  } catch (e) {
    throw new ToolkitError(`Error retrieving toolkit stack info: ${e}`);
  }
}

// ../tmp-toolkit-helpers/src/api/deployments/deploy-stack.ts
var import_util28 = require("util");
var chalk6 = __toESM(require("chalk"));
var uuid3 = __toESM(require("uuid"));

// ../tmp-toolkit-helpers/src/api/deployments/assets.ts
var path6 = __toESM(require("path"));
var cxschema2 = __toESM(require("@aws-cdk/cloud-assembly-schema"));
var cxapi2 = __toESM(require("@aws-cdk/cx-api"));
var chalk4 = __toESM(require("chalk"));
async function addMetadataAssetsToManifest(ioHelper, stack, assetManifest, envResources, reuse) {
  reuse = reuse || [];
  const assets = stack.assets;
  if (assets.length === 0) {
    return {};
  }
  const toolkitInfo = await envResources.lookupToolkit();
  if (!toolkitInfo.found) {
    throw new ToolkitError(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${chalk4.blue("cdk bootstrap " + stack.environment.name)}")`);
  }
  const params = {};
  for (const asset of assets) {
    const reuseAsset = reuse.indexOf(asset.id) > -1;
    if (reuseAsset) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`));
      continue;
    }
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`));
    if (!stack.assembly) {
      throw new ToolkitError("Unexpected: stack assembly is required in order to find assets in assembly directory");
    }
    Object.assign(params, await prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo));
  }
  return params;
}
async function prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo) {
  switch (asset.packaging) {
    case "zip":
    case "file":
      return prepareFileAsset(
        ioHelper,
        asset,
        assetManifest,
        toolkitInfo,
        asset.packaging === "zip" ? cxschema2.FileAssetPackaging.ZIP_DIRECTORY : cxschema2.FileAssetPackaging.FILE
      );
    case "container-image":
      return prepareDockerImageAsset(asset, assetManifest, envResources);
    default:
      throw new ToolkitError(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
  }
}
async function prepareFileAsset(ioHelper, asset, assetManifest, toolkitInfo, packaging) {
  const extension = packaging === cxschema2.FileAssetPackaging.ZIP_DIRECTORY ? ".zip" : path6.extname(asset.path);
  const baseName = `${asset.sourceHash}${extension}`;
  const s3Prefix = asset.id === asset.sourceHash ? "assets/" : `assets/${asset.id}/`;
  const key = `${s3Prefix}${baseName}`;
  const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Storing asset ${asset.path} at ${s3url}`));
  assetManifest.addFileAsset(asset.sourceHash, {
    path: asset.path,
    packaging
  }, {
    bucketName: toolkitInfo.bucketName,
    objectKey: key
  });
  return {
    [asset.s3BucketParameter]: toolkitInfo.bucketName,
    [asset.s3KeyParameter]: `${s3Prefix}${cxapi2.ASSET_PREFIX_SEPARATOR}${baseName}`,
    [asset.artifactHashParameter]: asset.sourceHash
  };
}
async function prepareDockerImageAsset(asset, assetManifest, envResources) {
  if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
    throw new ToolkitError('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
  }
  const repositoryName = asset.repositoryName ?? "cdk/" + asset.id.replace(/[:/]/g, "-").toLowerCase();
  const { repositoryUri } = await envResources.prepareEcrRepository(repositoryName);
  const imageTag = asset.imageTag ?? asset.sourceHash;
  assetManifest.addDockerImageAsset(asset.sourceHash, {
    directory: asset.path,
    dockerBuildArgs: asset.buildArgs,
    dockerBuildSsh: asset.buildSsh,
    dockerBuildTarget: asset.target,
    dockerFile: asset.file,
    networkMode: asset.networkMode,
    platform: asset.platform,
    dockerOutputs: asset.outputs
  }, {
    repositoryName,
    imageTag
  });
  if (!asset.imageNameParameter) {
    return {};
  }
  return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}

// ../tmp-toolkit-helpers/src/api/hotswap/common.ts
var ICON = "\u2728";
var HotswapMode = /* @__PURE__ */ ((HotswapMode2) => {
  HotswapMode2["FALL_BACK"] = "fall-back";
  HotswapMode2["HOTSWAP_ONLY"] = "hotswap-only";
  HotswapMode2["FULL_DEPLOYMENT"] = "full-deployment";
  return HotswapMode2;
})(HotswapMode || {});
var HotswapPropertyOverrides = class {
  // Each supported resource type will have its own properties. Currently this is ECS
  ecsHotswapProperties;
  constructor(ecsHotswapProperties) {
    this.ecsHotswapProperties = ecsHotswapProperties;
  }
};
var EcsHotswapProperties = class {
  // The lower limit on the number of your service's tasks that must remain in the RUNNING state during a deployment, as a percentage of the desiredCount
  minimumHealthyPercent;
  // The upper limit on the number of your service's tasks that are allowed in the RUNNING or PENDING state during a deployment, as a percentage of the desiredCount
  maximumHealthyPercent;
  constructor(minimumHealthyPercent, maximumHealthyPercent) {
    if (minimumHealthyPercent !== void 0 && minimumHealthyPercent < 0) {
      throw new ToolkitError("hotswap-ecs-minimum-healthy-percent can't be a negative number");
    }
    if (maximumHealthyPercent !== void 0 && maximumHealthyPercent < 0) {
      throw new ToolkitError("hotswap-ecs-maximum-healthy-percent can't be a negative number");
    }
    if (minimumHealthyPercent == void 0) {
      this.minimumHealthyPercent = 0;
    } else {
      this.minimumHealthyPercent = minimumHealthyPercent;
    }
    this.maximumHealthyPercent = maximumHealthyPercent;
  }
  /**
   * Check if any hotswap properties are defined
   * @returns true if all properties are undefined, false otherwise
   */
  isEmpty() {
    return this.minimumHealthyPercent === 0 && this.maximumHealthyPercent === void 0;
  }
};
var ClassifiedChanges = class {
  constructor(change, hotswappableProps, nonHotswappableProps) {
    this.change = change;
    this.hotswappableProps = hotswappableProps;
    this.nonHotswappableProps = nonHotswappableProps;
  }
  reportNonHotswappablePropertyChanges(ret) {
    const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
    if (nonHotswappablePropNames.length > 0) {
      const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === "Tags";
      const reason = tagOnlyChange ? "tags" /* TAGS */ : "properties" /* PROPERTIES */;
      const description = tagOnlyChange ? "Tags are not hotswappable" : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`;
      ret.push(nonHotswappableChange(
        this.change,
        reason,
        description,
        this.nonHotswappableProps
      ));
    }
  }
  get namesOfHotswappableProps() {
    return Object.keys(this.hotswappableProps);
  }
};
function classifyChanges(xs, hotswappablePropNames) {
  const hotswappableProps = {};
  const nonHotswappableProps = {};
  for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
    if (hotswappablePropNames.includes(name)) {
      hotswappableProps[name] = propDiff;
    } else {
      nonHotswappableProps[name] = propDiff;
    }
  }
  return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
function nonHotswappableChange(change, reason, description, nonHotswappableProps, hotswapOnlyVisible = true) {
  return {
    hotswappable: false,
    hotswapOnlyVisible,
    change: {
      reason,
      description,
      subject: {
        type: "Resource",
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        rejectedProperties: Object.keys(nonHotswappableProps ?? change.propertyUpdates),
        metadata: change.metadata
      }
    }
  };
}
function nonHotswappableResource(change) {
  return {
    hotswappable: false,
    change: {
      reason: "resource-unsupported" /* RESOURCE_UNSUPPORTED */,
      description: "This resource type is not supported for hotswap deployments",
      subject: {
        type: "Resource",
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        rejectedProperties: Object.keys(change.propertyUpdates),
        metadata: change.metadata
      }
    }
  };
}

// ../tmp-toolkit-helpers/src/api/hotswap/hotswap-deployments.ts
var import_util26 = require("util");
var cfn_diff = __toESM(require("@aws-cdk/cloudformation-diff"));
var chalk5 = __toESM(require("chalk"));

// ../tmp-toolkit-helpers/src/api/deployments/deployment-result.ts
function assertIsSuccessfulDeployStackResult(x) {
  if (x.type !== "did-deploy-stack") {
    throw new ToolkitError(`Unexpected deployStack result. This should not happen: ${JSON.stringify(x)}. If you are seeing this error, please report it at https://github.com/aws/aws-cdk/issues/new/choose.`);
  }
}

// ../tmp-toolkit-helpers/src/api/hotswap/appsync-mapping-templates.ts
async function isHotswappableAppSyncChange(logicalId, change, evaluateCfnTemplate) {
  const isResolver = change.newValue.Type === "AWS::AppSync::Resolver";
  const isFunction = change.newValue.Type === "AWS::AppSync::FunctionConfiguration";
  const isGraphQLSchema = change.newValue.Type === "AWS::AppSync::GraphQLSchema";
  const isAPIKey = change.newValue.Type === "AWS::AppSync::ApiKey";
  if (!isResolver && !isFunction && !isGraphQLSchema && !isAPIKey) {
    return [];
  }
  const ret = [];
  const classifiedChanges = classifyChanges(change, [
    "RequestMappingTemplate",
    "RequestMappingTemplateS3Location",
    "ResponseMappingTemplate",
    "ResponseMappingTemplateS3Location",
    "Code",
    "CodeS3Location",
    "Definition",
    "DefinitionS3Location",
    "Expires"
  ]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
  if (namesOfHotswappableChanges.length > 0) {
    let physicalName = void 0;
    const arn = await evaluateCfnTemplate.establishResourcePhysicalName(
      logicalId,
      isFunction ? change.newValue.Properties?.Name : void 0
    );
    if (isResolver) {
      const arnParts = arn?.split("/");
      physicalName = arnParts ? `${arnParts[3]}.${arnParts[5]}` : void 0;
    } else {
      physicalName = arn;
    }
    if (!physicalName) {
      return ret;
    }
    ret.push({
      change: {
        cause: change,
        resources: [{
          logicalId,
          resourceType: change.newValue.Type,
          physicalName,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }]
      },
      hotswappable: true,
      service: "appsync",
      apply: async (sdk) => {
        const sdkProperties = {
          ...change.oldValue.Properties,
          Definition: change.newValue.Properties?.Definition,
          DefinitionS3Location: change.newValue.Properties?.DefinitionS3Location,
          requestMappingTemplate: change.newValue.Properties?.RequestMappingTemplate,
          requestMappingTemplateS3Location: change.newValue.Properties?.RequestMappingTemplateS3Location,
          responseMappingTemplate: change.newValue.Properties?.ResponseMappingTemplate,
          responseMappingTemplateS3Location: change.newValue.Properties?.ResponseMappingTemplateS3Location,
          code: change.newValue.Properties?.Code,
          codeS3Location: change.newValue.Properties?.CodeS3Location,
          expires: change.newValue.Properties?.Expires
        };
        const evaluatedResourceProperties = await evaluateCfnTemplate.evaluateCfnExpression(sdkProperties);
        const sdkRequestObject = transformObjectKeys(evaluatedResourceProperties, lowerCaseFirstCharacter);
        if (sdkRequestObject.requestMappingTemplateS3Location) {
          sdkRequestObject.requestMappingTemplate = await fetchFileFromS3(
            sdkRequestObject.requestMappingTemplateS3Location,
            sdk
          );
          delete sdkRequestObject.requestMappingTemplateS3Location;
        }
        if (sdkRequestObject.responseMappingTemplateS3Location) {
          sdkRequestObject.responseMappingTemplate = await fetchFileFromS3(
            sdkRequestObject.responseMappingTemplateS3Location,
            sdk
          );
          delete sdkRequestObject.responseMappingTemplateS3Location;
        }
        if (sdkRequestObject.definitionS3Location) {
          sdkRequestObject.definition = await fetchFileFromS3(sdkRequestObject.definitionS3Location, sdk);
          delete sdkRequestObject.definitionS3Location;
        }
        if (sdkRequestObject.codeS3Location) {
          sdkRequestObject.code = await fetchFileFromS3(sdkRequestObject.codeS3Location, sdk);
          delete sdkRequestObject.codeS3Location;
        }
        if (isResolver) {
          await sdk.appsync().updateResolver(sdkRequestObject);
        } else if (isFunction) {
          if (sdkRequestObject.code) {
            delete sdkRequestObject.functionVersion;
          } else {
            delete sdkRequestObject.runtime;
          }
          const functions = await sdk.appsync().listFunctions({ apiId: sdkRequestObject.apiId });
          const { functionId } = functions.find((fn) => fn.name === physicalName) ?? {};
          await exponentialBackOffRetry(
            () => sdk.appsync().updateFunction({
              ...sdkRequestObject,
              functionId
            }),
            6,
            1e3,
            "ConcurrentModificationException"
          );
        } else if (isGraphQLSchema) {
          let schemaCreationResponse = await sdk.appsync().startSchemaCreation(sdkRequestObject);
          while (schemaCreationResponse.status && ["PROCESSING", "DELETING"].some((status) => status === schemaCreationResponse.status)) {
            await sleep(1e3);
            const getSchemaCreationStatusRequest = {
              apiId: sdkRequestObject.apiId
            };
            schemaCreationResponse = await sdk.appsync().getSchemaCreationStatus(getSchemaCreationStatusRequest);
          }
          if (schemaCreationResponse.status === "FAILED") {
            throw new ToolkitError(schemaCreationResponse.details ?? "Schema creation has failed.");
          }
        } else {
          if (!sdkRequestObject.id) {
            const arnParts = physicalName?.split("/");
            if (arnParts && arnParts.length === 4) {
              sdkRequestObject.id = arnParts[3];
            }
          }
          await sdk.appsync().updateApiKey(sdkRequestObject);
        }
      }
    });
  }
  return ret;
}
async function fetchFileFromS3(s3Url, sdk) {
  const s3PathParts = s3Url.split("/");
  const s3Bucket = s3PathParts[2];
  const s3Key = s3PathParts.splice(3).join("/");
  return (await sdk.s3().getObject({ Bucket: s3Bucket, Key: s3Key })).Body?.transformToString();
}
async function exponentialBackOffRetry(fn, numOfRetries, backOff, errorCodeToRetry) {
  try {
    await fn();
  } catch (error2) {
    if (error2 && error2.name === errorCodeToRetry && numOfRetries > 0) {
      await sleep(backOff);
      await exponentialBackOffRetry(fn, numOfRetries - 1, backOff * 2, errorCodeToRetry);
    } else {
      throw error2;
    }
  }
}
async function sleep(ms) {
  return new Promise((ok) => setTimeout(ok, ms));
}

// ../tmp-toolkit-helpers/src/api/hotswap/code-build-projects.ts
async function isHotswappableCodeBuildProjectChange(logicalId, change, evaluateCfnTemplate) {
  if (change.newValue.Type !== "AWS::CodeBuild::Project") {
    return [];
  }
  const ret = [];
  const classifiedChanges = classifyChanges(change, ["Source", "Environment", "SourceVersion"]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  if (classifiedChanges.namesOfHotswappableProps.length > 0) {
    const updateProjectInput = {
      name: ""
    };
    const projectName = await evaluateCfnTemplate.establishResourcePhysicalName(
      logicalId,
      change.newValue.Properties?.Name
    );
    if (!projectName) {
      return ret;
    }
    ret.push({
      change: {
        cause: change,
        resources: [{
          logicalId,
          resourceType: change.newValue.Type,
          physicalName: projectName,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }]
      },
      hotswappable: true,
      service: "codebuild",
      apply: async (sdk) => {
        updateProjectInput.name = projectName;
        for (const updatedPropName in change.propertyUpdates) {
          const updatedProp = change.propertyUpdates[updatedPropName];
          switch (updatedPropName) {
            case "Source":
              updateProjectInput.source = transformObjectKeys(
                await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue),
                convertSourceCloudformationKeyToSdkKey
              );
              break;
            case "Environment":
              updateProjectInput.environment = await transformObjectKeys(
                await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue),
                lowerCaseFirstCharacter
              );
              break;
            case "SourceVersion":
              updateProjectInput.sourceVersion = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
              break;
          }
        }
        await sdk.codeBuild().updateProject(updateProjectInput);
      }
    });
  }
  return ret;
}
function convertSourceCloudformationKeyToSdkKey(key) {
  if (key.toLowerCase() === "buildspec") {
    return key.toLowerCase();
  }
  return lowerCaseFirstCharacter(key);
}

// ../tmp-toolkit-helpers/src/api/hotswap/ecs-services.ts
var ECS_SERVICE_RESOURCE_TYPE = "AWS::ECS::Service";
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate, hotswapPropertyOverrides) {
  if (change.newValue.Type !== "AWS::ECS::TaskDefinition") {
    return [];
  }
  const ret = [];
  const classifiedChanges = classifyChanges(change, ["ContainerDefinitions"]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
  const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(
    (r) => r.Type === ECS_SERVICE_RESOURCE_TYPE
  );
  const ecsServicesReferencingTaskDef = new Array();
  for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
    const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
    if (serviceArn) {
      ecsServicesReferencingTaskDef.push({
        logicalId: ecsServiceResource.LogicalId,
        serviceArn
      });
    }
  }
  if (ecsServicesReferencingTaskDef.length === 0) {
    ret.push(nonHotswappableChange(
      change,
      "dependency-unsupported" /* DEPENDENCY_UNSUPPORTED */,
      "No ECS services reference the changed task definition",
      void 0,
      false
    ));
  }
  if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
    const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter((r) => r.Type !== ECS_SERVICE_RESOURCE_TYPE);
    for (const taskRef of nonEcsServiceTaskDefRefs) {
      ret.push(nonHotswappableChange(
        change,
        "dependency-unsupported" /* DEPENDENCY_UNSUPPORTED */,
        `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`
      ));
    }
  }
  const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
  if (namesOfHotswappableChanges.length > 0) {
    const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
    ret.push({
      change: {
        cause: change,
        resources: [
          {
            logicalId,
            resourceType: change.newValue.Type,
            physicalName: await taskDefinitionResource.Family,
            metadata: evaluateCfnTemplate.metadataFor(logicalId)
          },
          ...ecsServicesReferencingTaskDef.map((ecsService) => ({
            resourceType: ECS_SERVICE_RESOURCE_TYPE,
            physicalName: ecsService.serviceArn.split("/")[2],
            logicalId: ecsService.logicalId,
            metadata: evaluateCfnTemplate.metadataFor(ecsService.logicalId)
          }))
        ]
      },
      hotswappable: true,
      service: "ecs-service",
      apply: async (sdk) => {
        const lowercasedTaskDef = transformObjectKeys(taskDefinitionResource, lowerCaseFirstCharacter, {
          // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
          // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
          ContainerDefinitions: {
            DockerLabels: true,
            FirelensConfiguration: {
              Options: true
            },
            LogConfiguration: {
              Options: true
            }
          },
          Volumes: {
            DockerVolumeConfiguration: {
              DriverOpts: true,
              Labels: true
            }
          }
        });
        const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef);
        const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
        let ecsHotswapProperties = hotswapPropertyOverrides.ecsHotswapProperties;
        let minimumHealthyPercent = ecsHotswapProperties?.minimumHealthyPercent;
        let maximumHealthyPercent = ecsHotswapProperties?.maximumHealthyPercent;
        await Promise.all(
          ecsServicesReferencingTaskDef.map(async (service) => {
            const cluster = service.serviceArn.split("/")[1];
            const update = await sdk.ecs().updateService({
              service: service.serviceArn,
              taskDefinition: taskDefRevArn,
              cluster,
              forceNewDeployment: true,
              deploymentConfiguration: {
                minimumHealthyPercent: minimumHealthyPercent !== void 0 ? minimumHealthyPercent : 0,
                maximumPercent: maximumHealthyPercent !== void 0 ? maximumHealthyPercent : void 0
              }
            });
            await sdk.ecs().waitUntilServicesStable({
              cluster: update.service?.clusterArn,
              services: [service.serviceArn]
            });
          })
        );
      }
    });
  }
  return ret;
}
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
  const taskDefinitionResource = {
    ...change.oldValue.Properties,
    ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions
  };
  const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(
    logicalId,
    taskDefinitionResource?.Family
  );
  if (!familyNameOrArn) {
    return;
  }
  const familyNameOrArnParts = familyNameOrArn.split(":");
  const family = familyNameOrArnParts.length > 1 ? (
    // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
    // so, take the 6th element, at index 5, and split it on '/'
    familyNameOrArnParts[5].split("/")[1]
  ) : (
    // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
    familyNameOrArn
  );
  return {
    ...await evaluateCfnTemplate.evaluateCfnExpression({
      ...taskDefinitionResource ?? {},
      Family: void 0
    }),
    Family: family
  };
}

// ../tmp-toolkit-helpers/src/api/hotswap/lambda-functions.ts
var import_stream = require("stream");
var archiver2 = require("archiver");
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
  if (change.newValue.Type === "AWS::Lambda::Version") {
    return [];
  }
  if (change.newValue.Type === "AWS::Lambda::Alias") {
    return classifyAliasChanges(change);
  }
  if (change.newValue.Type !== "AWS::Lambda::Function") {
    return [];
  }
  const ret = [];
  const classifiedChanges = classifyChanges(change, ["Code", "Environment", "Description"]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(
    logicalId,
    change.newValue.Properties?.FunctionName
  );
  const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
  if (functionName && namesOfHotswappableChanges.length > 0) {
    const lambdaCodeChange = await evaluateLambdaFunctionProps(
      classifiedChanges.hotswappableProps,
      change.newValue.Properties?.Runtime,
      evaluateCfnTemplate
    );
    if (lambdaCodeChange === void 0) {
      return ret;
    }
    const dependencies = await dependantResources(logicalId, functionName, evaluateCfnTemplate);
    ret.push({
      change: {
        cause: change,
        resources: [
          {
            logicalId,
            resourceType: change.newValue.Type,
            physicalName: functionName,
            metadata: evaluateCfnTemplate.metadataFor(logicalId)
          },
          ...dependencies
        ]
      },
      hotswappable: true,
      service: "lambda",
      apply: async (sdk) => {
        const lambda = sdk.lambda();
        const operations = [];
        if (lambdaCodeChange.code !== void 0 || lambdaCodeChange.configurations !== void 0) {
          if (lambdaCodeChange.code !== void 0) {
            const updateFunctionCodeResponse = await lambda.updateFunctionCode({
              FunctionName: functionName,
              S3Bucket: lambdaCodeChange.code.s3Bucket,
              S3Key: lambdaCodeChange.code.s3Key,
              ImageUri: lambdaCodeChange.code.imageUri,
              ZipFile: lambdaCodeChange.code.functionCodeZip,
              S3ObjectVersion: lambdaCodeChange.code.s3ObjectVersion
            });
            await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
          }
          if (lambdaCodeChange.configurations !== void 0) {
            const updateRequest = {
              FunctionName: functionName
            };
            if (lambdaCodeChange.configurations.description !== void 0) {
              updateRequest.Description = lambdaCodeChange.configurations.description;
            }
            if (lambdaCodeChange.configurations.environment !== void 0) {
              updateRequest.Environment = lambdaCodeChange.configurations.environment;
            }
            const updateFunctionCodeResponse = await lambda.updateFunctionConfiguration(updateRequest);
            await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
          }
          const versions = dependencies.filter((d) => d.resourceType === "AWS::Lambda::Version");
          if (versions.length) {
            const publishVersionPromise = lambda.publishVersion({
              FunctionName: functionName
            });
            const aliases = dependencies.filter((d) => d.resourceType === "AWS::Lambda::Alias");
            if (aliases.length) {
              const versionUpdate = await publishVersionPromise;
              for (const alias of aliases) {
                operations.push(
                  lambda.updateAlias({
                    FunctionName: functionName,
                    Name: alias.physicalName,
                    FunctionVersion: versionUpdate.Version
                  })
                );
              }
            } else {
              operations.push(publishVersionPromise);
            }
          }
        }
        await Promise.all(operations);
      }
    });
  }
  return ret;
}
function classifyAliasChanges(change) {
  const ret = [];
  const classifiedChanges = classifyChanges(change, ["FunctionVersion"]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  return ret;
}
async function evaluateLambdaFunctionProps(hotswappablePropChanges, runtime, evaluateCfnTemplate) {
  let code = void 0;
  let description = void 0;
  let environment = void 0;
  for (const updatedPropName in hotswappablePropChanges) {
    const updatedProp = hotswappablePropChanges[updatedPropName];
    switch (updatedPropName) {
      case "Code":
        let s3Bucket, s3Key, s3ObjectVersion, imageUri, functionCodeZip;
        for (const newPropName in updatedProp.newValue) {
          switch (newPropName) {
            case "S3Bucket":
              s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
              break;
            case "S3Key":
              s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
              break;
            case "S3ObjectVersion":
              s3ObjectVersion = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
              break;
            case "ImageUri":
              imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
              break;
            case "ZipFile":
              const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
              const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression(runtime);
              if (!functionRuntime) {
                return void 0;
              }
              const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
              functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
              break;
          }
        }
        code = {
          s3Bucket,
          s3Key,
          s3ObjectVersion,
          imageUri,
          functionCodeZip
        };
        break;
      case "Description":
        description = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
        break;
      case "Environment":
        environment = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
        break;
      default:
        throw new ToolkitError(
          "while apply()ing, found a property that cannot be hotswapped. Please report this at github.com/aws/aws-cdk/issues/new/choose"
        );
    }
  }
  const configurations = description || environment ? { description, environment } : void 0;
  return code || configurations ? { code, configurations } : void 0;
}
function zipString(fileName, rawString) {
  return new Promise((resolve2, reject) => {
    const buffers = [];
    const converter = new import_stream.Writable();
    converter._write = (chunk, _, callback) => {
      buffers.push(chunk);
      process.nextTick(callback);
    };
    converter.on("finish", () => {
      resolve2(Buffer.concat(buffers));
    });
    const archive = archiver2("zip");
    archive.on("error", (err) => {
      reject(err);
    });
    archive.pipe(converter);
    archive.append(rawString, {
      name: fileName,
      date: /* @__PURE__ */ new Date("1980-01-01T00:00:00.000Z")
      // Add date to make resulting zip file deterministic
    });
    void archive.finalize();
  });
}
async function waitForLambdasPropertiesUpdateToFinish(currentFunctionConfiguration, lambda, functionName) {
  const functionIsInVpcOrUsesDockerForCode = currentFunctionConfiguration.VpcConfig?.VpcId || currentFunctionConfiguration.PackageType === "Image";
  const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
  await lambda.waitUntilFunctionUpdated(delaySeconds, {
    FunctionName: functionName
  });
}
function determineCodeFileExtFromRuntime(runtime) {
  if (runtime.startsWith("node")) {
    return "js";
  }
  if (runtime.startsWith("python")) {
    return "py";
  }
  throw new CfnEvaluationException(
    `runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`
  );
}
async function versionsAndAliases(logicalId, evaluateCfnTemplate) {
  const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId).filter((r) => r.Type === "AWS::Lambda::Version");
  const aliasesReferencingVersions = flatMap(versionsReferencingFunction, (v) => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
  return { versionsReferencingFunction, aliasesReferencingVersions };
}
async function dependantResources(logicalId, functionName, evaluateCfnTemplate) {
  const candidates = await versionsAndAliases(logicalId, evaluateCfnTemplate);
  const aliases = await Promise.all(candidates.aliasesReferencingVersions.map(async (a) => {
    const name = await evaluateCfnTemplate.evaluateCfnExpression(a.Properties?.Name);
    return {
      logicalId: a.LogicalId,
      resourceType: a.Type,
      physicalName: name,
      description: `${a.Type} '${name}' for AWS::Lambda::Function '${functionName}'`,
      metadata: evaluateCfnTemplate.metadataFor(a.LogicalId)
    };
  }));
  const versions = candidates.versionsReferencingFunction.map((v) => ({
    logicalId: v.LogicalId,
    resourceType: v.Type,
    description: `${v.Type} for AWS::Lambda::Function '${functionName}'`,
    metadata: evaluateCfnTemplate.metadataFor(v.LogicalId)
  }));
  return [
    ...versions,
    ...aliases
  ];
}

// ../tmp-toolkit-helpers/src/api/hotswap/s3-bucket-deployments.ts
var REQUIRED_BY_CFN = "required-to-be-present-by-cfn";
var CDK_BUCKET_DEPLOYMENT_CFN_TYPE = "Custom::CDKBucketDeployment";
async function isHotswappableS3BucketDeploymentChange(logicalId, change, evaluateCfnTemplate) {
  const ret = [];
  if (change.newValue.Type !== CDK_BUCKET_DEPLOYMENT_CFN_TYPE) {
    return [];
  }
  const customResourceProperties = await evaluateCfnTemplate.evaluateCfnExpression({
    ...change.newValue.Properties,
    ServiceToken: void 0
  });
  const functionName = await evaluateCfnTemplate.evaluateCfnExpression(change.newValue.Properties?.ServiceToken);
  if (!functionName) {
    return ret;
  }
  ret.push({
    change: {
      cause: change,
      resources: [{
        logicalId,
        physicalName: customResourceProperties.DestinationBucketName,
        resourceType: CDK_BUCKET_DEPLOYMENT_CFN_TYPE,
        description: `Contents of AWS::S3::Bucket '${customResourceProperties.DestinationBucketName}'`,
        metadata: evaluateCfnTemplate.metadataFor(logicalId)
      }]
    },
    hotswappable: true,
    service: "custom-s3-deployment",
    apply: async (sdk) => {
      await sdk.lambda().invokeCommand({
        FunctionName: functionName,
        // Lambda refuses to take a direct JSON object and requires it to be stringify()'d
        Payload: JSON.stringify({
          RequestType: "Update",
          ResponseURL: REQUIRED_BY_CFN,
          PhysicalResourceId: REQUIRED_BY_CFN,
          StackId: REQUIRED_BY_CFN,
          RequestId: REQUIRED_BY_CFN,
          LogicalResourceId: REQUIRED_BY_CFN,
          ResourceProperties: stringifyObject(customResourceProperties)
          // JSON.stringify() doesn't turn the actual objects to strings, but the lambda expects strings
        })
      });
    }
  });
  return ret;
}
async function skipChangeForS3DeployCustomResourcePolicy(iamPolicyLogicalId, change, evaluateCfnTemplate) {
  if (change.newValue.Type !== "AWS::IAM::Policy") {
    return false;
  }
  const roles = change.newValue.Properties?.Roles;
  if (!roles || !roles.length) {
    return false;
  }
  for (const role of roles) {
    const roleArn = await evaluateCfnTemplate.evaluateCfnExpression(role);
    const roleLogicalId = await evaluateCfnTemplate.findLogicalIdForPhysicalName(roleArn);
    if (!roleLogicalId) {
      return false;
    }
    const roleRefs = evaluateCfnTemplate.findReferencesTo(roleLogicalId).filter((roleRef) => !(roleRef.Type == "AWS::IAM::Policy" && roleRef.LogicalId === iamPolicyLogicalId));
    const isRoleOnlyForS3Deployment = roleRefs.length >= 1 && roleRefs.every((roleRef) => {
      if (roleRef.Type === "AWS::Lambda::Function") {
        const lambdaRefs = evaluateCfnTemplate.findReferencesTo(roleRef.LogicalId);
        return lambdaRefs.length >= 1 && lambdaRefs.every((lambdaRef) => lambdaRef.Type === "Custom::CDKBucketDeployment");
      }
      return false;
    });
    if (!isRoleOnlyForS3Deployment) {
      return false;
    }
  }
  return true;
}
function stringifyObject(obj) {
  if (obj == null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(stringifyObject);
  }
  if (typeof obj !== "object") {
    return obj.toString();
  }
  const ret = {};
  for (const [k, v] of Object.entries(obj)) {
    ret[k] = stringifyObject(v);
  }
  return ret;
}

// ../tmp-toolkit-helpers/src/api/hotswap/stepfunctions-state-machines.ts
async function isHotswappableStateMachineChange(logicalId, change, evaluateCfnTemplate) {
  if (change.newValue.Type !== "AWS::StepFunctions::StateMachine") {
    return [];
  }
  const ret = [];
  const classifiedChanges = classifyChanges(change, ["DefinitionString"]);
  classifiedChanges.reportNonHotswappablePropertyChanges(ret);
  const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
  if (namesOfHotswappableChanges.length > 0) {
    const stateMachineNameInCfnTemplate = change.newValue?.Properties?.StateMachineName;
    const stateMachineArn = stateMachineNameInCfnTemplate ? await evaluateCfnTemplate.evaluateCfnExpression({
      "Fn::Sub": "arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:" + stateMachineNameInCfnTemplate
    }) : await evaluateCfnTemplate.findPhysicalNameFor(logicalId);
    if (!stateMachineArn) {
      return ret;
    }
    ret.push({
      change: {
        cause: change,
        resources: [{
          logicalId,
          resourceType: change.newValue.Type,
          physicalName: stateMachineArn?.split(":")[6],
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }]
      },
      hotswappable: true,
      service: "stepfunctions-service",
      apply: async (sdk) => {
        await sdk.stepFunctions().updateStateMachine({
          stateMachineArn,
          definition: await evaluateCfnTemplate.evaluateCfnExpression(change.propertyUpdates.DefinitionString.newValue)
        });
      }
    });
  }
  return ret;
}

// ../tmp-toolkit-helpers/src/api/hotswap/hotswap-deployments.ts
var pLimit = require("p-limit");
var RESOURCE_DETECTORS = {
  // Lambda
  "AWS::Lambda::Function": isHotswappableLambdaFunctionChange,
  "AWS::Lambda::Version": isHotswappableLambdaFunctionChange,
  "AWS::Lambda::Alias": isHotswappableLambdaFunctionChange,
  // AppSync
  "AWS::AppSync::Resolver": isHotswappableAppSyncChange,
  "AWS::AppSync::FunctionConfiguration": isHotswappableAppSyncChange,
  "AWS::AppSync::GraphQLSchema": isHotswappableAppSyncChange,
  "AWS::AppSync::ApiKey": isHotswappableAppSyncChange,
  "AWS::ECS::TaskDefinition": isHotswappableEcsServiceChange,
  "AWS::CodeBuild::Project": isHotswappableCodeBuildProjectChange,
  "AWS::StepFunctions::StateMachine": isHotswappableStateMachineChange,
  "Custom::CDKBucketDeployment": isHotswappableS3BucketDeploymentChange,
  "AWS::IAM::Policy": async (logicalId, change, evaluateCfnTemplate) => {
    if (await skipChangeForS3DeployCustomResourcePolicy(logicalId, change, evaluateCfnTemplate)) {
      return [];
    }
    return [nonHotswappableResource(change)];
  },
  "AWS::CDK::Metadata": async () => []
};
async function tryHotswapDeployment(sdkProvider, ioHelper, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
  const hotswapSpan = await ioHelper.span(SPAN.HOTSWAP).begin({
    stack: stackArtifact,
    mode: hotswapMode
  });
  const result2 = await hotswapDeployment(
    sdkProvider,
    hotswapSpan,
    assetParams,
    stackArtifact,
    hotswapMode,
    hotswapPropertyOverrides
  );
  await hotswapSpan.end(result2);
  if (result2?.hotswapped === true) {
    return {
      type: "did-deploy-stack",
      noOp: result2.hotswappableChanges.length === 0,
      stackArn: cloudFormationStack.stackId,
      outputs: cloudFormationStack.outputs
    };
  }
  return void 0;
}
async function hotswapDeployment(sdkProvider, ioSpan, assetParams, stack, hotswapMode, hotswapPropertyOverrides) {
  const resolvedEnv = await sdkProvider.resolveEnvironment(stack.environment);
  const sdk = (await sdkProvider.forEnvironment(resolvedEnv, 1 /* ForWriting */)).sdk;
  const currentTemplate = await loadCurrentTemplateWithNestedStacks(stack, sdk);
  const evaluateCfnTemplate = new EvaluateCloudFormationTemplate({
    stackArtifact: stack,
    parameters: assetParams,
    account: resolvedEnv.account,
    region: resolvedEnv.region,
    partition: (await sdk.currentAccount()).partition,
    sdk,
    nestedStacks: currentTemplate.nestedStacks
  });
  const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stack.template);
  const { hotswappable, nonHotswappable } = await classifyResourceChanges(
    stackChanges,
    evaluateCfnTemplate,
    sdk,
    currentTemplate.nestedStacks,
    hotswapPropertyOverrides
  );
  await logRejectedChanges(ioSpan, nonHotswappable, hotswapMode);
  const hotswappableChanges = hotswappable.map((o) => o.change);
  const nonHotswappableChanges = nonHotswappable.map((n) => n.change);
  await ioSpan.notify(IO.CDK_TOOLKIT_I5401.msg("Hotswap plan created", {
    stack,
    mode: hotswapMode,
    hotswappableChanges,
    nonHotswappableChanges
  }));
  if (hotswapMode === "fall-back") {
    if (nonHotswappableChanges.length > 0) {
      return {
        stack,
        mode: hotswapMode,
        hotswapped: false,
        hotswappableChanges,
        nonHotswappableChanges
      };
    }
  }
  await applyAllHotswapOperations(sdk, ioSpan, hotswappable);
  return {
    stack,
    mode: hotswapMode,
    hotswapped: true,
    hotswappableChanges,
    nonHotswappableChanges
  };
}
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
  const resourceDifferences = getStackResourceDifferences(stackChanges);
  const promises = [];
  const hotswappableResources = new Array();
  const nonHotswappableResources = new Array();
  for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
    nonHotswappableResources.push({
      hotswappable: false,
      change: {
        reason: "output" /* OUTPUT */,
        description: "output was changed",
        subject: {
          type: "Output",
          logicalId,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }
      }
    });
  }
  for (const [logicalId, change] of Object.entries(resourceDifferences)) {
    if (change.newValue?.Type === "AWS::CloudFormation::Stack" && change.oldValue?.Type === "AWS::CloudFormation::Stack") {
      const nestedHotswappableResources = await findNestedHotswappableChanges(
        logicalId,
        change,
        nestedStackNames,
        evaluateCfnTemplate,
        sdk,
        hotswapPropertyOverrides
      );
      hotswappableResources.push(...nestedHotswappableResources.hotswappable);
      nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappable);
      continue;
    }
    const hotswappableChangeCandidate = isCandidateForHotswapping(logicalId, change, evaluateCfnTemplate);
    if ("hotswappable" in hotswappableChangeCandidate) {
      if (!hotswappableChangeCandidate.hotswappable) {
        nonHotswappableResources.push(hotswappableChangeCandidate);
      }
      continue;
    }
    const resourceType = hotswappableChangeCandidate.newValue.Type;
    if (resourceType in RESOURCE_DETECTORS) {
      promises.push(
        () => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides)
      );
    } else {
      nonHotswappableResources.push(nonHotswappableResource(hotswappableChangeCandidate));
    }
  }
  const changesDetectionResults = [];
  for (const detectorResultPromises of promises) {
    const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
    changesDetectionResults.push(hotswapDetectionResults);
  }
  for (const resourceDetectionResults of changesDetectionResults) {
    for (const propertyResult of resourceDetectionResults) {
      propertyResult.hotswappable ? hotswappableResources.push(propertyResult) : nonHotswappableResources.push(propertyResult);
    }
  }
  return {
    hotswappable: hotswappableResources,
    nonHotswappable: nonHotswappableResources
  };
}
function getStackResourceDifferences(stackChanges) {
  const allResourceChanges = stackChanges.resources.changes;
  const allRemovalChanges = filterDict(allResourceChanges, (resChange) => resChange.isRemoval);
  const allNonRemovalChanges = filterDict(allResourceChanges, (resChange) => !resChange.isRemoval);
  for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
    if (nonRemovalChange.isAddition) {
      const addChange = nonRemovalChange;
      const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
        return changesAreForSameResource(remChange, addChange);
      });
      if (identicalRemovalChange) {
        const [removedLogId, removedResourceChange] = identicalRemovalChange;
        allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
        delete allRemovalChanges[removedLogId];
      }
    }
  }
  return {
    ...allRemovalChanges,
    ...allNonRemovalChanges
  };
}
function filterDict(dict, func) {
  return Object.entries(dict).reduce(
    (acc, [key, t]) => {
      if (func(t)) {
        acc[key] = t;
      }
      return acc;
    },
    {}
  );
}
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
  const nestedStack = nestedStackTemplates[logicalId];
  if (!nestedStack.physicalName) {
    return {
      hotswappable: [],
      nonHotswappable: [
        {
          hotswappable: false,
          change: {
            reason: "nested-stack-creation" /* NESTED_STACK_CREATION */,
            description: "newly created nested stacks cannot be hotswapped",
            subject: {
              type: "Resource",
              logicalId,
              resourceType: "AWS::CloudFormation::Stack",
              metadata: evaluateCfnTemplate.metadataFor(logicalId)
            }
          }
        }
      ]
    };
  }
  const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(
    nestedStack.physicalName,
    nestedStack.generatedTemplate,
    change.newValue?.Properties?.Parameters
  );
  const nestedDiff = cfn_diff.fullDiff(
    nestedStackTemplates[logicalId].deployedTemplate,
    nestedStackTemplates[logicalId].generatedTemplate
  );
  return classifyResourceChanges(
    nestedDiff,
    evaluateNestedCfnTemplate,
    sdk,
    nestedStackTemplates[logicalId].nestedStackTemplates,
    hotswapPropertyOverrides
  );
}
function changesAreForSameResource(oldChange, newChange) {
  return oldChange.oldResourceType === newChange.newResourceType && // this isn't great, but I don't want to bring in something like underscore just for this comparison
  JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
  return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue,
    addChange.newValue,
    {
      resourceType: {
        oldType: remChange.oldResourceType,
        newType: addChange.newResourceType
      },
      propertyDiffs: addChange.propertyDiffs,
      otherDiffs: addChange.otherDiffs
    }
  );
}
function isCandidateForHotswapping(logicalId, change, evaluateCfnTemplate) {
  if (!change.oldValue) {
    return {
      hotswappable: false,
      change: {
        reason: "resource-creation" /* RESOURCE_CREATION */,
        description: `resource '${logicalId}' was created by this deployment`,
        subject: {
          type: "Resource",
          logicalId,
          resourceType: change.newValue.Type,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }
      }
    };
  } else if (!change.newValue) {
    return {
      hotswappable: false,
      logicalId,
      change: {
        reason: "resource-deletion" /* RESOURCE_DELETION */,
        description: `resource '${logicalId}' was destroyed by this deployment`,
        subject: {
          type: "Resource",
          logicalId,
          resourceType: change.oldValue.Type,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }
      }
    };
  }
  if (change.newValue.Type !== change.oldValue.Type) {
    return {
      hotswappable: false,
      change: {
        reason: "resource-type-changed" /* RESOURCE_TYPE_CHANGED */,
        description: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        subject: {
          type: "Resource",
          logicalId,
          resourceType: change.newValue.Type,
          metadata: evaluateCfnTemplate.metadataFor(logicalId)
        }
      }
    };
  }
  return {
    logicalId,
    oldValue: change.oldValue,
    newValue: change.newValue,
    propertyUpdates: change.propertyUpdates,
    metadata: evaluateCfnTemplate.metadataFor(logicalId)
  };
}
async function applyAllHotswapOperations(sdk, ioSpan, hotswappableChanges) {
  if (hotswappableChanges.length === 0) {
    return Promise.resolve([]);
  }
  await ioSpan.notify(IO.DEFAULT_TOOLKIT_INFO.msg(`
${ICON} hotswapping resources:`));
  const limit = pLimit(10);
  return Promise.all(hotswappableChanges.map((hotswapOperation) => limit(() => {
    return applyHotswapOperation(sdk, ioSpan, hotswapOperation);
  })));
}
async function applyHotswapOperation(sdk, ioSpan, hotswapOperation) {
  const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
  sdk.appendCustomUserAgent(customUserAgent);
  const resourceText = (r) => r.description ?? `${r.resourceType} '${r.physicalName ?? r.logicalId}'`;
  await ioSpan.notify(IO.CDK_TOOLKIT_I5402.msg(
    hotswapOperation.change.resources.map((r) => (0, import_util26.format)(`   ${ICON} %s`, chalk5.bold(resourceText(r)))).join("\n"),
    hotswapOperation.change
  ));
  try {
    await hotswapOperation.apply(sdk);
  } catch (e) {
    if (e.name === "TimeoutError" || e.name === "AbortError") {
      const result2 = JSON.parse(formatErrorMessage(e));
      const error2 = new ToolkitError(formatWaiterErrorResult(result2));
      error2.name = e.name;
      throw error2;
    }
    throw e;
  }
  await ioSpan.notify(IO.CDK_TOOLKIT_I5403.msg(
    hotswapOperation.change.resources.map((r) => (0, import_util26.format)(`   ${ICON} %s %s`, chalk5.bold(resourceText(r)), chalk5.green("hotswapped!"))).join("\n"),
    hotswapOperation.change
  ));
  sdk.removeCustomUserAgent(customUserAgent);
}
function formatWaiterErrorResult(result2) {
  const main = [
    `Resource is not in the expected state due to waiter status: ${result2.state}`,
    result2.reason ? `${result2.reason}.` : ""
  ].join(". ");
  if (result2.observedResponses != null) {
    const observedResponses = Object.entries(result2.observedResponses).map(([msg, count]) => `  - ${msg} (${count})`).join("\n");
    return `${main} Observed responses:
${observedResponses}`;
  }
  return main;
}
async function logRejectedChanges(ioSpan, rejectedChanges, hotswapMode) {
  if (rejectedChanges.length === 0) {
    return;
  }
  if (hotswapMode === "hotswap-only") {
    rejectedChanges = rejectedChanges.filter((change) => change.hotswapOnlyVisible === true);
    if (rejectedChanges.length === 0) {
      return;
    }
  }
  const messages = [""];
  if (hotswapMode === "hotswap-only") {
    messages.push((0, import_util26.format)("%s %s", chalk5.red("\u26A0\uFE0F"), chalk5.red("The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback")));
  } else {
    messages.push((0, import_util26.format)("%s %s", chalk5.red("\u26A0\uFE0F"), chalk5.red("The following non-hotswappable changes were found:")));
  }
  for (const { change } of rejectedChanges) {
    messages.push("    " + nonHotswappableChangeMessage(change));
  }
  messages.push("");
  await ioSpan.notify(IO.DEFAULT_TOOLKIT_INFO.msg(messages.join("\n")));
}
function nonHotswappableChangeMessage(change) {
  const subject = change.subject;
  const reason = change.description ?? change.reason;
  switch (subject.type) {
    case "Output":
      return (0, import_util26.format)(
        "output: %s, reason: %s",
        chalk5.bold(subject.logicalId),
        chalk5.red(reason)
      );
    case "Resource":
      return nonHotswappableResourceMessage(subject, reason);
  }
}
function nonHotswappableResourceMessage(subject, reason) {
  if (subject.rejectedProperties?.length) {
    return (0, import_util26.format)(
      "resource: %s, type: %s, rejected changes: %s, reason: %s",
      chalk5.bold(subject.logicalId),
      chalk5.bold(subject.resourceType),
      chalk5.bold(subject.rejectedProperties),
      chalk5.red(reason)
    );
  }
  return (0, import_util26.format)(
    "resource: %s, type: %s, reason: %s",
    chalk5.bold(subject.logicalId),
    chalk5.bold(subject.resourceType),
    chalk5.red(reason)
  );
}

// ../tmp-toolkit-helpers/src/api/deployments/deploy-stack.ts
async function deployStack(options, ioHelper) {
  const stackArtifact = options.stack;
  const stackEnv = options.resolvedEnvironment;
  options.sdk.appendCustomUserAgent(options.extraUserAgent);
  const cfn = options.sdk.cloudFormation();
  const deployName = options.deployName || stackArtifact.stackName;
  let cloudFormationStack = await CloudFormationStack.lookup(cfn, deployName);
  if (cloudFormationStack.stackStatus.isCreationFailure) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(
      `Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`
    ));
    await cfn.deleteStack({ StackName: deployName });
    const deletedStack = await waitForStackDelete(cfn, ioHelper, deployName);
    if (deletedStack && deletedStack.stackStatus.name !== "DELETE_COMPLETE") {
      throw new ToolkitError(
        `Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`
      );
    }
    cloudFormationStack = CloudFormationStack.doesNotExist(cfn, deployName);
  }
  const legacyAssets = new AssetManifestBuilder();
  const assetParams = await addMetadataAssetsToManifest(
    ioHelper,
    stackArtifact,
    legacyAssets,
    options.envResources,
    options.reuseAssets
  );
  const finalParameterValues = { ...options.parameters, ...assetParams };
  const templateParams = TemplateParameters.fromTemplate(stackArtifact.template);
  const stackParams = options.usePreviousParameters ? templateParams.updateExisting(finalParameterValues, cloudFormationStack.parameters) : templateParams.supplyAll(finalParameterValues);
  const hotswapMode = options.hotswap ?? "full-deployment" /* FULL_DEPLOYMENT */;
  const hotswapPropertyOverrides = options.hotswapPropertyOverrides ?? new HotswapPropertyOverrides();
  if (await canSkipDeploy(options, cloudFormationStack, stackParams.hasChanges(cloudFormationStack.parameters), ioHelper)) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: skipping deployment (use --force to override)`));
    if (hotswapMode !== "full-deployment" /* FULL_DEPLOYMENT */) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(
        (0, import_util28.format)(
          `
 ${ICON} %s
`,
          chalk6.bold("hotswap deployment skipped - no changes were detected (use --force to override)")
        )
      ));
    }
    return {
      type: "did-deploy-stack",
      noOp: true,
      outputs: cloudFormationStack.outputs,
      stackArn: cloudFormationStack.stackId
    };
  } else {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: deploying...`));
  }
  const bodyParameter = await makeBodyParameter(
    ioHelper,
    stackArtifact,
    options.resolvedEnvironment,
    legacyAssets,
    options.envResources,
    options.overrideTemplate
  );
  let bootstrapStackName;
  try {
    bootstrapStackName = (await options.envResources.lookupToolkit()).stackName;
  } catch (e) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Could not determine the bootstrap stack name: ${e}`));
  }
  await publishAssets(legacyAssets.toManifest(stackArtifact.assembly.directory), options.sdkProvider, stackEnv, {
    parallel: options.assetParallelism,
    allowCrossAccount: await determineAllowCrossAccountAssetPublishing(options.sdk, ioHelper, bootstrapStackName)
  }, ioHelper);
  if (hotswapMode !== "full-deployment" /* FULL_DEPLOYMENT */) {
    try {
      const hotswapDeploymentResult = await tryHotswapDeployment(
        options.sdkProvider,
        ioHelper,
        stackParams.values,
        cloudFormationStack,
        stackArtifact,
        hotswapMode,
        hotswapPropertyOverrides
      );
      if (hotswapDeploymentResult) {
        return hotswapDeploymentResult;
      }
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util28.format)(
        "Could not perform a hotswap deployment, as the stack %s contains non-Asset changes",
        stackArtifact.displayName
      )));
    } catch (e) {
      if (!(e instanceof CfnEvaluationException)) {
        throw e;
      }
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util28.format)(
        "Could not perform a hotswap deployment, because the CloudFormation template could not be resolved: %s",
        formatErrorMessage(e)
      )));
    }
    if (hotswapMode === "fall-back" /* FALL_BACK */) {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg("Falling back to doing a full deployment"));
      options.sdk.appendCustomUserAgent("cdk-hotswap/fallback");
    } else {
      return {
        type: "did-deploy-stack",
        noOp: true,
        stackArn: cloudFormationStack.stackId,
        outputs: cloudFormationStack.outputs
      };
    }
  }
  const fullDeployment = new FullCloudFormationDeployment(
    options,
    cloudFormationStack,
    stackArtifact,
    stackParams,
    bodyParameter,
    ioHelper
  );
  return fullDeployment.performDeployment();
}
var FullCloudFormationDeployment = class {
  constructor(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter, ioHelper) {
    this.options = options;
    this.cloudFormationStack = cloudFormationStack;
    this.stackArtifact = stackArtifact;
    this.stackParams = stackParams;
    this.bodyParameter = bodyParameter;
    this.ioHelper = ioHelper;
    this.cfn = options.sdk.cloudFormation();
    this.stackName = options.deployName ?? stackArtifact.stackName;
    this.update = cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== "REVIEW_IN_PROGRESS";
    this.verb = this.update ? "update" : "create";
    this.uuid = uuid3.v4();
  }
  cfn;
  stackName;
  update;
  verb;
  uuid;
  async performDeployment() {
    const deploymentMethod = this.options.deploymentMethod ?? {
      method: "change-set"
    };
    if (deploymentMethod.method === "direct" && this.options.resourcesToImport) {
      throw new ToolkitError("Importing resources requires a changeset deployment");
    }
    switch (deploymentMethod.method) {
      case "change-set":
        return this.changeSetDeployment(deploymentMethod);
      case "direct":
        return this.directDeployment();
    }
  }
  async changeSetDeployment(deploymentMethod) {
    const changeSetName = deploymentMethod.changeSetName ?? "cdk-deploy-change-set";
    const execute = deploymentMethod.execute ?? true;
    const importExistingResources = deploymentMethod.importExistingResources ?? false;
    const changeSetDescription = await this.createChangeSet(changeSetName, execute, importExistingResources);
    await this.updateTerminationProtection();
    if (changeSetHasNoChanges(changeSetDescription)) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("No changes are to be performed on %s.", this.stackName)));
      if (execute) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("Deleting empty change set %s", changeSetDescription.ChangeSetId)));
        await this.cfn.deleteChangeSet({
          StackName: this.stackName,
          ChangeSetName: changeSetName
        });
      }
      if (this.options.forceDeployment) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          [
            "You used the --force flag, but CloudFormation reported that the deployment would not make any changes.",
            "According to CloudFormation, all resources are already up-to-date with the state in your CDK app.",
            "",
            "You cannot use the --force flag to get rid of changes you made in the console. Try using",
            "CloudFormation drift detection instead: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html"
          ].join("\n")
        ));
      }
      return {
        type: "did-deploy-stack",
        noOp: true,
        outputs: this.cloudFormationStack.outputs,
        stackArn: changeSetDescription.StackId
      };
    }
    if (!execute) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util28.format)(
        "Changeset %s created and waiting in review for manual execution (--no-execute)",
        changeSetDescription.ChangeSetId
      )));
      return {
        type: "did-deploy-stack",
        noOp: false,
        outputs: this.cloudFormationStack.outputs,
        stackArn: changeSetDescription.StackId
      };
    }
    const replacement = hasReplacement(changeSetDescription);
    const isPausedFailState = this.cloudFormationStack.stackStatus.isRollbackable;
    const rollback = this.options.rollback ?? true;
    if (isPausedFailState && replacement) {
      return { type: "failpaused-need-rollback-first", reason: "replacement", status: this.cloudFormationStack.stackStatus.name };
    }
    if (isPausedFailState && rollback) {
      return { type: "failpaused-need-rollback-first", reason: "not-norollback", status: this.cloudFormationStack.stackStatus.name };
    }
    if (!rollback && replacement) {
      return { type: "replacement-requires-rollback" };
    }
    return this.executeChangeSet(changeSetDescription);
  }
  async createChangeSet(changeSetName, willExecute, importExistingResources) {
    await this.cleanupOldChangeset(changeSetName);
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Attempting to create ChangeSet with name ${changeSetName} to ${this.verb} stack ${this.stackName}`));
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util28.format)("%s: creating CloudFormation changeset...", chalk6.bold(this.stackName))));
    const changeSet = await this.cfn.createChangeSet({
      StackName: this.stackName,
      ChangeSetName: changeSetName,
      ChangeSetType: this.options.resourcesToImport ? "IMPORT" : this.update ? "UPDATE" : "CREATE",
      ResourcesToImport: this.options.resourcesToImport,
      Description: `CDK Changeset for execution ${this.uuid}`,
      ClientToken: `create${this.uuid}`,
      ImportExistingResources: importExistingResources,
      ...this.commonPrepareOptions()
    });
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("Initiated creation of changeset: %s; waiting for it to finish creating...", changeSet.Id)));
    return waitForChangeSet(this.cfn, this.ioHelper, this.stackName, changeSetName, {
      fetchAll: willExecute
    });
  }
  async executeChangeSet(changeSet) {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("Initiating execution of changeset %s on stack %s", changeSet.ChangeSetId, this.stackName)));
    await this.cfn.executeChangeSet({
      StackName: this.stackName,
      ChangeSetName: changeSet.ChangeSetName,
      ClientRequestToken: `exec${this.uuid}`,
      ...this.commonExecuteOptions()
    });
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(
      (0, import_util28.format)(
        "Execution of changeset %s on stack %s has started; waiting for the update to complete...",
        changeSet.ChangeSetId,
        this.stackName
      )
    ));
    const changeSetLength = (changeSet.Changes ?? []).length + (this.update ? 1 : 0);
    return this.monitorDeployment(changeSet.CreationTime, changeSetLength);
  }
  async cleanupOldChangeset(changeSetName) {
    if (this.cloudFormationStack.exists) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Removing existing change set with name ${changeSetName} if it exists`));
      await this.cfn.deleteChangeSet({
        StackName: this.stackName,
        ChangeSetName: changeSetName
      });
    }
  }
  async updateTerminationProtection() {
    const terminationProtection = this.stackArtifact.terminationProtection ?? false;
    if (!!this.cloudFormationStack.terminationProtection !== terminationProtection) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(
        (0, import_util28.format)(
          "Updating termination protection from %s to %s for stack %s",
          this.cloudFormationStack.terminationProtection,
          terminationProtection,
          this.stackName
        )
      ));
      await this.cfn.updateTerminationProtection({
        StackName: this.stackName,
        EnableTerminationProtection: terminationProtection
      });
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("Termination protection updated to %s for stack %s", terminationProtection, this.stackName)));
    }
  }
  async directDeployment() {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util28.format)("%s: %s stack...", chalk6.bold(this.stackName), this.update ? "updating" : "creating")));
    const startTime = /* @__PURE__ */ new Date();
    if (this.update) {
      await this.updateTerminationProtection();
      try {
        await this.cfn.updateStack({
          StackName: this.stackName,
          ClientRequestToken: `update${this.uuid}`,
          ...this.commonPrepareOptions(),
          ...this.commonExecuteOptions()
        });
      } catch (err) {
        if (err.message === "No updates are to be performed.") {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("No updates are to be performed for stack %s", this.stackName)));
          return {
            type: "did-deploy-stack",
            noOp: true,
            outputs: this.cloudFormationStack.outputs,
            stackArn: this.cloudFormationStack.stackId
          };
        }
        throw err;
      }
      return this.monitorDeployment(startTime, void 0);
    } else {
      const terminationProtection = this.stackArtifact.terminationProtection ?? false;
      await this.cfn.createStack({
        StackName: this.stackName,
        ClientRequestToken: `create${this.uuid}`,
        ...terminationProtection ? { EnableTerminationProtection: true } : void 0,
        ...this.commonPrepareOptions(),
        ...this.commonExecuteOptions()
      });
      return this.monitorDeployment(startTime, void 0);
    }
  }
  async monitorDeployment(startTime, expectedChanges) {
    const monitor = new StackActivityMonitor({
      cfn: this.cfn,
      stack: this.stackArtifact,
      stackName: this.stackName,
      resourcesTotal: expectedChanges,
      ioHelper: this.ioHelper,
      changeSetCreationTime: startTime
    });
    await monitor.start();
    let finalState = this.cloudFormationStack;
    try {
      const successStack = await waitForStackDeploy(this.cfn, this.ioHelper, this.stackName);
      if (!successStack) {
        throw new ToolkitError("Stack deploy failed (the stack disappeared while we were deploying it)");
      }
      finalState = successStack;
    } catch (e) {
      throw new ToolkitError(suffixWithErrors(formatErrorMessage(e), monitor.errors));
    } finally {
      await monitor.stop();
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg((0, import_util28.format)("Stack %s has completed updating", this.stackName)));
    return {
      type: "did-deploy-stack",
      noOp: false,
      outputs: finalState.outputs,
      stackArn: finalState.stackId
    };
  }
  /**
   * Return the options that are shared between CreateStack, UpdateStack and CreateChangeSet
   */
  commonPrepareOptions() {
    return {
      Capabilities: ["CAPABILITY_IAM", "CAPABILITY_NAMED_IAM", "CAPABILITY_AUTO_EXPAND"],
      NotificationARNs: this.options.notificationArns,
      Parameters: this.stackParams.apiParameters,
      RoleARN: this.options.roleArn,
      TemplateBody: this.bodyParameter.TemplateBody,
      TemplateURL: this.bodyParameter.TemplateURL,
      Tags: this.options.tags
    };
  }
  /**
   * Return the options that are shared between UpdateStack and CreateChangeSet
   *
   * Be careful not to add in keys for options that aren't used, as the features may not have been
   * deployed everywhere yet.
   */
  commonExecuteOptions() {
    const shouldDisableRollback = this.options.rollback === false;
    return {
      StackName: this.stackName,
      ...shouldDisableRollback ? { DisableRollback: true } : void 0
    };
  }
};
async function destroyStack(options, ioHelper) {
  const deployName = options.deployName || options.stack.stackName;
  const cfn = options.sdk.cloudFormation();
  const currentStack = await CloudFormationStack.lookup(cfn, deployName);
  if (!currentStack.exists) {
    return {};
  }
  const monitor = new StackActivityMonitor({
    cfn,
    stack: options.stack,
    stackName: deployName,
    ioHelper
  });
  await monitor.start();
  try {
    await cfn.deleteStack({ StackName: deployName, RoleARN: options.roleArn });
    const destroyedStack = await waitForStackDelete(cfn, ioHelper, deployName);
    if (destroyedStack && destroyedStack.stackStatus.name !== "DELETE_COMPLETE") {
      throw new ToolkitError(`Failed to destroy ${deployName}: ${destroyedStack.stackStatus}`);
    }
    return { stackArn: currentStack.stackId };
  } catch (e) {
    throw new ToolkitError(suffixWithErrors(formatErrorMessage(e), monitor.errors));
  } finally {
    if (monitor) {
      await monitor.stop();
    }
  }
}
async function canSkipDeploy(deployStackOptions, cloudFormationStack, parameterChanges, ioHelper) {
  const deployName = deployStackOptions.deployName || deployStackOptions.stack.stackName;
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: checking if we can skip deploy`));
  if (deployStackOptions.forceDeployment) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: forced deployment`));
    return false;
  }
  if (deployStackOptions.deploymentMethod?.method === "change-set" && deployStackOptions.deploymentMethod.execute === false) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: --no-execute, always creating change set`));
    return false;
  }
  if (!cloudFormationStack.exists) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: no existing stack`));
    return false;
  }
  if (JSON.stringify(deployStackOptions.stack.template) !== JSON.stringify(await cloudFormationStack.template())) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: template has changed`));
    return false;
  }
  if (!compareTags(cloudFormationStack.tags, deployStackOptions.tags ?? [])) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: tags have changed`));
    return false;
  }
  if (!arrayEquals(cloudFormationStack.notificationArns, deployStackOptions.notificationArns ?? [])) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: notification arns have changed`));
    return false;
  }
  if (!!deployStackOptions.stack.terminationProtection !== !!cloudFormationStack.terminationProtection) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: termination protection has been updated`));
    return false;
  }
  if (parameterChanges) {
    if (parameterChanges === "ssm") {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: some parameters come from SSM so we have to assume they may have changed`));
    } else {
      await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: parameters have changed`));
    }
    return false;
  }
  if (cloudFormationStack.stackStatus.isFailure) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deployName}: stack is in a failure state`));
    return false;
  }
  return true;
}
function compareTags(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (const aTag of a) {
    const bTag = b.find((tag) => tag.Key === aTag.Key);
    if (!bTag || bTag.Value !== aTag.Value) {
      return false;
    }
  }
  return true;
}
function suffixWithErrors(msg, errors) {
  return errors && errors.length > 0 ? `${msg}: ${errors.join(", ")}` : msg;
}
function arrayEquals(a, b) {
  return a.every((item) => b.includes(item)) && b.every((item) => a.includes(item));
}
function hasReplacement(cs) {
  return (cs.Changes ?? []).some((c) => {
    const a = c.ResourceChange?.PolicyAction;
    return a === "ReplaceAndDelete" || a === "ReplaceAndRetain" || a === "ReplaceAndSnapshot";
  });
}

// ../tmp-toolkit-helpers/src/api/notices.ts
var https = __toESM(require("node:https"));
var path8 = __toESM(require("path"));
var fs9 = __toESM(require("fs-extra"));
var semver2 = __toESM(require("semver"));

// ../tmp-toolkit-helpers/src/api/tree.ts
var path7 = __toESM(require("node:path"));
var fs8 = __toESM(require("fs-extra"));
function some(node, predicate) {
  return node != null && (predicate(node) || findInChildren());
  function findInChildren() {
    return Object.values(node?.children ?? {}).some((child) => some(child, predicate));
  }
}
async function loadTree(assembly, trace2) {
  try {
    const outdir = assembly.directory;
    const fileName = assembly.tree()?.file;
    return fileName ? fs8.readJSONSync(path7.join(outdir, fileName)).tree : {};
  } catch (e) {
    await trace2(`Failed to get tree.json file: ${e}. Proceeding with empty tree.`);
    return void 0;
  }
}
function loadTreeFromDir(outdir, trace2) {
  try {
    return fs8.readJSONSync(path7.join(outdir, "tree.json")).tree;
  } catch (e) {
    trace2(`Failed to get tree.json file: ${e}. Proceeding with empty tree.`);
    return void 0;
  }
}

// ../tmp-toolkit-helpers/src/api/notices.ts
var CACHE_FILE_PATH = path8.join(cdkCacheDir(), "notices.json");
var NoticesFilter = class {
  constructor(ioMessages) {
    this.ioMessages = ioMessages;
  }
  filter(options) {
    const components = [
      ...this.constructTreeComponents(options.outDir),
      ...this.otherComponents(options)
    ];
    return this.findForNamedComponents(options.data, components);
  }
  /**
   * From a set of input options, return the notices components we are searching for
   */
  otherComponents(options) {
    return [
      // CLI
      {
        name: "cli",
        version: options.cliVersion
      },
      // Node version
      {
        name: "node",
        version: process.version.replace(/^v/, ""),
        // remove the 'v' prefix.
        dynamicName: "node"
      },
      // Bootstrap environments
      ...options.bootstrappedEnvironments.flatMap((env) => {
        const semverBootstrapVersion = semver2.coerce(env.bootstrapStackVersion);
        if (!semverBootstrapVersion) {
          this.ioMessages.warning(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
          return [];
        }
        return [{
          name: "bootstrap",
          version: `${semverBootstrapVersion}`,
          dynamicName: "ENVIRONMENTS",
          dynamicValue: env.environment.name
        }];
      })
    ];
  }
  /**
   * Based on a set of component names, find all notices that match one of the given components
   */
  findForNamedComponents(data, actualComponents) {
    return data.flatMap((notice) => {
      const ors = this.resolveAliases(normalizeComponents(notice.components));
      for (const ands of ors) {
        const matched = ands.map((affected) => actualComponents.filter((actual) => this.componentNameMatches(affected, actual) && semver2.satisfies(actual.version, affected.version, { includePrerelease: true })));
        if (matched.every((xs) => xs.length > 0)) {
          const ret = new FilteredNotice(notice);
          this.addDynamicValues(matched.flatMap((x) => x), ret);
          return [ret];
        }
      }
      return [];
    });
  }
  /**
   * Whether the given "affected component" name applies to the given actual component name.
   *
   * The name matches if the name is exactly the same, or the name in the notice
   * is a prefix of the node name when the query ends in '.'.
   */
  componentNameMatches(pattern, actual) {
    return pattern.name.endsWith(".") ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
  }
  /**
   * Adds dynamic values from the given ActualComponents
   *
   * If there are multiple components with the same dynamic name, they are joined
   * by a comma.
   */
  addDynamicValues(comps, notice) {
    const dynamicValues = {};
    for (const comp of comps) {
      if (comp.dynamicName) {
        dynamicValues[comp.dynamicName] = dynamicValues[comp.dynamicName] ?? [];
        dynamicValues[comp.dynamicName].push(comp.dynamicValue ?? comp.version);
      }
    }
    for (const [key, values] of Object.entries(dynamicValues)) {
      notice.addDynamicValue(key, values.join(","));
    }
  }
  /**
   * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
   *
   * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
   * arrays at the top level.
   */
  resolveAliases(ors) {
    return ors.flatMap((ands) => {
      const hasFramework = ands.find((c) => c.name === "framework");
      if (!hasFramework) {
        return [ands];
      }
      return [
        ands.map((c) => c.name === "framework" ? { ...c, name: "@aws-cdk/core." } : c),
        ands.map((c) => c.name === "framework" ? { ...c, name: "aws-cdk-lib." } : c)
      ];
    });
  }
  /**
   * Load the construct tree from the given directory and return its components
   */
  constructTreeComponents(manifestDir) {
    const tree = loadTreeFromDir(manifestDir, (msg) => void this.ioMessages.notify(IO.DEFAULT_ASSEMBLY_TRACE.msg(msg)));
    if (!tree) {
      return [];
    }
    const ret = [];
    recurse(tree);
    return ret;
    function recurse(x) {
      if (x.constructInfo?.fqn && x.constructInfo?.version) {
        ret.push({
          name: x.constructInfo?.fqn,
          version: x.constructInfo?.version
        });
      }
      for (const child of Object.values(x.children ?? {})) {
        recurse(child);
      }
    }
  }
};
var Notices = class _Notices {
  /**
   * Create an instance. Note that this replaces the singleton.
   */
  static create(props) {
    this._instance = new _Notices(props);
    return this._instance;
  }
  /**
   * Get the singleton instance. May return `undefined` if `create` has not been called.
   */
  static get() {
    return this._instance;
  }
  static _instance;
  context;
  output;
  acknowledgedIssueNumbers;
  includeAcknowlegded;
  httpOptions;
  ioHelper;
  ioMessages;
  cliVersion;
  data = /* @__PURE__ */ new Set();
  // sets don't deduplicate interfaces, so we use a map.
  bootstrappedEnvironments = /* @__PURE__ */ new Map();
  constructor(props) {
    this.context = props.context;
    this.acknowledgedIssueNumbers = new Set(this.context.get("acknowledged-issue-numbers") ?? []);
    this.includeAcknowlegded = props.includeAcknowledged ?? false;
    this.output = props.output ?? "cdk.out";
    this.httpOptions = props.httpOptions ?? {};
    this.ioHelper = asIoHelper(
      props.ioHost,
      "notices"
      /* forcing a CliAction to a ToolkitAction */
    );
    this.ioMessages = new IoDefaultMessages(this.ioHelper);
    this.cliVersion = props.cliVersion;
  }
  /**
   * Add a bootstrap information to filter on. Can have multiple values
   * in case of multi-environment deployments.
   */
  addBootstrappedEnvironment(bootstrapped) {
    const key = [
      bootstrapped.bootstrapStackVersion,
      bootstrapped.environment.account,
      bootstrapped.environment.region,
      bootstrapped.environment.name
    ].join(":");
    this.bootstrappedEnvironments.set(key, bootstrapped);
  }
  /**
   * Refresh the list of notices this instance is aware of.
   * To make sure this never crashes the CLI process, all failures are caught and
   * silently logged.
   *
   * If context is configured to not display notices, this will no-op.
   */
  async refresh(options = {}) {
    try {
      const underlyingDataSource = options.dataSource ?? new WebsiteNoticeDataSource(this.ioHelper, this.httpOptions);
      const dataSource = new CachedDataSource(this.ioMessages, CACHE_FILE_PATH, underlyingDataSource, options.force ?? false);
      const notices = await dataSource.fetch();
      this.data = new Set(this.includeAcknowlegded ? notices : notices.filter((n) => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
    } catch (e) {
      this.ioMessages.debug(`Could not refresh notices: ${e}`);
    }
  }
  /**
   * Display the relevant notices (unless context dictates we shouldn't).
   */
  display(options = {}) {
    const filteredNotices = new NoticesFilter(this.ioMessages).filter({
      data: Array.from(this.data),
      cliVersion: this.cliVersion,
      outDir: this.output,
      bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values())
    });
    if (filteredNotices.length > 0) {
      void this.ioMessages.notify(IO.CDK_TOOLKIT_I0100.msg([
        "",
        "NOTICES         (What's this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)",
        ""
      ].join("\n")));
      for (const filtered of filteredNotices) {
        const formatted = filtered.format() + "\n";
        switch (filtered.notice.severity) {
          case "warning":
            void this.ioMessages.notify(IO.CDK_TOOLKIT_W0101.msg(formatted));
            break;
          case "error":
            void this.ioMessages.notify(IO.CDK_TOOLKIT_E0101.msg(formatted));
            break;
          default:
            void this.ioMessages.notify(IO.CDK_TOOLKIT_I0101.msg(formatted));
            break;
        }
      }
      void this.ioMessages.notify(IO.CDK_TOOLKIT_I0100.msg(
        `If you don\u2019t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`
      ));
    }
    if (options.showTotal ?? false) {
      void this.ioMessages.notify(IO.CDK_TOOLKIT_I0100.msg(
        `
There are ${filteredNotices.length} unacknowledged notice(s).`
      ));
    }
  }
};
function normalizeComponents(xs) {
  return xs.map((x) => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
  return xs.map((c) => `${c.name}: ${c.version}`).join(" AND ");
}
var FilteredNotice = class {
  constructor(notice) {
    this.notice = notice;
  }
  dynamicValues = {};
  addDynamicValue(key, value) {
    this.dynamicValues[`{resolve:${key}}`] = value;
  }
  format() {
    const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(", ");
    return this.resolveDynamicValues([
      `${this.notice.issueNumber}	${this.notice.title}`,
      this.formatOverview(),
      `	Affected versions: ${componentsValue}`,
      `	More information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`
    ].join("\n\n") + "\n");
  }
  formatOverview() {
    const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, "$1\n");
    const heading = "Overview: ";
    const separator = `
	${" ".repeat(heading.length)}`;
    const content = wrap(this.notice.overview).split("\n").join(separator);
    return "	" + heading + content;
  }
  resolveDynamicValues(input) {
    const pattern = new RegExp(Object.keys(this.dynamicValues).join("|"), "g");
    return input.replace(pattern, (matched) => this.dynamicValues[matched] ?? matched);
  }
};
var WebsiteNoticeDataSource = class {
  constructor(ioHelper, options = {}) {
    this.ioHelper = ioHelper;
    this.options = options;
  }
  options;
  async fetch() {
    const timeout = 3e3;
    const options = {
      agent: await new ProxyAgentProvider(this.ioHelper).create(this.options)
    };
    const notices = await new Promise((resolve2, reject) => {
      let req;
      let timer = setTimeout(() => {
        if (req) {
          req.destroy(new ToolkitError("Request timed out"));
        }
      }, timeout);
      timer.unref();
      try {
        req = https.get(
          "https://cli.cdk.dev-tools.aws.dev/notices.json",
          options,
          (res) => {
            if (res.statusCode === 200) {
              res.setEncoding("utf8");
              let rawData = "";
              res.on("data", (chunk) => {
                rawData += chunk;
              });
              res.on("end", () => {
                try {
                  const data = JSON.parse(rawData).notices;
                  if (!data) {
                    throw new ToolkitError("'notices' key is missing");
                  }
                  resolve2(data ?? []);
                } catch (e) {
                  reject(new ToolkitError(`Failed to parse notices: ${formatErrorMessage(e)}`));
                }
              });
              res.on("error", (e) => {
                reject(new ToolkitError(`Failed to fetch notices: ${formatErrorMessage(e)}`));
              });
            } else {
              reject(new ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
            }
          }
        );
        req.on("error", reject);
      } catch (e) {
        reject(new ToolkitError(`HTTPS 'get' call threw an error: ${formatErrorMessage(e)}`));
      }
    });
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Notices refreshed"));
    return notices;
  }
};
var TIME_TO_LIVE_SUCCESS = 60 * 60 * 1e3;
var TIME_TO_LIVE_ERROR = 1 * 60 * 1e3;
var CachedDataSource = class {
  constructor(ioMessages, fileName, dataSource, skipCache) {
    this.ioMessages = ioMessages;
    this.fileName = fileName;
    this.dataSource = dataSource;
    this.skipCache = skipCache;
  }
  async fetch() {
    const cachedData = await this.load();
    const data = cachedData.notices;
    const expiration = cachedData.expiration ?? 0;
    if (Date.now() > expiration || this.skipCache) {
      const freshData = await this.fetchInner();
      await this.save(freshData);
      return freshData.notices;
    } else {
      this.ioMessages.debug(`Reading cached notices from ${this.fileName}`);
      return data;
    }
  }
  async fetchInner() {
    try {
      return {
        expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
        notices: await this.dataSource.fetch()
      };
    } catch (e) {
      this.ioMessages.debug(`Could not refresh notices: ${e}`);
      return {
        expiration: Date.now() + TIME_TO_LIVE_ERROR,
        notices: []
      };
    }
  }
  async load() {
    const defaultValue = {
      expiration: 0,
      notices: []
    };
    try {
      return fs9.existsSync(this.fileName) ? await fs9.readJSON(this.fileName) : defaultValue;
    } catch (e) {
      this.ioMessages.debug(`Failed to load notices from cache: ${e}`);
      return defaultValue;
    }
  }
  async save(cached2) {
    try {
      await fs9.writeJSON(this.fileName, cached2);
    } catch (e) {
      this.ioMessages.debug(`Failed to store notices in the cache: ${e}`);
    }
  }
};

// ../tmp-toolkit-helpers/src/api/toolkit-info.ts
var import_util31 = require("util");
var chalk7 = __toESM(require("chalk"));
var DEFAULT_TOOLKIT_STACK_NAME = "CDKToolkit";
var ToolkitInfo = class _ToolkitInfo {
  static determineName(overrideName) {
    return overrideName ?? DEFAULT_TOOLKIT_STACK_NAME;
  }
  static async lookup(environment, sdk, ioHelper, stackName) {
    const cfn = sdk.cloudFormation();
    stackName = _ToolkitInfo.determineName(stackName);
    try {
      const stack = await stabilizeStack(cfn, ioHelper, stackName);
      if (!stack) {
        await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(
          (0, import_util31.format)(
            "The environment %s doesn't have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.",
            environment.name,
            stackName,
            chalk7.blue(`cdk bootstrap "${environment.name}"`)
          )
        ));
        return _ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
      }
      if (stack.stackStatus.isCreationFailure) {
        await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(
          (0, import_util31.format)(
            "The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.",
            environment.name,
            stackName,
            chalk7.blue(`cdk bootstrap "${environment.name}"`)
          )
        ));
        return _ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
      }
      return new ExistingToolkitInfo(stack);
    } catch (e) {
      return _ToolkitInfo.bootstrapStackLookupError(stackName, e);
    }
  }
  static fromStack(stack) {
    return new ExistingToolkitInfo(stack);
  }
  static bootstrapStackNotFoundInfo(stackName) {
    return new BootstrapStackNotFoundInfo(
      stackName,
      "This deployment requires a bootstrap stack with a known name; pass '--toolkit-stack-name' or switch to using the 'DefaultStackSynthesizer' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)"
    );
  }
  static bootstrapStackLookupError(stackName, e) {
    return new BootstrapStackNotFoundInfo(
      stackName,
      `This deployment requires a bootstrap stack with a known name, but during its lookup the following error occurred: ${e}; pass '--toolkit-stack-name' or switch to using the 'DefaultStackSynthesizer' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`
    );
  }
  constructor() {
  }
};
var ExistingToolkitInfo = class extends ToolkitInfo {
  constructor(bootstrapStack) {
    super();
    this.bootstrapStack = bootstrapStack;
  }
  found = true;
  get bucketUrl() {
    return `https://${this.requireOutput(BUCKET_DOMAIN_NAME_OUTPUT)}`;
  }
  get bucketName() {
    return this.requireOutput(BUCKET_NAME_OUTPUT);
  }
  get repositoryName() {
    return this.requireOutput(REPOSITORY_NAME_OUTPUT);
  }
  get version() {
    return parseInt(this.bootstrapStack.outputs[BOOTSTRAP_VERSION_OUTPUT] ?? "0", 10);
  }
  get variant() {
    return this.bootstrapStack.parameters[BOOTSTRAP_VARIANT_PARAMETER] ?? DEFAULT_BOOTSTRAP_VARIANT;
  }
  get parameters() {
    return this.bootstrapStack.parameters ?? {};
  }
  get terminationProtection() {
    return this.bootstrapStack.terminationProtection ?? false;
  }
  get stackName() {
    return this.bootstrapStack.stackName;
  }
  /**
   * Prepare an ECR repository for uploading to using Docker
   *
   */
  requireOutput(output) {
    if (!(output in this.bootstrapStack.outputs)) {
      throw new ToolkitError(
        `The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`
      );
    }
    return this.bootstrapStack.outputs[output];
  }
};
var BootstrapStackNotFoundInfo = class extends ToolkitInfo {
  constructor(stackName, errorMessage) {
    super();
    this.stackName = stackName;
    this.errorMessage = errorMessage;
  }
  found = false;
  get bootstrapStack() {
    throw new ToolkitError(this.errorMessage);
  }
  get bucketUrl() {
    throw new ToolkitError(this.errorMessage);
  }
  get bucketName() {
    throw new ToolkitError(this.errorMessage);
  }
  get repositoryName() {
    throw new ToolkitError(this.errorMessage);
  }
  get version() {
    throw new ToolkitError(this.errorMessage);
  }
  get variant() {
    throw new ToolkitError(this.errorMessage);
  }
  prepareEcrRepository() {
    throw new ToolkitError(this.errorMessage);
  }
};

// ../tmp-toolkit-helpers/src/api/environment/environment-resources.ts
var EnvironmentResourcesRegistry = class {
  constructor(toolkitStackName) {
    this.toolkitStackName = toolkitStackName;
  }
  cache = /* @__PURE__ */ new Map();
  for(resolvedEnvironment, sdk, ioHelper) {
    const key = `${resolvedEnvironment.account}:${resolvedEnvironment.region}`;
    let envCache = this.cache.get(key);
    if (!envCache) {
      envCache = emptyCache();
      this.cache.set(key, envCache);
    }
    return new EnvironmentResources(resolvedEnvironment, sdk, ioHelper, envCache, this.toolkitStackName);
  }
};
var EnvironmentResources = class {
  constructor(environment, sdk, ioHelper, cache, toolkitStackName) {
    this.environment = environment;
    this.sdk = sdk;
    this.ioHelper = ioHelper;
    this.cache = cache;
    this.toolkitStackName = toolkitStackName;
  }
  /**
   * Look up the toolkit for a given environment, using a given SDK
   */
  async lookupToolkit() {
    if (!this.cache.toolkitInfo) {
      this.cache.toolkitInfo = await ToolkitInfo.lookup(this.environment, this.sdk, this.ioHelper, this.toolkitStackName);
    }
    return this.cache.toolkitInfo;
  }
  /**
   * Validate that the bootstrap stack version matches or exceeds the expected version
   *
   * Use the SSM parameter name to read the version number if given, otherwise use the version
   * discovered on the bootstrap stack.
   *
   * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
   * lookup again and again for every artifact.
   */
  async validateVersion(expectedVersion, ssmParameterName) {
    if (expectedVersion === void 0) {
      return;
    }
    const defExpectedVersion = expectedVersion;
    if (ssmParameterName !== void 0) {
      try {
        doValidate(await this.versionFromSsmParameter(ssmParameterName), this.environment);
        return;
      } catch (e) {
        if (e.name !== "AccessDeniedException") {
          throw e;
        }
        const bootstrapStack2 = await this.lookupToolkit();
        if (bootstrapStack2.found && bootstrapStack2.version < BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
            `Could not read SSM parameter ${ssmParameterName}: ${formatErrorMessage(e)}, falling back to version from ${bootstrapStack2}`
          ));
          doValidate(bootstrapStack2.version, this.environment);
          return;
        }
        throw new ToolkitError(
          `This CDK deployment requires bootstrap stack version '${expectedVersion}', but during the confirmation via SSM parameter ${ssmParameterName} the following error occurred: ${e}`
        );
      }
    }
    const bootstrapStack = await this.lookupToolkit();
    doValidate(bootstrapStack.version, this.environment);
    function doValidate(version, environment) {
      const notices = Notices.get();
      if (notices) {
        notices.addBootstrappedEnvironment({ bootstrapStackVersion: version, environment });
      }
      if (defExpectedVersion > version) {
        throw new ToolkitError(
          `This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`
        );
      }
    }
  }
  /**
   * Read a version from an SSM parameter, cached
   */
  async versionFromSsmParameter(parameterName) {
    const existing = this.cache.ssmParameters.get(parameterName);
    if (existing !== void 0) {
      return existing;
    }
    const ssm = this.sdk.ssm();
    try {
      const result2 = await ssm.getParameter({ Name: parameterName });
      const asNumber = parseInt(`${result2.Parameter?.Value}`, 10);
      if (isNaN(asNumber)) {
        throw new ToolkitError(`SSM parameter ${parameterName} not a number: ${result2.Parameter?.Value}`);
      }
      this.cache.ssmParameters.set(parameterName, asNumber);
      return asNumber;
    } catch (e) {
      if (e.name === "ParameterNotFound") {
        throw new ToolkitError(
          `SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run 'cdk bootstrap' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`
        );
      }
      throw e;
    }
  }
  async prepareEcrRepository(repositoryName) {
    if (!this.sdk) {
      throw new ToolkitError("ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository");
    }
    const ecr = this.sdk.ecr();
    try {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${repositoryName}: checking if ECR repository already exists`));
      const describeResponse = await ecr.describeRepositories({
        repositoryNames: [repositoryName]
      });
      const existingRepositoryUri = describeResponse.repositories[0]?.repositoryUri;
      if (existingRepositoryUri) {
        return { repositoryUri: existingRepositoryUri };
      }
    } catch (e) {
      if (e.name !== "RepositoryNotFoundException") {
        throw e;
      }
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${repositoryName}: creating ECR repository`));
    const assetTag = { Key: "awscdk:asset", Value: "true" };
    const response = await ecr.createRepository({
      repositoryName,
      tags: [assetTag]
    });
    const repositoryUri = response.repository?.repositoryUri;
    if (!repositoryUri) {
      throw new ToolkitError(`CreateRepository did not return a repository URI for ${repositoryUri}`);
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${repositoryName}: enable image scanning`));
    await ecr.putImageScanningConfiguration({
      repositoryName,
      imageScanningConfiguration: { scanOnPush: true }
    });
    return { repositoryUri };
  }
};
var NoBootstrapStackEnvironmentResources = class extends EnvironmentResources {
  constructor(environment, sdk, ioHelper) {
    super(environment, sdk, ioHelper, emptyCache());
  }
  /**
   * Look up the toolkit for a given environment, using a given SDK
   */
  async lookupToolkit() {
    throw new ToolkitError(
      "Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI."
    );
  }
};
function emptyCache() {
  return {
    ssmParameters: /* @__PURE__ */ new Map(),
    toolkitInfo: void 0
  };
}
var BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;

// ../tmp-toolkit-helpers/src/api/environment/placeholders.ts
var import_cx_api5 = require("@aws-cdk/cx-api");
async function replaceEnvPlaceholders(object, env, sdkProvider) {
  return import_cx_api5.EnvironmentPlaceholders.replaceAsync(object, {
    accountId: () => Promise.resolve(env.account),
    region: () => Promise.resolve(env.region),
    partition: async () => {
      return await sdkProvider.baseCredentialsPartition(env, 0 /* ForReading */) ?? "aws";
    }
  });
}

// ../tmp-toolkit-helpers/src/api/environment/environment-access.ts
var EnvironmentAccess = class {
  constructor(sdkProvider, toolkitStackName, ioHelper) {
    this.sdkProvider = sdkProvider;
    this.environmentResources = new EnvironmentResourcesRegistry(toolkitStackName);
    this.ioHelper = ioHelper;
  }
  sdkCache = /* @__PURE__ */ new Map();
  environmentResources;
  ioHelper;
  /**
   * Resolves the environment for a stack.
   */
  async resolveStackEnvironment(stack) {
    return this.sdkProvider.resolveEnvironment(stack.environment);
  }
  /**
   * Get an SDK to access the given stack's environment for stack operations
   *
   * Will ask plugins for readonly credentials if available, use the default
   * AWS credentials if not.
   *
   * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
   * policies to see what you can do with this role.
   */
  async accessStackForReadOnlyStackOperations(stack) {
    return this.accessStackForStackOperations(stack, 0 /* ForReading */);
  }
  /**
   * Get an SDK to access the given stack's environment for stack operations
   *
   * Will ask plugins for mutating credentials if available, use the default AWS
   * credentials if not.  The `mode` parameter is only used for querying
   * plugins.
   *
   * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
   * policies to see what you can do with this role.
   */
  async accessStackForMutableStackOperations(stack) {
    return this.accessStackForStackOperations(stack, 1 /* ForWriting */);
  }
  /**
   * Get an SDK to access the given stack's environment for environmental lookups
   *
   * Will use a plugin if available, use the default AWS credentials if not.
   * The `mode` parameter is only used for querying plugins.
   *
   * Will assume the lookup role if configured on the stack. Check the default `lookup-role`
   * policies to see what you can do with this role. It can generally read everything
   * in the account that does not require KMS access.
   *
   * ---
   *
   * For backwards compatibility reasons, there are some scenarios that are handled here:
   *
   *  1. The lookup role may not exist (it was added in bootstrap stack version 7). If so:
   *     a. Return the default credentials if the default credentials are for the stack account
   *        (you will notice this as `isFallbackCredentials=true`).
   *     b. Throw an error if the default credentials are not for the stack account.
   *
   *  2. The lookup role may not have the correct permissions (for example, ReadOnlyAccess was added in
   *     bootstrap stack version 8); the stack will have a minimum version number on it.
   *     a. If it does not we throw an error which should be handled in the calling
   *        function (and fallback to use a different role, etc)
   *
   * Upon success, caller will have an SDK for the right account, which may or may not have
   * the right permissions.
   */
  async accessStackForLookup(stack) {
    if (!stack.environment) {
      throw new ToolkitError(`The stack ${stack.displayName} does not have an environment`);
    }
    const lookupEnv = await this.prepareSdk({
      environment: stack.environment,
      mode: 0 /* ForReading */,
      assumeRoleArn: stack.lookupRole?.arn,
      assumeRoleExternalId: stack.lookupRole?.assumeRoleExternalId,
      assumeRoleAdditionalOptions: stack.lookupRole?.assumeRoleAdditionalOptions
    });
    if (lookupEnv.didAssumeRole && stack.lookupRole?.bootstrapStackVersionSsmParameter && stack.lookupRole.requiresBootstrapStackVersion) {
      const version = await lookupEnv.resources.versionFromSsmParameter(stack.lookupRole.bootstrapStackVersionSsmParameter);
      if (version < stack.lookupRole.requiresBootstrapStackVersion) {
        throw new ToolkitError(`Bootstrap stack version '${stack.lookupRole.requiresBootstrapStackVersion}' is required, found version '${version}'. To get rid of this error, please upgrade to bootstrap version >= ${stack.lookupRole.requiresBootstrapStackVersion}`);
      }
    }
    if (lookupEnv.isFallbackCredentials) {
      const arn = await lookupEnv.replacePlaceholders(stack.lookupRole?.arn);
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`Lookup role ${arn} was not assumed. Proceeding with default credentials.`));
    }
    return lookupEnv;
  }
  /**
   * Get an SDK to access the given stack's environment for reading stack attributes
   *
   * Will use a plugin if available, use the default AWS credentials if not.
   * The `mode` parameter is only used for querying plugins.
   *
   * Will try to assume the lookup role if given, will use the regular stack operations
   * access (deploy-role) otherwise. When calling this, you should assume that you will get
   * the least privileged role, so don't try to use it for anything the `deploy-role`
   * wouldn't be able to do. Also you cannot rely on being able to read encrypted anything.
   */
  async accessStackForLookupBestEffort(stack) {
    if (!stack.environment) {
      throw new ToolkitError(`The stack ${stack.displayName} does not have an environment`);
    }
    try {
      return await this.accessStackForLookup(stack);
    } catch (e) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`${formatErrorMessage(e)}`));
    }
    return this.accessStackForStackOperations(stack, 0 /* ForReading */);
  }
  /**
   * Get an SDK to access the given stack's environment for stack operations
   *
   * Will use a plugin if available, use the default AWS credentials if not.
   * The `mode` parameter is only used for querying plugins.
   *
   * Will assume the deploy role if configured on the stack. Check the default `deploy-role`
   * policies to see what you can do with this role.
   */
  async accessStackForStackOperations(stack, mode) {
    if (!stack.environment) {
      throw new ToolkitError(`The stack ${stack.displayName} does not have an environment`);
    }
    return this.prepareSdk({
      environment: stack.environment,
      mode,
      assumeRoleArn: stack.assumeRoleArn,
      assumeRoleExternalId: stack.assumeRoleExternalId,
      assumeRoleAdditionalOptions: stack.assumeRoleAdditionalOptions
    });
  }
  /**
   * Prepare an SDK for use in the given environment and optionally with a role assumed.
   */
  async prepareSdk(options) {
    const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(options.environment);
    const { assumeRoleArn } = await replaceEnvPlaceholders({
      assumeRoleArn: options.assumeRoleArn
    }, resolvedEnvironment, this.sdkProvider);
    const stackSdk = await this.cachedSdkForEnvironment(resolvedEnvironment, options.mode, {
      assumeRoleArn,
      assumeRoleExternalId: options.assumeRoleExternalId,
      assumeRoleAdditionalOptions: options.assumeRoleAdditionalOptions
    });
    return {
      sdk: stackSdk.sdk,
      resolvedEnvironment,
      resources: this.environmentResources.for(resolvedEnvironment, stackSdk.sdk, this.ioHelper),
      // If we asked for a role, did not successfully assume it, and yet got here without an exception: that
      // means we must have fallback credentials.
      isFallbackCredentials: !stackSdk.didAssumeRole && !!assumeRoleArn,
      didAssumeRole: stackSdk.didAssumeRole,
      replacePlaceholders: async (str) => {
        const ret = await replaceEnvPlaceholders({ str }, resolvedEnvironment, this.sdkProvider);
        return ret.str;
      }
    };
  }
  async cachedSdkForEnvironment(environment, mode, options) {
    const cacheKeyElements = [
      environment.account,
      environment.region,
      `${mode}`,
      options?.assumeRoleArn ?? "",
      options?.assumeRoleExternalId ?? ""
    ];
    if (options?.assumeRoleAdditionalOptions) {
      cacheKeyElements.push(JSON.stringify(options.assumeRoleAdditionalOptions));
    }
    const cacheKey = cacheKeyElements.join(":");
    const existing = this.sdkCache.get(cacheKey);
    if (existing) {
      return existing;
    }
    const ret = await this.sdkProvider.forEnvironment(environment, mode, options);
    this.sdkCache.set(cacheKey, ret);
    return ret;
  }
};

// ../tmp-toolkit-helpers/src/api/deployments/deployments.ts
var BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK = 23;
var Deployments = class {
  constructor(props) {
    this.props = props;
    this.assetSdkProvider = props.sdkProvider;
    this.deployStackSdkProvider = props.sdkProvider;
    this.ioHelper = props.ioHelper;
    this.envs = new EnvironmentAccess(
      props.sdkProvider,
      props.toolkitStackName ?? DEFAULT_TOOLKIT_STACK_NAME,
      this.ioHelper
    );
  }
  envs;
  /**
   * SDK provider for asset publishing (do not use for anything else).
   *
   * This SDK provider is only allowed to be used for that purpose, nothing else.
   *
   * It's not a different object, but the field name should imply that this
   * object should not be used directly, except to pass to asset handling routines.
   */
  assetSdkProvider;
  /**
   * SDK provider for passing to deployStack
   *
   * This SDK provider is only allowed to be used for that purpose, nothing else.
   *
   * It's not a different object, but the field name should imply that this
   * object should not be used directly, except to pass to `deployStack`.
   */
  deployStackSdkProvider;
  publisherCache = /* @__PURE__ */ new Map();
  _allowCrossAccountAssetPublishing;
  ioHelper;
  /**
   * Resolves the environment for a stack.
   */
  async resolveEnvironment(stack) {
    return this.envs.resolveStackEnvironment(stack);
  }
  async readCurrentTemplateWithNestedStacks(rootStackArtifact, retrieveProcessedTemplate = false) {
    const env = await this.envs.accessStackForLookupBestEffort(rootStackArtifact);
    return loadCurrentTemplateWithNestedStacks(rootStackArtifact, env.sdk, retrieveProcessedTemplate);
  }
  async readCurrentTemplate(stackArtifact) {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Reading existing template for stack ${stackArtifact.displayName}.`));
    const env = await this.envs.accessStackForLookupBestEffort(stackArtifact);
    return loadCurrentTemplate(stackArtifact, env.sdk);
  }
  async resourceIdentifierSummaries(stackArtifact) {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Retrieving template summary for stack ${stackArtifact.displayName}.`));
    const env = await this.envs.accessStackForReadOnlyStackOperations(stackArtifact);
    const cfn = env.sdk.cloudFormation();
    await uploadStackTemplateAssets(stackArtifact, this);
    const builder = new AssetManifestBuilder();
    const cfnParam = await makeBodyParameter(
      this.ioHelper,
      stackArtifact,
      env.resolvedEnvironment,
      builder,
      env.resources
    );
    const addedAssets = builder.toManifest(stackArtifact.assembly.directory);
    for (const entry of addedAssets.entries) {
      await this.buildSingleAsset("no-version-validation", addedAssets, entry, {
        stack: stackArtifact
      });
      await this.publishSingleAsset(addedAssets, entry, {
        stack: stackArtifact
      });
    }
    const response = await cfn.getTemplateSummary(cfnParam);
    if (!response.ResourceIdentifierSummaries) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg('GetTemplateSummary API call did not return "ResourceIdentifierSummaries"'));
    }
    return response.ResourceIdentifierSummaries ?? [];
  }
  async deployStack(options) {
    let deploymentMethod = options.deploymentMethod;
    if (options.changeSetName || options.execute !== void 0) {
      if (deploymentMethod) {
        throw new ToolkitError(
          "You cannot supply both 'deploymentMethod' and 'changeSetName/execute'. Supply one or the other."
        );
      }
      deploymentMethod = {
        method: "change-set",
        changeSetName: options.changeSetName,
        execute: options.execute
      };
    }
    const env = await this.envs.accessStackForMutableStackOperations(options.stack);
    await this.validateBootstrapStackVersion(
      options.stack.stackName,
      options.stack.requiresBootstrapStackVersion,
      options.stack.bootstrapStackVersionSsmParameter,
      env.resources
    );
    const executionRoleArn = await env.replacePlaceholders(options.roleArn ?? options.stack.cloudFormationExecutionRoleArn);
    return deployStack({
      stack: options.stack,
      resolvedEnvironment: env.resolvedEnvironment,
      deployName: options.deployName,
      notificationArns: options.notificationArns,
      sdk: env.sdk,
      sdkProvider: this.deployStackSdkProvider,
      roleArn: executionRoleArn,
      reuseAssets: options.reuseAssets,
      envResources: env.resources,
      tags: options.tags,
      deploymentMethod,
      forceDeployment: options.forceDeployment,
      parameters: options.parameters,
      usePreviousParameters: options.usePreviousParameters,
      rollback: options.rollback,
      hotswap: options.hotswap,
      hotswapPropertyOverrides: options.hotswapPropertyOverrides,
      extraUserAgent: options.extraUserAgent,
      resourcesToImport: options.resourcesToImport,
      overrideTemplate: options.overrideTemplate,
      assetParallelism: options.assetParallelism
    }, this.ioHelper);
  }
  async rollbackStack(options) {
    let resourcesToSkip = options.orphanLogicalIds ?? [];
    if (options.orphanFailedResources && resourcesToSkip.length > 0) {
      throw new ToolkitError("Cannot combine --force with --orphan");
    }
    const env = await this.envs.accessStackForMutableStackOperations(options.stack);
    if (options.validateBootstrapStackVersion ?? true) {
      await this.validateBootstrapStackVersion(
        options.stack.stackName,
        BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK,
        options.stack.bootstrapStackVersionSsmParameter,
        env.resources
      );
    }
    const cfn = env.sdk.cloudFormation();
    const deployName = options.stack.stackName;
    let maxLoops = 10;
    while (maxLoops--) {
      const cloudFormationStack = await CloudFormationStack.lookup(cfn, deployName);
      const stackArn = cloudFormationStack.stackId;
      const executionRoleArn = await env.replacePlaceholders(options.roleArn ?? options.stack.cloudFormationExecutionRoleArn);
      switch (cloudFormationStack.stackStatus.rollbackChoice) {
        case 3 /* NONE */:
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`Stack ${deployName} does not need a rollback: ${cloudFormationStack.stackStatus}`));
          return { stackArn: cloudFormationStack.stackId, notInRollbackableState: true };
        case 0 /* START_ROLLBACK */:
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Initiating rollback of stack ${deployName}`));
          await cfn.rollbackStack({
            StackName: deployName,
            RoleARN: executionRoleArn,
            ClientRequestToken: (0, import_crypto.randomUUID)(),
            // Enabling this is just the better overall default, the only reason it isn't the upstream default is backwards compatibility
            RetainExceptOnCreate: true
          });
          break;
        case 1 /* CONTINUE_UPDATE_ROLLBACK */:
          if (options.orphanFailedResources) {
            const poller = new StackEventPoller(cfn, {
              stackName: deployName,
              stackStatuses: ["ROLLBACK_IN_PROGRESS", "UPDATE_ROLLBACK_IN_PROGRESS"]
            });
            await poller.poll();
            resourcesToSkip = poller.resourceErrors.filter((r) => !r.isStackEvent && r.parentStackLogicalIds.length === 0).map((r) => r.event.LogicalResourceId ?? "");
          }
          const skipDescription = resourcesToSkip.length > 0 ? ` (orphaning: ${resourcesToSkip.join(", ")})` : "";
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`Continuing rollback of stack ${deployName}${skipDescription}`));
          await cfn.continueUpdateRollback({
            StackName: deployName,
            ClientRequestToken: (0, import_crypto.randomUUID)(),
            RoleARN: executionRoleArn,
            ResourcesToSkip: resourcesToSkip
          });
          break;
        case 2 /* ROLLBACK_FAILED */:
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
            `Stack ${deployName} failed creation and rollback. This state cannot be rolled back. You can recreate this stack by running 'cdk deploy'.`
          ));
          return { stackArn, notInRollbackableState: true };
        default:
          throw new ToolkitError(`Unexpected rollback choice: ${cloudFormationStack.stackStatus.rollbackChoice}`);
      }
      const monitor = new StackActivityMonitor({
        cfn,
        stack: options.stack,
        stackName: deployName,
        ioHelper: this.ioHelper
      });
      await monitor.start();
      let stackErrorMessage = void 0;
      let finalStackState = cloudFormationStack;
      try {
        const successStack = await stabilizeStack(cfn, this.ioHelper, deployName);
        if (!successStack) {
          throw new ToolkitError("Stack deploy failed (the stack disappeared while we were rolling it back)");
        }
        finalStackState = successStack;
        const errors = monitor.errors.join(", ");
        if (errors) {
          stackErrorMessage = errors;
        }
      } catch (e) {
        stackErrorMessage = suffixWithErrors2(formatErrorMessage(e), monitor.errors);
      } finally {
        await monitor.stop();
      }
      if (finalStackState.stackStatus.isRollbackSuccess || !stackErrorMessage) {
        return { stackArn, success: true };
      }
      if (finalStackState.stackStatus.rollbackChoice === 1 /* CONTINUE_UPDATE_ROLLBACK */ && options.orphanFailedResources) {
        continue;
      }
      throw new ToolkitError(
        `${stackErrorMessage} (fix problem and retry, or orphan these resources using --orphan or --force)`
      );
    }
    throw new ToolkitError(
      "Rollback did not finish after a large number of iterations; stopping because it looks like we're not making progress anymore. You can retry if rollback was progressing as expected."
    );
  }
  async destroyStack(options) {
    const env = await this.envs.accessStackForMutableStackOperations(options.stack);
    const executionRoleArn = await env.replacePlaceholders(options.roleArn ?? options.stack.cloudFormationExecutionRoleArn);
    return destroyStack({
      sdk: env.sdk,
      roleArn: executionRoleArn,
      stack: options.stack,
      deployName: options.deployName
    }, this.ioHelper);
  }
  async stackExists(options) {
    let env;
    if (options.tryLookupRole) {
      env = await this.envs.accessStackForLookupBestEffort(options.stack);
    } else {
      env = await this.envs.accessStackForReadOnlyStackOperations(options.stack);
    }
    const stack = await CloudFormationStack.lookup(env.sdk.cloudFormation(), options.deployName ?? options.stack.stackName);
    return stack.exists;
  }
  /**
   * Build a single asset from an asset manifest
   *
   * If an assert manifest artifact is given, the bootstrap stack version
   * will be validated according to the constraints in that manifest artifact.
   * If that is not necessary, `'no-version-validation'` can be passed.
   */
  // eslint-disable-next-line max-len
  async buildSingleAsset(assetArtifact, assetManifest, asset, options) {
    if (assetArtifact !== "no-version-validation") {
      const env = await this.envs.accessStackForReadOnlyStackOperations(options.stack);
      await this.validateBootstrapStackVersion(
        options.stack.stackName,
        assetArtifact.requiresBootstrapStackVersion,
        assetArtifact.bootstrapStackVersionSsmParameter,
        env.resources
      );
    }
    const resolvedEnvironment = await this.envs.resolveStackEnvironment(options.stack);
    const publisher = this.cachedPublisher(assetManifest, resolvedEnvironment, options.stackName);
    await publisher.buildEntry(asset);
    if (publisher.hasFailures) {
      throw new ToolkitError(`Failed to build asset ${asset.displayName(false)}`);
    }
  }
  /**
   * Publish a single asset from an asset manifest
   */
  async publishSingleAsset(assetManifest, asset, options) {
    const stackEnv = await this.envs.resolveStackEnvironment(options.stack);
    const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
    await publisher.publishEntry(asset, {
      allowCrossAccount: await this.allowCrossAccountAssetPublishingForEnv(options.stack),
      force: options.forcePublish
    });
    if (publisher.hasFailures) {
      throw new ToolkitError(`Failed to publish asset ${asset.displayName(true)}`);
    }
  }
  async allowCrossAccountAssetPublishingForEnv(stack) {
    if (this._allowCrossAccountAssetPublishing === void 0) {
      const env = await this.envs.accessStackForReadOnlyStackOperations(stack);
      this._allowCrossAccountAssetPublishing = await determineAllowCrossAccountAssetPublishing(env.sdk, this.ioHelper, this.props.toolkitStackName);
    }
    return this._allowCrossAccountAssetPublishing;
  }
  /**
   * Return whether a single asset has been published already
   */
  async isSingleAssetPublished(assetManifest, asset, options) {
    const stackEnv = await this.envs.resolveStackEnvironment(options.stack);
    const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
    return publisher.isEntryPublished(asset);
  }
  /**
   * Validate that the bootstrap stack has the right version for this stack
   *
   * Call into envResources.validateVersion, but prepend the stack name in case of failure.
   */
  async validateBootstrapStackVersion(stackName, requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter, envResources) {
    try {
      await envResources.validateVersion(requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter);
    } catch (e) {
      throw new ToolkitError(`${stackName}: ${formatErrorMessage(e)}`);
    }
  }
  cachedPublisher(assetManifest, env, stackName) {
    const existing = this.publisherCache.get(assetManifest);
    if (existing) {
      return existing;
    }
    const prefix = stackName ? `${chalk8.bold(stackName)}: ` : "";
    const publisher = new cdk_assets.AssetPublishing(assetManifest, {
      // The AssetPublishing class takes care of role assuming etc, so it's okay to
      // give it a direct `SdkProvider`.
      aws: new PublishingAws(this.assetSdkProvider, env),
      progressListener: new ParallelSafeAssetProgress(prefix, this.ioHelper)
    });
    this.publisherCache.set(assetManifest, publisher);
    return publisher;
  }
};
var ParallelSafeAssetProgress = class extends BasePublishProgressListener {
  prefix;
  constructor(prefix, ioHelper) {
    super(ioHelper);
    this.prefix = prefix;
  }
  getMessage(type, event) {
    return `${this.prefix}${type}: ${event.message}`;
  }
};
function suffixWithErrors2(msg, errors) {
  return errors && errors.length > 0 ? `${msg}: ${errors.join(", ")}` : msg;
}

// ../tmp-toolkit-helpers/src/api/bootstrap/deploy-bootstrap.ts
var BootstrapStack = class _BootstrapStack {
  constructor(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo, ioHelper) {
    this.sdkProvider = sdkProvider;
    this.sdk = sdk;
    this.resolvedEnvironment = resolvedEnvironment;
    this.toolkitStackName = toolkitStackName;
    this.currentToolkitInfo = currentToolkitInfo;
    this.ioHelper = ioHelper;
  }
  static async lookup(sdkProvider, environment, toolkitStackName, ioHelper) {
    toolkitStackName = toolkitStackName ?? DEFAULT_TOOLKIT_STACK_NAME;
    const resolvedEnvironment = await sdkProvider.resolveEnvironment(environment);
    const sdk = (await sdkProvider.forEnvironment(resolvedEnvironment, 1 /* ForWriting */)).sdk;
    const currentToolkitInfo = await ToolkitInfo.lookup(resolvedEnvironment, sdk, ioHelper, toolkitStackName);
    return new _BootstrapStack(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo, ioHelper);
  }
  get parameters() {
    return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.parameters : {};
  }
  get terminationProtection() {
    return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.terminationProtection : void 0;
  }
  async partition() {
    return (await this.sdk.currentAccount()).partition;
  }
  /**
   * Perform the actual deployment of a bootstrap stack, given a template and some parameters
   */
  async update(template, parameters, options) {
    if (this.currentToolkitInfo.found && !options.forceDeployment) {
      const abortResponse = {
        type: "did-deploy-stack",
        noOp: true,
        outputs: {},
        stackArn: this.currentToolkitInfo.bootstrapStack.stackId
      };
      const currentVariant = this.currentToolkitInfo.variant;
      const newVariant = bootstrapVariantFromTemplate(template);
      if (currentVariant !== newVariant) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          `Bootstrap stack already exists, containing '${currentVariant}'. Not overwriting it with a template containing '${newVariant}' (use --force if you intend to overwrite)`
        ));
        return abortResponse;
      }
      const newVersion = bootstrapVersionFromTemplate(template);
      const currentVersion = this.currentToolkitInfo.version;
      if (newVersion < currentVersion) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          `Bootstrap stack already at version ${currentVersion}. Not downgrading it to version ${newVersion} (use --force if you intend to downgrade)`
        ));
        if (newVersion === 0) {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
            "(Did you set the '@aws-cdk/core:newStyleStackSynthesis' feature flag in cdk.json?)"
          ));
        }
        return abortResponse;
      }
    }
    const outdir = await fs10.mkdtemp(path9.join(os3.tmpdir(), "cdk-bootstrap"));
    const builder = new import_cx_api6.CloudAssemblyBuilder(outdir);
    const templateFile = `${this.toolkitStackName}.template.json`;
    await fs10.writeJson(path9.join(builder.outdir, templateFile), template, {
      spaces: 2
    });
    builder.addArtifact(this.toolkitStackName, {
      type: import_cloud_assembly_schema2.ArtifactType.AWS_CLOUDFORMATION_STACK,
      environment: import_cx_api6.EnvironmentUtils.format(this.resolvedEnvironment.account, this.resolvedEnvironment.region),
      properties: {
        templateFile,
        terminationProtection: options.terminationProtection ?? false
      }
    });
    const assembly = builder.buildAssembly();
    const ret = await deployStack({
      stack: assembly.getStackByName(this.toolkitStackName),
      resolvedEnvironment: this.resolvedEnvironment,
      sdk: this.sdk,
      sdkProvider: this.sdkProvider,
      forceDeployment: options.forceDeployment,
      roleArn: options.roleArn,
      tags: options.tags,
      deploymentMethod: { method: "change-set", execute: options.execute },
      parameters,
      usePreviousParameters: options.usePreviousParameters ?? true,
      // Obviously we can't need a bootstrap stack to deploy a bootstrap stack
      envResources: new NoBootstrapStackEnvironmentResources(this.resolvedEnvironment, this.sdk, this.ioHelper)
    }, this.ioHelper);
    assertIsSuccessfulDeployStackResult(ret);
    return ret;
  }
};
function bootstrapVersionFromTemplate(template) {
  const versionSources = [
    template.Outputs?.[BOOTSTRAP_VERSION_OUTPUT]?.Value,
    template.Resources?.[BOOTSTRAP_VERSION_RESOURCE]?.Properties?.Value
  ];
  for (const vs of versionSources) {
    if (typeof vs === "number") {
      return vs;
    }
    if (typeof vs === "string" && !isNaN(parseInt(vs, 10))) {
      return parseInt(vs, 10);
    }
  }
  return 0;
}
function bootstrapVariantFromTemplate(template) {
  return template.Parameters?.[BOOTSTRAP_VARIANT_PARAMETER]?.Default ?? DEFAULT_BOOTSTRAP_VARIANT;
}

// ../tmp-toolkit-helpers/src/api/bootstrap/legacy-template.ts
function legacyBootstrapTemplate(params) {
  return {
    Description: "The CDK Toolkit Stack. It was created by `cdk bootstrap` and manages resources necessary for managing your Cloud Applications with AWS CDK.",
    Conditions: {
      UsePublicAccessBlockConfiguration: {
        "Fn::Equals": [
          params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === void 0 ? "true" : "false",
          "true"
        ]
      }
    },
    Resources: {
      StagingBucket: {
        Type: "AWS::S3::Bucket",
        Properties: {
          BucketName: params.bucketName,
          AccessControl: "Private",
          BucketEncryption: {
            ServerSideEncryptionConfiguration: [{
              ServerSideEncryptionByDefault: {
                SSEAlgorithm: "aws:kms",
                KMSMasterKeyID: params.kmsKeyId
              }
            }]
          },
          PublicAccessBlockConfiguration: {
            "Fn::If": [
              "UsePublicAccessBlockConfiguration",
              {
                BlockPublicAcls: true,
                BlockPublicPolicy: true,
                IgnorePublicAcls: true,
                RestrictPublicBuckets: true
              },
              { Ref: "AWS::NoValue" }
            ]
          }
        }
      },
      StagingBucketPolicy: {
        Type: "AWS::S3::BucketPolicy",
        Properties: {
          Bucket: { Ref: "StagingBucket" },
          PolicyDocument: {
            Id: "AccessControl",
            Version: "2012-10-17",
            Statement: [
              {
                Sid: "AllowSSLRequestsOnly",
                Action: "s3:*",
                Effect: "Deny",
                Resource: [
                  { "Fn::Sub": "${StagingBucket.Arn}" },
                  { "Fn::Sub": "${StagingBucket.Arn}/*" }
                ],
                Condition: {
                  Bool: { "aws:SecureTransport": "false" }
                },
                Principal: "*"
              }
            ]
          }
        }
      }
    },
    Outputs: {
      [BUCKET_NAME_OUTPUT]: {
        Description: "The name of the S3 bucket owned by the CDK toolkit stack",
        Value: { Ref: "StagingBucket" }
      },
      [BUCKET_DOMAIN_NAME_OUTPUT]: {
        Description: "The domain name of the S3 bucket owned by the CDK toolkit stack",
        Value: { "Fn::GetAtt": ["StagingBucket", "RegionalDomainName"] }
      }
    }
  };
}

// ../tmp-toolkit-helpers/src/api/bootstrap/bootstrap-environment.ts
var Bootstrapper = class {
  constructor(source = { source: "default" }, ioHelper) {
    this.source = source;
    this.ioHelper = ioHelper;
  }
  ioHelper;
  bootstrapEnvironment(environment, sdkProvider, options = {}) {
    switch (this.source.source) {
      case "legacy":
        return this.legacyBootstrap(environment, sdkProvider, options);
      case "default":
        return this.modernBootstrap(environment, sdkProvider, options);
      case "custom":
        return this.customBootstrap(environment, sdkProvider, options);
    }
  }
  async showTemplate(json) {
    const template = await this.loadTemplate();
    process.stdout.write(`${serializeStructure(template, json)}
`);
  }
  /**
   * Deploy legacy bootstrap stack
   *
   */
  async legacyBootstrap(environment, sdkProvider, options = {}) {
    const params = options.parameters ?? {};
    if (params.trustedAccounts?.length) {
      throw new ToolkitError("--trust can only be passed for the modern bootstrap experience.");
    }
    if (params.cloudFormationExecutionPolicies?.length) {
      throw new ToolkitError("--cloudformation-execution-policies can only be passed for the modern bootstrap experience.");
    }
    if (params.createCustomerMasterKey !== void 0) {
      throw new ToolkitError("--bootstrap-customer-key can only be passed for the modern bootstrap experience.");
    }
    if (params.qualifier) {
      throw new ToolkitError("--qualifier can only be passed for the modern bootstrap experience.");
    }
    const toolkitStackName = options.toolkitStackName ?? DEFAULT_TOOLKIT_STACK_NAME;
    const current = await BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
    return current.update(
      await this.loadTemplate(params),
      {},
      {
        ...options,
        terminationProtection: options.terminationProtection ?? current.terminationProtection
      }
    );
  }
  /**
   * Deploy CI/CD-ready bootstrap stack from template
   *
   */
  async modernBootstrap(environment, sdkProvider, options = {}) {
    const params = options.parameters ?? {};
    const bootstrapTemplate = await this.loadTemplate();
    const toolkitStackName = options.toolkitStackName ?? DEFAULT_TOOLKIT_STACK_NAME;
    const current = await BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.ioHelper);
    const partition2 = await current.partition();
    if (params.createCustomerMasterKey !== void 0 && params.kmsKeyId) {
      throw new ToolkitError(
        "You cannot pass '--bootstrap-kms-key-id' and '--bootstrap-customer-key' together. Specify one or the other"
      );
    }
    const allTrusted = /* @__PURE__ */ new Set([
      ...params.trustedAccounts ?? [],
      ...params.trustedAccountsForLookup ?? []
    ]);
    const invalid = intersection(allTrusted, new Set(params.untrustedAccounts));
    if (invalid.size > 0) {
      throw new ToolkitError(`Accounts cannot be both trusted and untrusted. Found: ${[...invalid].join(",")}`);
    }
    const removeUntrusted = (accounts) => accounts.filter((acc) => !params.untrustedAccounts?.map(String).includes(String(acc)));
    const trustedAccounts = removeUntrusted(params.trustedAccounts ?? splitCfnArray(current.parameters.TrustedAccounts));
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(
      `Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(", ") : "(none)"}`
    ));
    const trustedAccountsForLookup = removeUntrusted(
      params.trustedAccountsForLookup ?? splitCfnArray(current.parameters.TrustedAccountsForLookup)
    );
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(
      `Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(", ") : "(none)"}`
    ));
    const cloudFormationExecutionPolicies = params.cloudFormationExecutionPolicies ?? splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
    if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
      const implicitPolicy = `arn:${partition2}:iam::aws:policy/AdministratorAccess`;
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
        `Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`
      ));
    } else if (cloudFormationExecutionPolicies.length === 0) {
      throw new ToolkitError(
        `Please pass '--cloudformation-execution-policies' when using '--trust' to specify deployment permissions. Try a managed policy of the form 'arn:${partition2}:iam::aws:policy/<PolicyName>'.`
      );
    } else {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(`Execution policies: ${cloudFormationExecutionPolicies.join(", ")}`));
    }
    const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
    const kmsKeyId = params.kmsKeyId ?? (params.createCustomerMasterKey === true ? CREATE_NEW_KEY : params.createCustomerMasterKey === false || currentKmsKeyId === void 0 ? USE_AWS_MANAGED_KEY : void 0);
    const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary || void 0;
    const inputPolicyName = params.examplePermissionsBoundary ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY : params.customPermissionsBoundary;
    let policyName;
    if (inputPolicyName) {
      const sdk = (await sdkProvider.forEnvironment(environment, 1 /* ForWriting */)).sdk;
      policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition2, params);
    }
    if (currentPermissionsBoundary !== policyName) {
      if (!currentPermissionsBoundary) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          `Adding new permissions boundary ${policyName}`
        ));
      } else if (!policyName) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          `Removing existing permissions boundary ${currentPermissionsBoundary}`
        ));
      } else {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(
          `Changing permissions boundary from ${currentPermissionsBoundary} to ${policyName}`
        ));
      }
    }
    return current.update(
      bootstrapTemplate,
      {
        FileAssetsBucketName: params.bucketName,
        FileAssetsBucketKmsKeyId: kmsKeyId,
        // Empty array becomes empty string
        TrustedAccounts: trustedAccounts.join(","),
        TrustedAccountsForLookup: trustedAccountsForLookup.join(","),
        CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(","),
        Qualifier: params.qualifier,
        PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === void 0 ? "true" : "false",
        InputPermissionsBoundary: policyName
      },
      {
        ...options,
        terminationProtection: options.terminationProtection ?? current.terminationProtection
      }
    );
  }
  async getPolicyName(environment, sdk, permissionsBoundary, partition2, params) {
    if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
      this.validatePolicyName(permissionsBoundary);
      return Promise.resolve(permissionsBoundary);
    }
    const arn = await this.getExamplePermissionsBoundary(
      params.qualifier ?? "hnb659fds",
      partition2,
      environment.account,
      sdk
    );
    const policyName = arn.split("/").pop();
    if (!policyName) {
      throw new ToolkitError("Could not retrieve the example permission boundary!");
    }
    return Promise.resolve(policyName);
  }
  async getExamplePermissionsBoundary(qualifier, partition2, account, sdk) {
    const iam = sdk.iam();
    let policyName = `cdk-${qualifier}-permissions-boundary`;
    const arn = `arn:${partition2}:iam::${account}:policy/${policyName}`;
    try {
      let getPolicyResp = await iam.getPolicy({ PolicyArn: arn });
      if (getPolicyResp.Policy) {
        return arn;
      }
    } catch (e) {
      if (e.name === "NoSuchEntity") {
      } else {
        throw e;
      }
    }
    const policyDoc = {
      Version: "2012-10-17",
      Statement: [
        {
          Action: ["*"],
          Resource: "*",
          Effect: "Allow",
          Sid: "ExplicitAllowAll"
        },
        {
          Condition: {
            StringEquals: {
              "iam:PermissionsBoundary": `arn:${partition2}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`
            }
          },
          Action: [
            "iam:CreateUser",
            "iam:CreateRole",
            "iam:PutRolePermissionsBoundary",
            "iam:PutUserPermissionsBoundary"
          ],
          Resource: "*",
          Effect: "Allow",
          Sid: "DenyAccessIfRequiredPermBoundaryIsNotBeingApplied"
        },
        {
          Action: [
            "iam:CreatePolicyVersion",
            "iam:DeletePolicy",
            "iam:DeletePolicyVersion",
            "iam:SetDefaultPolicyVersion"
          ],
          Resource: `arn:${partition2}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
          Effect: "Deny",
          Sid: "DenyPermBoundaryIAMPolicyAlteration"
        },
        {
          Action: ["iam:DeleteUserPermissionsBoundary", "iam:DeleteRolePermissionsBoundary"],
          Resource: "*",
          Effect: "Deny",
          Sid: "DenyRemovalOfPermBoundaryFromAnyUserOrRole"
        }
      ]
    };
    const request2 = {
      PolicyName: policyName,
      PolicyDocument: JSON.stringify(policyDoc)
    };
    const createPolicyResponse = await iam.createPolicy(request2);
    if (createPolicyResponse.Policy?.Arn) {
      return createPolicyResponse.Policy.Arn;
    } else {
      throw new ToolkitError(`Could not retrieve the example permission boundary ${arn}!`);
    }
  }
  validatePolicyName(permissionsBoundary) {
    const regexp = /[\w+\/=,.@-]+/;
    const matches = regexp.exec(permissionsBoundary);
    if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
      throw new ToolkitError(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
    }
  }
  async customBootstrap(environment, sdkProvider, options = {}) {
    const version = bootstrapVersionFromTemplate(await this.loadTemplate());
    if (version === 0) {
      return this.legacyBootstrap(environment, sdkProvider, options);
    } else {
      return this.modernBootstrap(environment, sdkProvider, options);
    }
  }
  async loadTemplate(params = {}) {
    switch (this.source.source) {
      case "custom":
        return loadStructuredFile(this.source.templateFile);
      case "default":
        return loadStructuredFile(path10.join(bundledPackageRootDir(__dirname), "lib", "api", "bootstrap", "bootstrap-template.yaml"));
      case "legacy":
        return legacyBootstrapTemplate(params);
    }
  }
};
var USE_AWS_MANAGED_KEY = "AWS_MANAGED_KEY";
var CREATE_NEW_KEY = "";
var CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = "CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY";
function splitCfnArray(xs) {
  if (xs === "" || xs === void 0) {
    return [];
  }
  return xs.split(",");
}
function intersection(xs, ys) {
  return new Set(Array.from(xs).filter((x) => ys.has(x)));
}

// ../tmp-toolkit-helpers/src/api/cloud-assembly/environment.ts
var path11 = __toESM(require("path"));
var import_util36 = require("util");
var cxapi3 = __toESM(require("@aws-cdk/cx-api"));
var fs11 = __toESM(require("fs-extra"));
async function prepareDefaultEnvironment(aws, debugFn) {
  const env = {};
  env[cxapi3.DEFAULT_REGION_ENV] = aws.defaultRegion;
  await debugFn(`Setting "${cxapi3.DEFAULT_REGION_ENV}" environment variable to ${env[cxapi3.DEFAULT_REGION_ENV]}`);
  const accountId = (await aws.defaultAccount())?.accountId;
  if (accountId) {
    env[cxapi3.DEFAULT_ACCOUNT_ENV] = accountId;
    await debugFn(`Setting "${cxapi3.DEFAULT_ACCOUNT_ENV}" environment variable to ${env[cxapi3.DEFAULT_ACCOUNT_ENV]}`);
  }
  return env;
}
async function prepareContext(settings, context, env, debugFn) {
  const debugMode = settings.get(["debug"]) ?? true;
  if (debugMode) {
    env.CDK_DEBUG = "true";
  }
  const pathMetadata = settings.get(["pathMetadata"]) ?? true;
  if (pathMetadata) {
    context[cxapi3.PATH_METADATA_ENABLE_CONTEXT] = true;
  }
  const assetMetadata = settings.get(["assetMetadata"]) ?? true;
  if (assetMetadata) {
    context[cxapi3.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT] = true;
  }
  const versionReporting = settings.get(["versionReporting"]) ?? true;
  if (versionReporting) {
    context[cxapi3.ANALYTICS_REPORTING_ENABLED_CONTEXT] = true;
  }
  if (!versionReporting) {
    context["aws:cdk:disable-version-reporting"] = true;
  }
  const stagingEnabled = settings.get(["staging"]) ?? true;
  if (!stagingEnabled) {
    context[cxapi3.DISABLE_ASSET_STAGING_CONTEXT] = true;
  }
  const bundlingStacks = settings.get(["bundlingStacks"]) ?? ["**"];
  context[cxapi3.BUNDLING_STACKS] = bundlingStacks;
  await debugFn((0, import_util36.format)("context:", context));
  return context;
}
function spaceAvailableForContext(env, limit) {
  const size = (value) => value != null ? Buffer.byteLength(value) : 0;
  const usedSpace = Object.entries(env).map(([k, v]) => k === cxapi3.CONTEXT_ENV ? size(k) : size(k) + size(v)).reduce((a, b) => a + b, 0);
  return Math.max(0, limit - usedSpace);
}
async function guessExecutable(app, debugFn) {
  const commandLine = appToArray(app);
  if (commandLine.length === 1) {
    let fstat;
    try {
      fstat = await fs11.stat(commandLine[0]);
    } catch {
      await debugFn(`Not a file: '${commandLine[0]}'. Using '${commandLine}' as command-line`);
      return commandLine;
    }
    const isExecutable = (fstat.mode & fs11.constants.X_OK) !== 0;
    const isWindows = process.platform === "win32";
    const handler = EXTENSION_MAP.get(path11.extname(commandLine[0]));
    if (handler && (!isExecutable || isWindows)) {
      return handler(commandLine[0]);
    }
  }
  return commandLine;
}
var EXTENSION_MAP = /* @__PURE__ */ new Map([
  [".js", executeNode]
]);
function executeNode(scriptFile) {
  return [process.execPath, scriptFile];
}
function appToArray(app) {
  return typeof app === "string" ? app.split(" ") : app;
}

// ../tmp-toolkit-helpers/src/api/cloud-assembly/stack-assembly.ts
var chalk9 = __toESM(require("chalk"));
var import_minimatch = require("minimatch");

// ../tmp-toolkit-helpers/src/api/cloud-assembly/stack-collection.ts
var import_cx_api7 = require("@aws-cdk/cx-api");
var StackCollection = class _StackCollection {
  constructor(assembly, stackArtifacts) {
    this.assembly = assembly;
    this.stackArtifacts = stackArtifacts;
  }
  get stackCount() {
    return this.stackArtifacts.length;
  }
  get firstStack() {
    if (this.stackCount < 1) {
      throw new ToolkitError("StackCollection contains no stack artifacts (trying to access the first one)");
    }
    return this.stackArtifacts[0];
  }
  get stackIds() {
    return this.stackArtifacts.map((s) => s.id);
  }
  get hierarchicalIds() {
    return this.stackArtifacts.map((s) => s.hierarchicalId);
  }
  withDependencies() {
    const allData = [];
    for (const stack of this.stackArtifacts) {
      const data = {
        id: stack.displayName ?? stack.id,
        name: stack.stackName,
        environment: stack.environment,
        dependencies: []
      };
      for (const dependencyId of stack.dependencies.map((x) => x.id)) {
        if (dependencyId.includes(".assets")) {
          continue;
        }
        const depStack = this.assembly.stackById(dependencyId);
        if (depStack.firstStack.dependencies.filter((dep) => !dep.id.includes(".assets")).length > 0) {
          for (const stackDetail of depStack.withDependencies()) {
            data.dependencies.push({
              id: stackDetail.id,
              dependencies: stackDetail.dependencies
            });
          }
        } else {
          data.dependencies.push({
            id: depStack.firstStack.displayName ?? depStack.firstStack.id,
            dependencies: []
          });
        }
      }
      allData.push(data);
    }
    return allData;
  }
  reversed() {
    const arts = [...this.stackArtifacts];
    arts.reverse();
    return new _StackCollection(this.assembly, arts);
  }
  filter(predicate) {
    return new _StackCollection(this.assembly, this.stackArtifacts.filter(predicate));
  }
  concat(...others) {
    return new _StackCollection(this.assembly, this.stackArtifacts.concat(...others.map((o) => o.stackArtifacts)));
  }
  /**
   * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
   */
  async validateMetadata(failAt = "error", logger = async () => {
  }) {
    let warnings = false;
    let errors = false;
    for (const stack of this.stackArtifacts) {
      for (const message2 of stack.messages) {
        switch (message2.level) {
          case import_cx_api7.SynthesisMessageLevel.WARNING:
            warnings = true;
            await logger("warn", message2);
            break;
          case import_cx_api7.SynthesisMessageLevel.ERROR:
            errors = true;
            await logger("error", message2);
            break;
          case import_cx_api7.SynthesisMessageLevel.INFO:
            await logger("info", message2);
            break;
        }
      }
    }
    if (errors && failAt != "none") {
      throw AssemblyError.withStacks("Found errors", this.stackArtifacts);
    }
    if (warnings && failAt === "warn") {
      throw AssemblyError.withStacks("Found warnings (--strict mode)", this.stackArtifacts);
    }
  }
};

// ../tmp-toolkit-helpers/src/api/cloud-assembly/stack-assembly.ts
var ExtendedStackSelection = /* @__PURE__ */ ((ExtendedStackSelection2) => {
  ExtendedStackSelection2[ExtendedStackSelection2["None"] = 0] = "None";
  ExtendedStackSelection2[ExtendedStackSelection2["Upstream"] = 1] = "Upstream";
  ExtendedStackSelection2[ExtendedStackSelection2["Downstream"] = 2] = "Downstream";
  return ExtendedStackSelection2;
})(ExtendedStackSelection || {});
var BaseStackAssembly = class {
  constructor(assembly, ioHelper) {
    this.assembly = assembly;
    this.directory = assembly.directory;
    this.ioHelper = ioHelper;
  }
  /**
   * Sanitize a list of stack match patterns
   */
  static sanitizePatterns(patterns) {
    let sanitized = patterns.filter((s) => s != null);
    sanitized = [...new Set(sanitized)];
    return sanitized;
  }
  /**
   * The directory this CloudAssembly was read from
   */
  directory;
  /**
   * The IoHelper used for messaging
   */
  ioHelper;
  /**
   * Select a single stack by its ID
   */
  stackById(stackId) {
    return new StackCollection(this, [this.assembly.getStackArtifact(stackId)]);
  }
  async selectMatchingStacks(stacks, patterns, extend = 0 /* None */) {
    const matchingPattern = (pattern) => (stack) => (0, import_minimatch.minimatch)(stack.hierarchicalId, pattern);
    const matchedStacks = flatten(patterns.map((pattern) => stacks.filter(matchingPattern(pattern))));
    return this.extendStacks(matchedStacks, stacks, extend);
  }
  async extendStacks(matched, all, extend = 0 /* None */) {
    const allStacks = /* @__PURE__ */ new Map();
    for (const stack of all) {
      allStacks.set(stack.hierarchicalId, stack);
    }
    const index = indexByHierarchicalId(matched);
    switch (extend) {
      case 2 /* Downstream */:
        await includeDownstreamStacks(this.ioHelper, index, allStacks);
        break;
      case 1 /* Upstream */:
        await includeUpstreamStacks(this.ioHelper, index, allStacks);
        break;
    }
    const selectedList = all.filter((s) => index.has(s.hierarchicalId));
    return new StackCollection(this, selectedList);
  }
};
function indexByHierarchicalId(stacks) {
  const result2 = /* @__PURE__ */ new Map();
  for (const stack of stacks) {
    result2.set(stack.hierarchicalId, stack);
  }
  return result2;
}
async function includeDownstreamStacks(ioHelper, selectedStacks, allStacks) {
  const added = new Array();
  let madeProgress;
  do {
    madeProgress = false;
    for (const [id, stack] of allStacks) {
      if (!selectedStacks.has(id) && (stack.dependencies || []).some((dep) => selectedStacks.has(dep.id))) {
        selectedStacks.set(id, stack);
        added.push(id);
        madeProgress = true;
      }
    }
  } while (madeProgress);
  if (added.length > 0) {
    await ioHelper.notify(IO.DEFAULT_ASSEMBLY_INFO.msg(`Including depending stacks: ${chalk9.bold(added.join(", "))}`));
  }
}
async function includeUpstreamStacks(ioHelper, selectedStacks, allStacks) {
  const added = new Array();
  let madeProgress = true;
  while (madeProgress) {
    madeProgress = false;
    for (const stack of selectedStacks.values()) {
      for (const dependencyId of stack.dependencies.map((x) => x.manifest.displayName ?? x.id)) {
        if (!selectedStacks.has(dependencyId) && allStacks.has(dependencyId)) {
          added.push(dependencyId);
          selectedStacks.set(dependencyId, allStacks.get(dependencyId));
          madeProgress = true;
        }
      }
    }
  }
  if (added.length > 0) {
    await ioHelper.notify(IO.DEFAULT_ASSEMBLY_INFO.msg(`Including dependency stacks: ${chalk9.bold(added.join(", "))}`));
  }
}

// ../tmp-toolkit-helpers/src/api/cloud-assembly/stack-selector.ts
var StackSelectionStrategy = /* @__PURE__ */ ((StackSelectionStrategy2) => {
  StackSelectionStrategy2["ALL_STACKS"] = "all-stacks";
  StackSelectionStrategy2["MAIN_ASSEMBLY"] = "main-assembly";
  StackSelectionStrategy2["ONLY_SINGLE"] = "only-single";
  StackSelectionStrategy2["PATTERN_MATCH"] = "pattern-match";
  StackSelectionStrategy2["PATTERN_MUST_MATCH"] = "pattern-must-match";
  StackSelectionStrategy2["PATTERN_MUST_MATCH_SINGLE"] = "pattern-must-match-single";
  return StackSelectionStrategy2;
})(StackSelectionStrategy || {});
var ExpandStackSelection = /* @__PURE__ */ ((ExpandStackSelection2) => {
  ExpandStackSelection2["NONE"] = "none";
  ExpandStackSelection2["UPSTREAM"] = "upstream";
  ExpandStackSelection2["DOWNSTREAM"] = "downstream";
  return ExpandStackSelection2;
})(ExpandStackSelection || {});

// ../tmp-toolkit-helpers/src/api/settings.ts
var os4 = __toESM(require("os"));
var fs_path = __toESM(require("path"));
var fs12 = __toESM(require("fs-extra"));
var TRANSIENT_CONTEXT_KEY = "$dontSaveContext";
var Settings = class _Settings {
  constructor(settings = {}, readOnly = false) {
    this.settings = settings;
    this.readOnly = readOnly;
  }
  static mergeAll(...settings) {
    let ret = new _Settings();
    for (const setting of settings) {
      ret = ret.merge(setting);
    }
    return ret;
  }
  async save(fileName) {
    const expanded = expandHomeDir(fileName);
    await fs12.writeJson(expanded, stripTransientValues(this.settings), {
      spaces: 2
    });
    return this;
  }
  get all() {
    return this.get([]);
  }
  merge(other) {
    return new _Settings(deepMerge(this.settings, other.settings));
  }
  subSettings(keyPrefix) {
    return new _Settings(this.get(keyPrefix) || {}, false);
  }
  makeReadOnly() {
    return new _Settings(this.settings, true);
  }
  clear() {
    if (this.readOnly) {
      throw new ToolkitError("Cannot clear(): settings are readonly");
    }
    this.settings = {};
  }
  get empty() {
    return Object.keys(this.settings).length === 0;
  }
  get(path13) {
    return deepClone(deepGet(this.settings, path13));
  }
  set(path13, value) {
    if (this.readOnly) {
      throw new ToolkitError(`Can't set ${path13}: settings object is readonly`);
    }
    if (path13.length === 0) {
      this.settings = value;
    } else {
      deepSet(this.settings, path13, value);
    }
    return this;
  }
  unset(path13) {
    this.set(path13, void 0);
  }
};
function expandHomeDir(x) {
  if (x.startsWith("~")) {
    return fs_path.join(os4.homedir(), x.slice(1));
  }
  return x;
}
function stripTransientValues(obj) {
  const ret = {};
  for (const [key, value] of Object.entries(obj)) {
    if (!isTransientValue(value)) {
      ret[key] = value;
    }
  }
  return ret;
}
function isTransientValue(value) {
  return typeof value === "object" && value !== null && value[TRANSIENT_CONTEXT_KEY];
}

// ../tmp-toolkit-helpers/src/api/context.ts
var PROJECT_CONTEXT = "cdk.context.json";
var Context = class {
  bags;
  fileNames;
  constructor(...bags) {
    this.bags = bags.length > 0 ? bags.map((b) => b.bag) : [new Settings()];
    this.fileNames = bags.length > 0 ? bags.map((b) => b.fileName) : ["default"];
  }
  get keys() {
    return Object.keys(this.all);
  }
  has(key) {
    return this.keys.indexOf(key) > -1;
  }
  get all() {
    let ret = new Settings();
    for (const bag of [...this.bags].reverse()) {
      ret = ret.merge(bag);
    }
    return ret.all;
  }
  get(key) {
    for (const bag of this.bags) {
      const v = bag.get([key]);
      if (v !== void 0) {
        return v;
      }
    }
    return void 0;
  }
  set(key, value) {
    for (const bag of this.bags) {
      if (bag.readOnly) {
        continue;
      }
      bag.set([key], value);
      value = void 0;
    }
  }
  unset(key) {
    this.set(key, void 0);
  }
  clear() {
    for (const key of this.keys) {
      this.unset(key);
    }
  }
  /**
   * Save a specific context file
   */
  async save(fileName) {
    const index = this.fileNames.indexOf(fileName);
    if (index === -1) {
      return this;
    }
    const bag = this.bags[index];
    if (bag.readOnly) {
      throw new ToolkitError(`Context file ${fileName} is read only!`);
    }
    await bag.save(fileName);
    return this;
  }
};

// ../tmp-toolkit-helpers/src/api/diff/diff-formatter.ts
var import_node_util2 = require("node:util");
var cxschema3 = __toESM(require("@aws-cdk/cloud-assembly-schema"));
var import_cloudformation_diff = require("@aws-cdk/cloudformation-diff");
var chalk10 = __toESM(require("chalk"));

// ../tmp-toolkit-helpers/src/api/require-approval.ts
var RequireApproval = /* @__PURE__ */ ((RequireApproval2) => {
  RequireApproval2["NEVER"] = "never";
  RequireApproval2["ANY_CHANGE"] = "any-change";
  RequireApproval2["BROADENING"] = "broadening";
  return RequireApproval2;
})(RequireApproval || {});

// ../tmp-toolkit-helpers/src/api/streams.ts
var import_node_stream = require("node:stream");
var StringWriteStream = class extends import_node_stream.Writable {
  buffer = [];
  constructor() {
    super();
  }
  _write(chunk, _encoding, callback) {
    this.buffer.push(chunk.toString());
    callback();
  }
  toString() {
    return this.buffer.join("");
  }
};

// ../tmp-toolkit-helpers/src/api/diff/diff-formatter.ts
var DiffFormatter = class {
  ioHelper;
  oldTemplate;
  newTemplate;
  stackName;
  changeSet;
  nestedStacks;
  isImport;
  /**
   * Stores the TemplateDiffs that get calculated in this DiffFormatter,
   * indexed by the stack name.
   */
  _diffs = {};
  constructor(props) {
    this.ioHelper = props.ioHelper;
    this.oldTemplate = props.templateInfo.oldTemplate;
    this.newTemplate = props.templateInfo.newTemplate;
    this.stackName = props.templateInfo.newTemplate.stackName;
    this.changeSet = props.templateInfo.changeSet;
    this.nestedStacks = props.templateInfo.nestedStacks;
    this.isImport = props.templateInfo.isImport ?? false;
  }
  get diffs() {
    return this._diffs;
  }
  /**
   * Format the stack diff
   */
  formatStackDiff(options = {}) {
    const ioDefaultHelper = new IoDefaultMessages(this.ioHelper);
    return this.formatStackDiffHelper(
      this.oldTemplate,
      this.stackName,
      this.nestedStacks,
      {
        ...options,
        ioDefaultHelper
      }
    );
  }
  formatStackDiffHelper(oldTemplate, stackName, nestedStackTemplates, options) {
    let diff = (0, import_cloudformation_diff.fullDiff)(oldTemplate, this.newTemplate.template, this.changeSet, this.isImport);
    this._diffs[stackName] = diff;
    const stream = new StringWriteStream();
    let numStacksWithChanges = 0;
    let formattedDiff = "";
    let filteredChangesCount = 0;
    try {
      if (stackName && (!options.quiet || !diff.isEmpty)) {
        stream.write((0, import_node_util2.format)(`Stack ${chalk10.bold(stackName)}
`));
      }
      if (!options.quiet && this.isImport) {
        stream.write("Parameters and rules created during migration do not affect resource configuration.\n");
      }
      if (diff.differenceCount && !options.strict) {
        const mangledNewTemplate = JSON.parse((0, import_cloudformation_diff.mangleLikeCloudFormation)(JSON.stringify(this.newTemplate.template)));
        const mangledDiff = (0, import_cloudformation_diff.fullDiff)(this.oldTemplate, mangledNewTemplate, this.changeSet);
        filteredChangesCount = Math.max(0, diff.differenceCount - mangledDiff.differenceCount);
        if (filteredChangesCount > 0) {
          diff = mangledDiff;
        }
      }
      if (!options.strict) {
        obscureDiff(diff);
      }
      if (!diff.isEmpty) {
        numStacksWithChanges++;
        (0, import_cloudformation_diff.formatDifferences)(stream, diff, {
          ...logicalIdMapFromTemplate(this.oldTemplate),
          ...buildLogicalToPathMap(this.newTemplate)
        }, options.context);
      } else if (!options.quiet) {
        stream.write(chalk10.green("There were no differences\n"));
      }
      if (filteredChangesCount > 0) {
        stream.write(chalk10.yellow(`Omitted ${filteredChangesCount} changes because they are likely mangled non-ASCII characters. Use --strict to print them.
`));
      }
    } finally {
      formattedDiff = stream.toString();
      stream.end();
    }
    for (const nestedStackLogicalId of Object.keys(nestedStackTemplates ?? {})) {
      if (!nestedStackTemplates) {
        break;
      }
      const nestedStack = nestedStackTemplates[nestedStackLogicalId];
      this.newTemplate._template = nestedStack.generatedTemplate;
      const nextDiff = this.formatStackDiffHelper(
        nestedStack.deployedTemplate,
        nestedStack.physicalName ?? nestedStackLogicalId,
        nestedStack.nestedStackTemplates,
        options
      );
      numStacksWithChanges += nextDiff.numStacksWithChanges;
      formattedDiff += nextDiff.formattedDiff;
    }
    return {
      numStacksWithChanges,
      formattedDiff
    };
  }
  /**
   * Format the security diff
   */
  formatSecurityDiff(options) {
    const ioDefaultHelper = new IoDefaultMessages(this.ioHelper);
    const diff = (0, import_cloudformation_diff.fullDiff)(this.oldTemplate, this.newTemplate.template, this.changeSet);
    this._diffs[this.stackName] = diff;
    if (diffRequiresApproval(diff, options.requireApproval)) {
      const stream = new StringWriteStream();
      stream.write((0, import_node_util2.format)(`Stack ${chalk10.bold(this.stackName)}
`));
      ioDefaultHelper.warning(`This deployment will make potentially sensitive changes according to your current security approval level (--require-approval ${options.requireApproval}).`);
      ioDefaultHelper.warning("Please confirm you intend to make the following modifications:\n");
      try {
        (0, import_cloudformation_diff.formatSecurityChanges)(stream, diff, buildLogicalToPathMap(this.newTemplate));
      } finally {
        stream.end();
      }
      const formattedDiff = stream.toString();
      return { formattedDiff };
    }
    return {};
  }
};
function diffRequiresApproval(diff, requireApproval) {
  switch (requireApproval) {
    case "never" /* NEVER */:
      return false;
    case "any-change" /* ANY_CHANGE */:
      return diff.permissionsAnyChanges;
    case "broadening" /* BROADENING */:
      return diff.permissionsBroadened;
    default:
      throw new ToolkitError(`Unrecognized approval level: ${requireApproval}`);
  }
}
function buildLogicalToPathMap(stack) {
  const map = {};
  for (const md of stack.findMetadataByType(cxschema3.ArtifactMetadataEntryType.LOGICAL_ID)) {
    map[md.data] = md.path;
  }
  return map;
}
function logicalIdMapFromTemplate(template) {
  const ret = {};
  for (const [logicalId, resource] of Object.entries(template.Resources ?? {})) {
    const path13 = resource?.Metadata?.["aws:cdk:path"];
    if (path13) {
      ret[logicalId] = path13;
    }
  }
  return ret;
}
function obscureDiff(diff) {
  if (diff.unknown) {
    diff.unknown = diff.unknown.filter((change) => {
      if (!change) {
        return true;
      }
      if (change.newValue?.CheckBootstrapVersion) {
        return false;
      }
      if (change.oldValue?.CheckBootstrapVersion) {
        return false;
      }
      return true;
    });
  }
  if (diff.resources) {
    diff.resources = diff.resources.filter((change) => {
      if (!change) {
        return true;
      }
      if (change.newResourceType === "AWS::CDK::Metadata") {
        return false;
      }
      if (change.oldResourceType === "AWS::CDK::Metadata") {
        return false;
      }
      return true;
    });
  }
}

// ../tmp-toolkit-helpers/src/api/garbage-collection/garbage-collector.ts
var chalk12 = __toESM(require("chalk"));
var promptly2 = __toESM(require("promptly"));

// ../tmp-toolkit-helpers/src/api/garbage-collection/progress-printer.ts
var chalk11 = __toESM(require("chalk"));
var ProgressPrinter = class {
  ioHelper;
  totalAssets;
  assetsScanned;
  taggedAsset;
  taggedAssetsSizeMb;
  deletedAssets;
  deletedAssetsSizeMb;
  interval;
  setInterval;
  isPaused;
  constructor(ioHelper, totalAssets, interval) {
    this.ioHelper = ioHelper;
    this.totalAssets = totalAssets;
    this.assetsScanned = 0;
    this.taggedAsset = 0;
    this.taggedAssetsSizeMb = 0;
    this.deletedAssets = 0;
    this.deletedAssetsSizeMb = 0;
    this.interval = interval ?? 1e4;
    this.isPaused = false;
  }
  reportScannedAsset(amt) {
    this.assetsScanned += amt;
  }
  reportTaggedAsset(assets) {
    this.taggedAsset += assets.length;
    const sizeInBytes = assets.reduce((total, asset) => total + asset.size, 0);
    this.taggedAssetsSizeMb += sizeInBytes / 1048576;
  }
  reportDeletedAsset(assets) {
    this.deletedAssets += assets.length;
    const sizeInBytes = assets.reduce((total, asset) => total + asset.size, 0);
    this.deletedAssetsSizeMb += sizeInBytes / 1048576;
  }
  start() {
    if (this.setInterval) {
      throw new ToolkitError("ProgressPrinter is already running. Stop it first using the stop() method before starting it again.");
    }
    this.setInterval = setInterval(() => {
      if (!this.isPaused) {
        this.print();
      }
    }, this.interval);
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  stop() {
    clearInterval(this.setInterval);
    if (!this.isPaused) {
      this.print();
    }
  }
  print() {
    const percentage = (this.assetsScanned / this.totalAssets * 100).toFixed(2);
    if (Math.max(this.taggedAssetsSizeMb, this.deletedAssetsSizeMb) >= 1e3) {
      void this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(chalk11.green(`[${percentage}%] ${this.assetsScanned} files scanned: ${this.taggedAsset} assets (${(this.taggedAssetsSizeMb / 1e3).toFixed(2)} GiB) tagged, ${this.deletedAssets} assets (${(this.deletedAssetsSizeMb / 1e3).toFixed(2)} GiB) deleted.`)));
    } else {
      void this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(chalk11.green(`[${percentage}%] ${this.assetsScanned} files scanned: ${this.taggedAsset} assets (${this.taggedAssetsSizeMb.toFixed(2)} MiB) tagged, ${this.deletedAssets} assets (${this.deletedAssetsSizeMb.toFixed(2)} MiB) deleted.`)));
    }
  }
};

// ../tmp-toolkit-helpers/src/api/garbage-collection/stack-refresh.ts
var ActiveAssetCache = class {
  stacks = /* @__PURE__ */ new Set();
  rememberStack(stackTemplate) {
    this.stacks.add(stackTemplate);
  }
  contains(asset) {
    for (const stack of this.stacks) {
      if (stack.includes(asset)) {
        return true;
      }
    }
    return false;
  }
};
async function paginateSdkCall(cb) {
  let finished = false;
  let nextToken;
  while (!finished) {
    nextToken = await cb(nextToken);
    if (nextToken === void 0) {
      finished = true;
    }
  }
}
async function fetchAllStackTemplates(cfn, ioHelper, qualifier) {
  const stackNames = [];
  await paginateSdkCall(async (nextToken) => {
    const stacks = await cfn.listStacks({ NextToken: nextToken });
    const ignoredStatues = ["CREATE_FAILED", "DELETE_COMPLETE", "DELETE_IN_PROGRESS", "DELETE_FAILED", "REVIEW_IN_PROGRESS"];
    stackNames.push(
      ...(stacks.StackSummaries ?? []).filter((s) => !ignoredStatues.includes(s.StackStatus)).map((s) => s.StackId ?? s.StackName)
    );
    return stacks.NextToken;
  });
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Parsing through ${stackNames.length} stacks`));
  const templates = [];
  for (const stack of stackNames) {
    let summary;
    summary = await cfn.getTemplateSummary({
      StackName: stack
    });
    if (bootstrapFilter(summary.Parameters, qualifier)) {
      continue;
    } else {
      const template = await cfn.getTemplate({
        StackName: stack
      });
      templates.push((template.TemplateBody ?? "") + JSON.stringify(summary?.Parameters));
    }
  }
  await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Done parsing through stacks"));
  return templates;
}
function bootstrapFilter(parameters, qualifier) {
  const bootstrapVersion = parameters?.find((p) => p.ParameterKey === "BootstrapVersion");
  const splitBootstrapVersion = bootstrapVersion?.DefaultValue?.split("/");
  return qualifier && splitBootstrapVersion && splitBootstrapVersion.length == 4 && splitBootstrapVersion[2] != qualifier;
}
async function refreshStacks(cfn, ioHelper, activeAssets, qualifier) {
  try {
    const stacks = await fetchAllStackTemplates(cfn, ioHelper, qualifier);
    for (const stack of stacks) {
      activeAssets.rememberStack(stack);
    }
  } catch (err) {
    throw new ToolkitError(`Error refreshing stacks: ${err}`);
  }
}
var BackgroundStackRefresh = class {
  constructor(props) {
    this.props = props;
    this.lastRefreshTime = Date.now();
  }
  timeout;
  lastRefreshTime;
  queuedPromises = [];
  start() {
    this.timeout = setTimeout(() => this.refresh(), 3e5);
  }
  async refresh() {
    const startTime = Date.now();
    await refreshStacks(this.props.cfn, this.props.ioHelper, this.props.activeAssets, this.props.qualifier);
    this.justRefreshedStacks();
    this.timeout = setTimeout(() => this.refresh(), Math.max(startTime + 3e5 - Date.now(), 0));
  }
  justRefreshedStacks() {
    this.lastRefreshTime = Date.now();
    for (const p of this.queuedPromises.splice(0, this.queuedPromises.length)) {
      p(void 0);
    }
  }
  /**
   * Checks if the last successful background refresh happened within the specified time frame.
   * If the last refresh is older than the specified time frame, it returns a Promise that resolves
   * when the next background refresh completes or rejects if the refresh takes too long.
   */
  noOlderThan(ms) {
    const horizon = Date.now() - ms;
    if (this.lastRefreshTime >= horizon) {
      return Promise.resolve();
    }
    return Promise.race([
      new Promise((resolve2) => this.queuedPromises.push(resolve2)),
      new Promise((_, reject) => setTimeout(() => reject(new ToolkitError("refreshStacks took too long; the background thread likely threw an error")), ms))
    ]);
  }
  stop() {
    clearTimeout(this.timeout);
  }
};

// ../tmp-toolkit-helpers/src/api/garbage-collection/garbage-collector.ts
var pLimit2 = require("p-limit");
var S3_ISOLATED_TAG = "aws-cdk:isolated";
var ECR_ISOLATED_TAG = "aws-cdk.isolated";
var P_LIMIT = 50;
var DAY = 24 * 60 * 60 * 1e3;
var ImageAsset = class {
  constructor(digest, size, tags, manifest) {
    this.digest = digest;
    this.size = size;
    this.tags = tags;
    this.manifest = manifest;
  }
  getTag(tag) {
    return this.tags.find((t) => t.includes(tag));
  }
  hasTag(tag) {
    return this.tags.some((t) => t.includes(tag));
  }
  hasIsolatedTag() {
    return this.hasTag(ECR_ISOLATED_TAG);
  }
  getIsolatedTag() {
    return this.getTag(ECR_ISOLATED_TAG);
  }
  isolatedTagBefore(date) {
    const dateIsolated = this.dateIsolated();
    if (!dateIsolated || dateIsolated == "") {
      return false;
    }
    return new Date(dateIsolated) < date;
  }
  buildImageTag(inc) {
    return `${inc}-${ECR_ISOLATED_TAG}-${String(Date.now())}`;
  }
  dateIsolated() {
    return this.getIsolatedTag()?.split("-")[3];
  }
};
var ObjectAsset = class {
  constructor(bucket, key, size) {
    this.bucket = bucket;
    this.key = key;
    this.size = size;
  }
  cached_tags = void 0;
  fileName() {
    return this.key.split(".")[0];
  }
  async allTags(s3) {
    if (this.cached_tags) {
      return this.cached_tags;
    }
    const response = await s3.getObjectTagging({ Bucket: this.bucket, Key: this.key });
    this.cached_tags = response.TagSet;
    return this.cached_tags;
  }
  getTag(tag) {
    if (!this.cached_tags) {
      throw new ToolkitError("Cannot call getTag before allTags");
    }
    return this.cached_tags.find((t) => t.Key === tag)?.Value;
  }
  hasTag(tag) {
    if (!this.cached_tags) {
      throw new ToolkitError("Cannot call hasTag before allTags");
    }
    return this.cached_tags.some((t) => t.Key === tag);
  }
  hasIsolatedTag() {
    return this.hasTag(S3_ISOLATED_TAG);
  }
  isolatedTagBefore(date) {
    const tagValue = this.getTag(S3_ISOLATED_TAG);
    if (!tagValue || tagValue == "") {
      return false;
    }
    return new Date(tagValue) < date;
  }
};
var GarbageCollector = class {
  constructor(props) {
    this.props = props;
    this.ioHelper = props.ioHelper;
    this.garbageCollectS3Assets = ["s3", "all"].includes(props.type);
    this.garbageCollectEcrAssets = ["ecr", "all"].includes(props.type);
    this.permissionToDelete = ["delete-tagged", "full"].includes(props.action);
    this.permissionToTag = ["tag", "full"].includes(props.action);
    this.confirm = props.confirm ?? true;
    this.bootstrapStackName = props.bootstrapStackName ?? DEFAULT_TOOLKIT_STACK_NAME;
  }
  garbageCollectS3Assets;
  garbageCollectEcrAssets;
  permissionToDelete;
  permissionToTag;
  bootstrapStackName;
  confirm;
  ioHelper;
  /**
   * Perform garbage collection on the resolved environment.
   */
  async garbageCollect() {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${this.garbageCollectS3Assets} ${this.garbageCollectEcrAssets}`));
    const sdk = (await this.props.sdkProvider.forEnvironment(this.props.resolvedEnvironment, 1 /* ForWriting */)).sdk;
    const cfn = sdk.cloudFormation();
    const qualifier = await this.bootstrapQualifier(sdk, this.bootstrapStackName);
    const activeAssets = new ActiveAssetCache();
    await refreshStacks(cfn, this.ioHelper, activeAssets, qualifier);
    const backgroundStackRefresh = new BackgroundStackRefresh({
      cfn,
      ioHelper: this.ioHelper,
      activeAssets,
      qualifier
    });
    backgroundStackRefresh.start();
    try {
      if (this.garbageCollectS3Assets) {
        await this.garbageCollectS3(sdk, activeAssets, backgroundStackRefresh);
      }
      if (this.garbageCollectEcrAssets) {
        await this.garbageCollectEcr(sdk, activeAssets, backgroundStackRefresh);
      }
    } catch (err) {
      throw new ToolkitError(err);
    } finally {
      backgroundStackRefresh.stop();
    }
  }
  /**
   * Perform garbage collection on ECR assets
   */
  async garbageCollectEcr(sdk, activeAssets, backgroundStackRefresh) {
    const ecr = sdk.ecr();
    const repo = await this.bootstrapRepositoryName(sdk, this.bootstrapStackName);
    const numImages = await this.numImagesInRepo(ecr, repo);
    const printer = new ProgressPrinter(this.ioHelper, numImages, 1e3);
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Found bootstrap repo ${repo} with ${numImages} images`));
    try {
      const batchSize = 1e3;
      const currentTime = Date.now();
      const graceDays = this.props.rollbackBufferDays;
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Parsing through ${numImages} images in batches`));
      printer.start();
      for await (const batch of this.readRepoInBatches(ecr, repo, batchSize, currentTime)) {
        await backgroundStackRefresh.noOlderThan(6e5);
        const { included: isolated, excluded: notIsolated } = partition(batch, (asset) => !asset.tags.some((t) => activeAssets.contains(t)));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${isolated.length} isolated images`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${notIsolated.length} not isolated images`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${batch.length} images total`));
        let deletables = isolated;
        let taggables = [];
        let untaggables = [];
        if (graceDays > 0) {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Filtering out images that are not old enough to delete"));
          deletables = isolated.filter((img) => img.isolatedTagBefore(new Date(currentTime - graceDays * DAY)));
          taggables = isolated.filter((img) => !img.hasIsolatedTag());
          untaggables = notIsolated.filter((img) => img.hasIsolatedTag());
        }
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deletables.length} deletable assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${taggables.length} taggable assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${untaggables.length} assets to untag`));
        if (this.permissionToDelete && deletables.length > 0) {
          await this.confirmationPrompt(printer, deletables, "image");
          await this.parallelDeleteEcr(ecr, repo, deletables, printer);
        }
        if (this.permissionToTag && taggables.length > 0) {
          await this.parallelTagEcr(ecr, repo, taggables, printer);
        }
        if (this.permissionToTag && untaggables.length > 0) {
          await this.parallelUntagEcr(ecr, repo, untaggables);
        }
        printer.reportScannedAsset(batch.length);
      }
    } catch (err) {
      throw new ToolkitError(err);
    } finally {
      printer.stop();
    }
  }
  /**
   * Perform garbage collection on S3 assets
   */
  async garbageCollectS3(sdk, activeAssets, backgroundStackRefresh) {
    const s3 = sdk.s3();
    const bucket = await this.bootstrapBucketName(sdk, this.bootstrapStackName);
    const numObjects = await this.numObjectsInBucket(s3, bucket);
    const printer = new ProgressPrinter(this.ioHelper, numObjects, 1e3);
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Found bootstrap bucket ${bucket} with ${numObjects} objects`));
    try {
      const batchSize = 1e3;
      const currentTime = Date.now();
      const graceDays = this.props.rollbackBufferDays;
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Parsing through ${numObjects} objects in batches`));
      printer.start();
      for await (const batch of this.readBucketInBatches(s3, bucket, batchSize, currentTime)) {
        await backgroundStackRefresh.noOlderThan(6e5);
        const { included: isolated, excluded: notIsolated } = partition(batch, (asset) => !activeAssets.contains(asset.fileName()));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${isolated.length} isolated assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${notIsolated.length} not isolated assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${batch.length} objects total`));
        let deletables = isolated;
        let taggables = [];
        let untaggables = [];
        if (graceDays > 0) {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Filtering out assets that are not old enough to delete"));
          await this.parallelReadAllTags(s3, batch);
          deletables = isolated.filter((obj) => obj.isolatedTagBefore(new Date(currentTime - graceDays * DAY)));
          taggables = isolated.filter((obj) => !obj.hasIsolatedTag());
          untaggables = notIsolated.filter((obj) => obj.hasIsolatedTag());
        }
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${deletables.length} deletable assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${taggables.length} taggable assets`));
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${untaggables.length} assets to untag`));
        if (this.permissionToDelete && deletables.length > 0) {
          await this.confirmationPrompt(printer, deletables, "object");
          await this.parallelDeleteS3(s3, bucket, deletables, printer);
        }
        if (this.permissionToTag && taggables.length > 0) {
          await this.parallelTagS3(s3, bucket, taggables, currentTime, printer);
        }
        if (this.permissionToTag && untaggables.length > 0) {
          await this.parallelUntagS3(s3, bucket, untaggables);
        }
        printer.reportScannedAsset(batch.length);
      }
    } catch (err) {
      throw new ToolkitError(err);
    } finally {
      printer.stop();
    }
  }
  async parallelReadAllTags(s3, objects) {
    const limit = pLimit2(P_LIMIT);
    for (const obj of objects) {
      await limit(() => obj.allTags(s3));
    }
  }
  /**
   * Untag assets that were previously tagged, but now currently referenced.
   * Since this is treated as an implementation detail, we do not print the results in the printer.
   */
  async parallelUntagEcr(ecr, repo, untaggables) {
    const limit = pLimit2(P_LIMIT);
    for (const img of untaggables) {
      const tag = img.getIsolatedTag();
      await limit(
        () => ecr.batchDeleteImage({
          repositoryName: repo,
          imageIds: [{
            imageTag: tag
          }]
        })
      );
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Untagged ${untaggables.length} assets`));
  }
  /**
   * Untag assets that were previously tagged, but now currently referenced.
   * Since this is treated as an implementation detail, we do not print the results in the printer.
   */
  async parallelUntagS3(s3, bucket, untaggables) {
    const limit = pLimit2(P_LIMIT);
    for (const obj of untaggables) {
      const tags = await obj.allTags(s3) ?? [];
      const updatedTags = tags.filter((tag) => tag.Key !== S3_ISOLATED_TAG);
      await limit(
        () => s3.deleteObjectTagging({
          Bucket: bucket,
          Key: obj.key
        })
      );
      await limit(
        () => s3.putObjectTagging({
          Bucket: bucket,
          Key: obj.key,
          Tagging: {
            TagSet: updatedTags
          }
        })
      );
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Untagged ${untaggables.length} assets`));
  }
  /**
   * Tag images in parallel using p-limit
   */
  async parallelTagEcr(ecr, repo, taggables, printer) {
    const limit = pLimit2(P_LIMIT);
    for (let i = 0; i < taggables.length; i++) {
      const img = taggables[i];
      const tagEcr = async () => {
        try {
          await ecr.putImage({
            repositoryName: repo,
            imageDigest: img.digest,
            imageManifest: img.manifest,
            imageTag: img.buildImageTag(i)
          });
        } catch (error2) {
          await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Warning: unable to tag image ${JSON.stringify(img.tags)} with ${img.buildImageTag(i)} due to the following error: ${error2}`));
        }
      };
      await limit(() => tagEcr());
    }
    printer.reportTaggedAsset(taggables);
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Tagged ${taggables.length} assets`));
  }
  /**
   * Tag objects in parallel using p-limit. The putObjectTagging API does not
   * support batch tagging so we must handle the parallelism client-side.
   */
  async parallelTagS3(s3, bucket, taggables, date, printer) {
    const limit = pLimit2(P_LIMIT);
    for (const obj of taggables) {
      await limit(
        () => s3.putObjectTagging({
          Bucket: bucket,
          Key: obj.key,
          Tagging: {
            TagSet: [
              {
                Key: S3_ISOLATED_TAG,
                Value: String(date)
              }
            ]
          }
        })
      );
    }
    printer.reportTaggedAsset(taggables);
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Tagged ${taggables.length} assets`));
  }
  /**
   * Delete images in parallel. The deleteImage API supports batches of 100.
   */
  async parallelDeleteEcr(ecr, repo, deletables, printer) {
    const batchSize = 100;
    const imagesToDelete = deletables.map((img) => ({
      imageDigest: img.digest
    }));
    try {
      const batches = [];
      for (let i = 0; i < imagesToDelete.length; i += batchSize) {
        batches.push(imagesToDelete.slice(i, i + batchSize));
      }
      for (const batch of batches) {
        await ecr.batchDeleteImage({
          imageIds: batch,
          repositoryName: repo
        });
        const deletedCount = batch.length;
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Deleted ${deletedCount} assets`));
        printer.reportDeletedAsset(deletables.slice(0, deletedCount));
      }
    } catch (err) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_ERROR.msg(`Error deleting images: ${err}`));
    }
  }
  /**
   * Delete objects in parallel. The deleteObjects API supports batches of 1000.
   */
  async parallelDeleteS3(s3, bucket, deletables, printer) {
    const batchSize = 1e3;
    const objectsToDelete = deletables.map((asset) => ({
      Key: asset.key
    }));
    try {
      const batches = [];
      for (let i = 0; i < objectsToDelete.length; i += batchSize) {
        batches.push(objectsToDelete.slice(i, i + batchSize));
      }
      for (const batch of batches) {
        await s3.deleteObjects({
          Bucket: bucket,
          Delete: {
            Objects: batch,
            Quiet: true
          }
        });
        const deletedCount = batch.length;
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Deleted ${deletedCount} assets`));
        printer.reportDeletedAsset(deletables.slice(0, deletedCount));
      }
    } catch (err) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(chalk12.red(`Error deleting objects: ${err}`)));
    }
  }
  async bootstrapBucketName(sdk, bootstrapStackName) {
    const toolkitInfo = await ToolkitInfo.lookup(this.props.resolvedEnvironment, sdk, this.ioHelper, bootstrapStackName);
    return toolkitInfo.bucketName;
  }
  async bootstrapRepositoryName(sdk, bootstrapStackName) {
    const toolkitInfo = await ToolkitInfo.lookup(this.props.resolvedEnvironment, sdk, this.ioHelper, bootstrapStackName);
    return toolkitInfo.repositoryName;
  }
  async bootstrapQualifier(sdk, bootstrapStackName) {
    const toolkitInfo = await ToolkitInfo.lookup(this.props.resolvedEnvironment, sdk, this.ioHelper, bootstrapStackName);
    return toolkitInfo.bootstrapStack.parameters.Qualifier;
  }
  async numObjectsInBucket(s3, bucket) {
    let totalCount = 0;
    let continuationToken;
    do {
      const response = await s3.listObjectsV2({
        Bucket: bucket,
        ContinuationToken: continuationToken
      });
      totalCount += response.KeyCount ?? 0;
      continuationToken = response.NextContinuationToken;
    } while (continuationToken);
    return totalCount;
  }
  async numImagesInRepo(ecr, repo) {
    let totalCount = 0;
    let nextToken;
    do {
      const response = await ecr.listImages({
        repositoryName: repo,
        nextToken
      });
      totalCount += response.imageIds?.length ?? 0;
      nextToken = response.nextToken;
    } while (nextToken);
    return totalCount;
  }
  async *readRepoInBatches(ecr, repo, batchSize = 1e3, currentTime) {
    let continuationToken;
    do {
      const batch = [];
      while (batch.length < batchSize) {
        const response = await ecr.listImages({
          repositoryName: repo,
          nextToken: continuationToken
        });
        if (!response.imageIds || response.imageIds.length === 0) {
          break;
        }
        const images = imageMap(response.imageIds ?? []);
        const imageIds = Object.keys(images).map((key) => ({
          imageDigest: key
        }));
        const describeImageInfo = await ecr.describeImages({
          repositoryName: repo,
          imageIds
        });
        const getImageInfo = await ecr.batchGetImage({
          repositoryName: repo,
          imageIds
        });
        const combinedImageInfo = describeImageInfo.imageDetails?.map((imageDetail) => {
          const matchingImage = getImageInfo.images?.find(
            (img) => img.imageId?.imageDigest === imageDetail.imageDigest
          );
          return {
            ...imageDetail,
            manifest: matchingImage?.imageManifest
          };
        });
        for (const image of combinedImageInfo ?? []) {
          const lastModified = image.imagePushedAt ?? new Date(currentTime);
          if (image.imageDigest && lastModified < new Date(currentTime - this.props.createdBufferDays * DAY)) {
            batch.push(new ImageAsset(image.imageDigest, image.imageSizeInBytes ?? 0, image.imageTags ?? [], image.manifest ?? ""));
          }
        }
        continuationToken = response.nextToken;
        if (!continuationToken) break;
      }
      if (batch.length > 0) {
        yield batch;
      }
    } while (continuationToken);
  }
  /**
   * Generator function that reads objects from the S3 Bucket in batches.
   */
  async *readBucketInBatches(s3, bucket, batchSize = 1e3, currentTime) {
    let continuationToken;
    do {
      const batch = [];
      while (batch.length < batchSize) {
        const response = await s3.listObjectsV2({
          Bucket: bucket,
          ContinuationToken: continuationToken
        });
        response.Contents?.forEach((obj) => {
          const key = obj.Key ?? "";
          const size = obj.Size ?? 0;
          const lastModified = obj.LastModified ?? new Date(currentTime);
          if (key && lastModified < new Date(currentTime - this.props.createdBufferDays * DAY)) {
            batch.push(new ObjectAsset(bucket, key, size));
          }
        });
        continuationToken = response.NextContinuationToken;
        if (!continuationToken) break;
      }
      if (batch.length > 0) {
        yield batch;
      }
    } while (continuationToken);
  }
  async confirmationPrompt(printer, deletables, type) {
    const pluralize = (name, count) => {
      return count === 1 ? name : `${name}s`;
    };
    if (this.confirm) {
      const message2 = [
        `Found ${deletables.length} ${pluralize(type, deletables.length)} to delete based off of the following criteria:`,
        `- ${type}s have been isolated for > ${this.props.rollbackBufferDays} days`,
        `- ${type}s were created > ${this.props.createdBufferDays} days ago`,
        "",
        "Delete this batch (yes/no/delete-all)?"
      ].join("\n");
      printer.pause();
      const response = await promptly2.prompt(
        message2,
        { trim: true }
      );
      if (!response || !["yes", "y", "delete-all"].includes(response.toLowerCase())) {
        throw new ToolkitError("Deletion aborted by user");
      } else if (response.toLowerCase() == "delete-all") {
        this.confirm = false;
      }
    }
    printer.resume();
  }
};
function partition(xs, pred) {
  const result2 = {
    included: [],
    excluded: []
  };
  for (const x of xs) {
    if (pred(x)) {
      result2.included.push(x);
    } else {
      result2.excluded.push(x);
    }
  }
  return result2;
}
function imageMap(imageIds) {
  const images = {};
  for (const image of imageIds ?? []) {
    if (!image.imageDigest || !image.imageTag) {
      continue;
    }
    if (!images[image.imageDigest]) {
      images[image.imageDigest] = [];
    }
    images[image.imageDigest].push(image.imageTag);
  }
  return images;
}

// ../tmp-toolkit-helpers/src/api/logs-monitor/logs-monitor.ts
var util8 = __toESM(require("util"));
var chalk13 = __toESM(require("chalk"));
var uuid4 = __toESM(require("uuid"));
var CloudWatchLogEventMonitor = class {
  /**
   * Determines which events not to display
   */
  startTime;
  /**
   * Map of environment (account:region) to LogGroupsAccessSettings
   */
  envsLogGroupsAccessSettings = /* @__PURE__ */ new Map();
  /**
   * After reading events from all CloudWatch log groups
   * how long should we wait to read more events.
   *
   * If there is some error with reading events (i.e. Throttle)
   * then this is also how long we wait until we try again
   */
  pollingInterval = 2e3;
  monitorId;
  ioHelper;
  constructor(props) {
    this.startTime = props.startTime?.getTime() ?? Date.now();
    this.ioHelper = props.ioHelper;
  }
  /**
   * resume reading/printing events
   */
  async activate() {
    this.monitorId = uuid4.v4();
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5032.msg("Start monitoring log groups", {
      monitor: this.monitorId,
      logGroupNames: this.logGroupNames()
    }));
    await this.tick();
    this.scheduleNextTick();
  }
  /**
   * deactivates the monitor so no new events are read
   * use case for this is when we are in the middle of performing a deployment
   * and don't want to interweave all the logs together with the CFN
   * deployment logs
   *
   * Also resets the start time to be when the new deployment was triggered
   * and clears the list of tracked log groups
   */
  async deactivate() {
    const oldMonitorId = this.monitorId;
    this.monitorId = void 0;
    this.startTime = Date.now();
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5034.msg("Stopped monitoring log groups", {
      monitor: oldMonitorId,
      logGroupNames: this.logGroupNames()
    }));
    this.envsLogGroupsAccessSettings.clear();
  }
  /**
   * Adds CloudWatch log groups to read log events from.
   * Since we could be watching multiple stacks that deploy to
   * multiple environments (account+region), we need to store a list of log groups
   * per env along with the SDK object that has access to read from
   * that environment.
   */
  addLogGroups(env, sdk, logGroupNames) {
    const awsEnv = `${env.account}:${env.region}`;
    const logGroupsStartTimes = logGroupNames.reduce(
      (acc, groupName) => {
        acc[groupName] = this.startTime;
        return acc;
      },
      {}
    );
    this.envsLogGroupsAccessSettings.set(awsEnv, {
      sdk,
      logGroupsStartTimes: {
        ...this.envsLogGroupsAccessSettings.get(awsEnv)?.logGroupsStartTimes,
        ...logGroupsStartTimes
      }
    });
  }
  logGroupNames() {
    return Array.from(this.envsLogGroupsAccessSettings.values()).flatMap((settings) => Object.keys(settings.logGroupsStartTimes));
  }
  scheduleNextTick() {
    if (!this.monitorId) {
      return;
    }
    setTimeout(() => void this.tick(), this.pollingInterval);
  }
  async tick() {
    if (!this.monitorId) {
      return;
    }
    try {
      const events = flatten(await this.readNewEvents());
      for (const event of events) {
        await this.print(event);
      }
      if (!this.monitorId) {
        return;
      }
    } catch (e) {
      await this.ioHelper.notify(IO.CDK_TOOLKIT_E5035.msg("Error occurred while monitoring logs: %s", { error: e }));
    }
    this.scheduleNextTick();
  }
  /**
   * Reads all new log events from a set of CloudWatch Log Groups
   * in parallel
   */
  async readNewEvents() {
    const promises = [];
    for (const settings of this.envsLogGroupsAccessSettings.values()) {
      for (const group of Object.keys(settings.logGroupsStartTimes)) {
        promises.push(this.readEventsFromLogGroup(settings, group));
      }
    }
    return Promise.all(promises);
  }
  /**
   * Print out a cloudwatch event
   */
  async print(event) {
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5033.msg(
      util8.format(
        "[%s] %s %s",
        chalk13.blue(event.logGroupName),
        chalk13.yellow(event.timestamp.toLocaleTimeString()),
        event.message.trim()
      ),
      event
    ));
  }
  /**
   * Reads all new log events from a CloudWatch Log Group
   * starting at either the time the hotswap was triggered or
   * when the last event was read on the previous tick
   */
  async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
    const events = [];
    const startTime = logGroupsAccessSettings.logGroupsStartTimes[logGroupName] ?? this.startTime;
    let endTime = startTime;
    try {
      const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
        logGroupName,
        limit: 100,
        startTime
      });
      const filteredEvents = response.events ?? [];
      for (const event of filteredEvents) {
        if (event.message) {
          events.push({
            message: event.message,
            logGroupName,
            timestamp: event.timestamp ? new Date(event.timestamp) : /* @__PURE__ */ new Date()
          });
          if (event.timestamp && endTime < event.timestamp) {
            endTime = event.timestamp;
          }
        }
      }
      if (filteredEvents.length === 100 && response.nextToken) {
        events.push({
          message: ">>> `watch` shows only the first 100 log messages - the rest have been truncated...",
          logGroupName,
          timestamp: new Date(endTime)
        });
      }
    } catch (e) {
      if (e.name === "ResourceNotFoundException") {
        return [];
      }
      throw e;
    }
    logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
    return events;
  }
};

// ../tmp-toolkit-helpers/src/api/logs-monitor/find-cloudwatch-logs.ts
var IGNORE_LOGS_RESOURCE_TYPES = ["AWS::EC2::FlowLog", "AWS::CloudTrail::Trail", "AWS::CodeBuild::Project"];
async function findCloudWatchLogGroups(sdkProvider, ioHelper, stackArtifact) {
  let sdk;
  const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
  try {
    sdk = (await new EnvironmentAccess(sdkProvider, DEFAULT_TOOLKIT_STACK_NAME, ioHelper).accessStackForLookup(stackArtifact)).sdk;
  } catch (e) {
    await ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`Failed to access SDK environment: ${formatErrorMessage(e)}`));
    sdk = (await sdkProvider.forEnvironment(resolvedEnv, 0 /* ForReading */)).sdk;
  }
  const listStackResources = new LazyListStackResources(sdk, stackArtifact.stackName);
  const evaluateCfnTemplate = new EvaluateCloudFormationTemplate({
    stackArtifact,
    parameters: {},
    account: resolvedEnv.account,
    region: resolvedEnv.region,
    partition: (await sdk.currentAccount()).partition,
    sdk
  });
  const stackResources = await listStackResources.listStackResources();
  const logGroupNames = findAllLogGroupNames(stackResources, evaluateCfnTemplate);
  return {
    env: resolvedEnv,
    sdk,
    logGroupNames
  };
}
function isReferencedFromIgnoredResource(logGroupResource, evaluateCfnTemplate) {
  const resourcesReferencingLogGroup = evaluateCfnTemplate.findReferencesTo(logGroupResource.LogicalResourceId);
  return resourcesReferencingLogGroup.some((reference) => {
    return IGNORE_LOGS_RESOURCE_TYPES.includes(reference.Type);
  });
}
var cloudWatchLogsResolvers = {
  "AWS::Logs::LogGroup": (resource, evaluateCfnTemplate) => {
    if (isReferencedFromIgnoredResource(resource, evaluateCfnTemplate)) {
      return void 0;
    }
    return resource.PhysicalResourceId?.toString();
  },
  // Resource types that will create a CloudWatch log group with a specific name if one is not provided.
  // The keys are CFN resource types, and the values are the name of the physical name property of that resource
  // and the service name that is used in the automatically created CloudWatch log group.
  "AWS::Lambda::Function": (resource, evaluateCfnTemplate) => {
    const loggingConfig = evaluateCfnTemplate.getResourceProperty(resource.LogicalResourceId, "LoggingConfig");
    if (loggingConfig?.LogGroup) {
      if (typeof loggingConfig.LogGroup === "string") {
        return loggingConfig.LogGroup;
      }
      if (typeof loggingConfig.LogGroup === "object") {
        if (loggingConfig.LogGroup.Ref) {
          return evaluateCfnTemplate.getResourceProperty(loggingConfig.LogGroup.Ref, "LogGroupName");
        }
      }
    }
    return `/aws/lambda/${resource.PhysicalResourceId}`;
  }
};
function findAllLogGroupNames(stackResources, evaluateCfnTemplate) {
  const logGroupNames = [];
  for (const resource of stackResources) {
    const logGroupResolver = cloudWatchLogsResolvers[resource.ResourceType];
    if (logGroupResolver) {
      const logGroupName = logGroupResolver(resource, evaluateCfnTemplate);
      if (logGroupName) {
        logGroupNames.push(logGroupName);
      }
    }
  }
  return logGroupNames;
}

// ../tmp-toolkit-helpers/src/api/refactoring/index.ts
var import_cloudformation_diff2 = require("@aws-cdk/cloudformation-diff");

// ../tmp-toolkit-helpers/src/api/refactoring/digest.ts
var crypto2 = __toESM(require("node:crypto"));
var import_util40 = require("@aws-cdk/cloudformation-diff/lib/diff/util");
function computeResourceDigests(template) {
  const resources = template.Resources || {};
  const graph = {};
  const reverseGraph = {};
  for (const id of Object.keys(resources)) {
    graph[id] = /* @__PURE__ */ new Set();
    reverseGraph[id] = /* @__PURE__ */ new Set();
  }
  const findDependencies = (value) => {
    if (!value || typeof value !== "object") return [];
    if (Array.isArray(value)) {
      return value.flatMap(findDependencies);
    }
    if ("Ref" in value) {
      return [value.Ref];
    }
    if ("Fn::GetAtt" in value) {
      const refTarget = Array.isArray(value["Fn::GetAtt"]) ? value["Fn::GetAtt"][0] : value["Fn::GetAtt"].split(".")[0];
      return [refTarget];
    }
    if ("DependsOn" in value) {
      return [value.DependsOn];
    }
    return Object.values(value).flatMap(findDependencies);
  };
  for (const [id, res] of Object.entries(resources)) {
    const deps = findDependencies(res || {});
    for (const dep of deps) {
      if (dep in resources && dep !== id) {
        graph[id].add(dep);
        reverseGraph[dep].add(id);
      }
    }
  }
  const outDegree = Object.keys(graph).reduce((acc, k) => {
    acc[k] = graph[k].size;
    return acc;
  }, {});
  const queue = Object.keys(outDegree).filter((k) => outDegree[k] === 0);
  const order = [];
  while (queue.length > 0) {
    const node = queue.shift();
    order.push(node);
    for (const nxt of reverseGraph[node]) {
      outDegree[nxt]--;
      if (outDegree[nxt] === 0) {
        queue.push(nxt);
      }
    }
  }
  const result2 = {};
  for (const id of order) {
    const resource = resources[id];
    const resourceProperties = resource.Properties ?? {};
    const model = (0, import_util40.loadResourceModel)(resource.Type);
    const identifier = intersection2(Object.keys(resourceProperties), model?.primaryIdentifier ?? []);
    let toHash;
    if (identifier.length === model?.primaryIdentifier?.length) {
      toHash = resource.Type + identifier.sort().map((attr) => JSON.stringify(resourceProperties[attr])).join("");
    } else {
      const depDigests = Array.from(graph[id]).map((d) => result2[d]);
      const propertiesHash = hashObject(stripReferences(stripConstructPath(resource)));
      toHash = resource.Type + propertiesHash + depDigests.join("");
    }
    result2[id] = crypto2.createHash("sha256").update(toHash).digest("hex");
  }
  return result2;
}
function hashObject(obj) {
  const hash = crypto2.createHash("sha256");
  function addToHash(value) {
    if (value == null) {
      addToHash("null");
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        value.forEach(addToHash);
      } else {
        Object.keys(value).sort().forEach((key) => {
          hash.update(key);
          addToHash(value[key]);
        });
      }
    } else {
      hash.update(typeof value + value.toString());
    }
  }
  addToHash(obj);
  return hash.digest("hex");
}
function stripReferences(value) {
  if (!value || typeof value !== "object") return value;
  if (Array.isArray(value)) {
    return value.map(stripReferences);
  }
  if ("Ref" in value) {
    return { __cloud_ref__: "Ref" };
  }
  if ("Fn::GetAtt" in value) {
    return { __cloud_ref__: "Fn::GetAtt" };
  }
  if ("DependsOn" in value) {
    return { __cloud_ref__: "DependsOn" };
  }
  const result2 = {};
  for (const [k, v] of Object.entries(value)) {
    result2[k] = stripReferences(v);
  }
  return result2;
}
function stripConstructPath(resource) {
  if (resource?.Metadata?.["aws:cdk:path"] == null) {
    return resource;
  }
  const copy = JSON.parse(JSON.stringify(resource));
  delete copy.Metadata["aws:cdk:path"];
  return copy;
}
function intersection2(a, b) {
  return a.filter((value) => b.includes(value));
}

// ../tmp-toolkit-helpers/src/api/refactoring/index.ts
var AmbiguityError = class extends Error {
  constructor(movements) {
    super("Ambiguous resource mappings");
    this.movements = movements;
  }
  paths() {
    return this.movements.map(([a, b]) => [convert(a), convert(b)]);
    function convert(locations) {
      return locations.map((l) => l.toPath());
    }
  }
};
var ResourceLocation = class {
  constructor(stack, logicalResourceId) {
    this.stack = stack;
    this.logicalResourceId = logicalResourceId;
  }
  toPath() {
    const stack = this.stack;
    const resource = stack.template.Resources?.[this.logicalResourceId];
    const result2 = resource?.Metadata?.["aws:cdk:path"];
    if (result2 != null) {
      return result2;
    }
    return `${stack.stackName}.${this.logicalResourceId}`;
  }
  getType() {
    const resource = this.stack.template.Resources?.[this.logicalResourceId ?? ""];
    return resource?.Type ?? "Unknown";
  }
  equalTo(other) {
    return this.logicalResourceId === other.logicalResourceId && this.stack.stackName === other.stack.stackName;
  }
};
var ResourceMapping = class {
  constructor(source, destination) {
    this.source = source;
    this.destination = destination;
  }
  toTypedMapping() {
    return {
      // the type is the same in both source and destination,
      // so we can use either one
      type: this.source.getType(),
      sourcePath: this.source.toPath(),
      destinationPath: this.destination.toPath()
    };
  }
};
function groupByKey(entries) {
  const result2 = {};
  for (const [hash, location] of entries) {
    if (hash in result2) {
      result2[hash].push(location);
    } else {
      result2[hash] = [location];
    }
  }
  return result2;
}
function resourceMovements(before, after) {
  return Object.values(
    removeUnmovedResources(
      zip(groupByKey(before.flatMap(resourceDigests)), groupByKey(after.flatMap(resourceDigests)))
    )
  );
}
function ambiguousMovements(movements) {
  return movements.filter(([pre, post]) => pre.length > 0 && post.length > 0).filter(([pre, post]) => pre.length > 1 || post.length > 1);
}
function resourceMappings(movements) {
  return movements.filter(([pre, post]) => pre.length === 1 && post.length === 1 && !pre[0].equalTo(post[0])).map(([pre, post]) => new ResourceMapping(pre[0], post[0]));
}
function removeUnmovedResources(m) {
  const result2 = {};
  for (const [hash, [before, after]] of Object.entries(m)) {
    const common = before.filter((b) => after.some((a) => a.equalTo(b)));
    result2[hash] = [
      before.filter((b) => !common.some((c) => b.equalTo(c))),
      after.filter((a) => !common.some((c) => a.equalTo(c)))
    ];
  }
  return result2;
}
function zip(m1, m2) {
  const result2 = {};
  for (const [hash, locations] of Object.entries(m1)) {
    if (hash in m2) {
      result2[hash] = [locations, m2[hash]];
    } else {
      result2[hash] = [locations, []];
    }
  }
  for (const [hash, locations] of Object.entries(m2)) {
    if (!(hash in m1)) {
      result2[hash] = [[], locations];
    }
  }
  return result2;
}
function resourceDigests(stack) {
  const digests = computeResourceDigests(stack.template);
  return Object.entries(digests).map(([logicalId, digest]) => {
    const location = new ResourceLocation(stack, logicalId);
    return [digest, location];
  });
}
async function findResourceMovements(stacks, sdkProvider) {
  const stackGroups = /* @__PURE__ */ new Map();
  for (const stack of stacks) {
    const environment = stack.environment;
    const key = hashObject(environment);
    if (stackGroups.has(key)) {
      stackGroups.get(key)[1].push(stack);
    } else {
      const before = await getDeployedStacks(sdkProvider, environment);
      stackGroups.set(key, [before, [stack]]);
    }
  }
  const result2 = [];
  for (const [_, [before, after]] of stackGroups) {
    result2.push(...resourceMovements(before, after));
  }
  return result2;
}
async function getDeployedStacks(sdkProvider, environment) {
  const cfn = (await sdkProvider.forEnvironment(environment, 0 /* ForReading */)).sdk.cloudFormation();
  const summaries = await cfn.paginatedListStacks({
    StackStatusFilter: [
      "CREATE_COMPLETE",
      "UPDATE_COMPLETE",
      "UPDATE_ROLLBACK_COMPLETE",
      "IMPORT_COMPLETE",
      "ROLLBACK_COMPLETE"
    ]
  });
  const normalize = async (summary) => {
    const templateCommandOutput = await cfn.getTemplate({ StackName: summary.StackName });
    const template = deserializeStructure(templateCommandOutput.TemplateBody ?? "{}");
    return {
      environment,
      stackName: summary.StackName,
      template
    };
  };
  return Promise.all(summaries.map(normalize));
}
function formatTypedMappings(mappings) {
  const stream = new StringWriteStream();
  (0, import_cloudformation_diff2.formatTypedMappings)(stream, mappings);
  return stream.toString();
}
function formatAmbiguousMappings(paths) {
  const stream = new StringWriteStream();
  (0, import_cloudformation_diff2.formatAmbiguousMappings)(stream, paths);
  return stream.toString();
}

// ../tmp-toolkit-helpers/src/api/resource-import/importer.ts
var import_util42 = require("util");
var cfnDiff = __toESM(require("@aws-cdk/cloudformation-diff"));
var chalk14 = __toESM(require("chalk"));
var fs13 = __toESM(require("fs-extra"));
var promptly3 = __toESM(require("promptly"));
var ResourceImporter = class {
  _currentTemplate;
  stack;
  cfn;
  ioHelper;
  constructor(stack, props) {
    this.stack = stack;
    this.cfn = props.deployments;
    this.ioHelper = props.ioHelper;
  }
  /**
   * Ask the user for resources to import
   */
  async askForResourceIdentifiers(available) {
    const ret = { importResources: [], resourceMap: {} };
    const resourceIdentifiers = await this.resourceIdentifiers();
    for (const resource of available) {
      const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
      if (!identifier) {
        continue;
      }
      ret.importResources.push(resource);
      ret.resourceMap[resource.logicalId] = identifier;
    }
    return ret;
  }
  /**
   * Load the resources to import from a file
   */
  async loadResourceIdentifiers(available, filename) {
    const contents = await fs13.readJson(filename);
    const ret = { importResources: [], resourceMap: {} };
    for (const resource of available) {
      const descr = this.describeResource(resource.logicalId);
      const idProps = contents[resource.logicalId];
      if (idProps) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util42.format)("%s: importing using %s", chalk14.blue(descr), chalk14.blue(fmtdict(idProps)))));
        ret.importResources.push(resource);
        ret.resourceMap[resource.logicalId] = idProps;
        delete contents[resource.logicalId];
      } else {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg((0, import_util42.format)("%s: skipping", chalk14.blue(descr))));
      }
    }
    const unknown = Object.keys(contents);
    if (unknown.length > 0) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`Unrecognized resource identifiers in mapping file: ${unknown.join(", ")}`));
    }
    return ret;
  }
  /**
   * Based on the provided resource mapping, prepare CFN structures for import (template,
   * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
   *
   * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
   * @param options Options to pass to CloudFormation deploy operation
   */
  async importResourcesFromMap(importMap, options = {}) {
    const resourcesToImport = await this.makeResourcesToImport(importMap);
    const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
    await this.importResources(updatedTemplate, resourcesToImport, options);
  }
  /**
   * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
   * cannot be included in an import change-set for new stacks and performs the import operation,
   * creating the new stack.
   *
   * @param resourcesToImport The mapping created by cdk migrate
   * @param options Options to pass to CloudFormation deploy operation
   */
  async importResourcesFromMigrate(resourcesToImport, options = {}) {
    const updatedTemplate = this.removeNonImportResources();
    await this.importResources(updatedTemplate, resourcesToImport, options);
  }
  async importResources(overrideTemplate, resourcesToImport, options) {
    try {
      const result2 = await this.cfn.deployStack({
        stack: this.stack,
        deployName: this.stack.stackName,
        ...options,
        overrideTemplate,
        resourcesToImport
      });
      assertIsSuccessfulDeployStackResult(result2);
      const message2 = result2.noOp ? " \u2705  %s (no changes)" : " \u2705  %s";
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg("\n" + chalk14.green((0, import_util42.format)(message2, this.stack.displayName))));
    } catch (e) {
      await this.ioHelper.notify(IO.CDK_TOOLKIT_E3900.msg((0, import_util42.format)("\n \u274C  %s failed: %s", chalk14.bold(this.stack.displayName), e), { error: e }));
      throw e;
    }
  }
  /**
   * Perform a diff between the currently running and the new template, ensure that it is valid
   * for importing and return a list of resources that are being added in the new version
   *
   * @return mapping logicalResourceId -> resourceDifference
   */
  async discoverImportableResources(allowNonAdditions = false) {
    const currentTemplate = await this.currentTemplate();
    const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
    const resourceChanges = Object.entries(diff.resources.changes).filter(([logicalId, _]) => logicalId !== "CDKMetadata");
    const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
    const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
    if (nonAdditions.length) {
      const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
      if (allowNonAdditions) {
        await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`Ignoring updated/deleted resources (--force): ${offendingResources.join(", ")}`));
      } else {
        throw new ToolkitError(`No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(", ")} (--force to override)`);
      }
    }
    return {
      additions: additions.map(([logicalId, resourceDiff]) => ({
        logicalId,
        resourceDiff,
        resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {})
      })),
      hasNonAdditions: nonAdditions.length > 0
    };
  }
  /**
   * Resolves the environment of a stack.
   */
  async resolveEnvironment() {
    return this.cfn.resolveEnvironment(this.stack);
  }
  /**
   * Get currently deployed template of the given stack (SINGLETON)
   *
   * @returns Currently deployed CloudFormation template
   */
  async currentTemplate() {
    if (!this._currentTemplate) {
      this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
    }
    return this._currentTemplate;
  }
  /**
   * Return the current template, with the given resources added to it
   */
  async currentTemplateWithAdditions(additions) {
    const template = await this.currentTemplate();
    if (!template.Resources) {
      template.Resources = {};
    }
    for (const add of additions) {
      template.Resources[add.logicalId] = add.resourceDefinition;
    }
    return template;
  }
  /**
   * Get a list of import identifiers for all resource types used in the given
   * template that do support the import operation (SINGLETON)
   *
   * @returns a mapping from a resource type to a list of property names that together identify the resource for import
   */
  async resourceIdentifiers() {
    const ret = {};
    const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
    for (const summary of resourceIdentifierSummaries) {
      if ("ResourceType" in summary && summary.ResourceType && "ResourceIdentifiers" in summary && summary.ResourceIdentifiers) {
        ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map((x) => x.split(","));
      }
    }
    return ret;
  }
  /**
   * Ask for the importable identifier for the given resource
   *
   * There may be more than one identifier under which a resource can be imported. The `import`
   * operation needs exactly one of them.
   *
   * - If we can get one from the template, we will use one.
   * - Otherwise, we will ask the user for one of them.
   */
  async askForResourceIdentifier(resourceIdentifiers, chg) {
    const resourceName = this.describeResource(chg.logicalId);
    const resourceType = chg.resourceDiff.newResourceType;
    if (resourceType === void 0 || !(resourceType in resourceIdentifiers)) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_WARN.msg(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`));
      return void 0;
    }
    const idPropSets = resourceIdentifiers[resourceType];
    const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {}).filter(([_, v]) => typeof v === "string"));
    const satisfiedPropSets = idPropSets.filter((ps) => ps.every((p) => resourceProps[p]));
    for (const satisfiedPropSet of satisfiedPropSets) {
      const candidateProps = Object.fromEntries(satisfiedPropSet.map((p) => [p, resourceProps[p]]));
      const displayCandidateProps = fmtdict(candidateProps);
      if (await promptly3.confirm(
        `${chalk14.blue(resourceName)} (${resourceType}): import with ${chalk14.yellow(displayCandidateProps)} (yes/no) [default: yes]? `,
        { default: "yes" }
      )) {
        return candidateProps;
      }
    }
    if (satisfiedPropSets.length > 0) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(chalk14.grey(`Skipping import of ${resourceName}`)));
      return void 0;
    }
    const prefix = `${chalk14.blue(resourceName)} (${resourceType})`;
    let preamble;
    let promptPattern;
    if (idPropSets.length > 1) {
      preamble = `${prefix}: enter one of ${idPropSets.map((x) => chalk14.blue(x.join("+"))).join(", ")} to import (all empty to skip)`;
      promptPattern = `${prefix}: enter %`;
    } else {
      promptPattern = `${prefix}: enter %`;
    }
    if (preamble) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(preamble));
    }
    for (const idProps of idPropSets) {
      const input = {};
      for (const idProp of idProps) {
        const defaultValue = resourceProps[idProp] ?? "";
        const prompt4 = [
          promptPattern.replace(/%/g, chalk14.blue(idProp)),
          defaultValue ? `[${defaultValue}]` : "(empty to skip)"
        ].join(" ") + ":";
        const response = await promptly3.prompt(
          prompt4,
          { default: defaultValue, trim: true }
        );
        if (!response) {
          break;
        }
        input[idProp] = response;
        resourceProps[idProp] = response;
      }
      if (Object.keys(input).length === idProps.length) {
        return input;
      }
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(chalk14.grey(`Skipping import of ${resourceName}`)));
    return void 0;
  }
  /**
   * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
   */
  async makeResourcesToImport(resourceMap) {
    return resourceMap.importResources.map((res) => ({
      LogicalResourceId: res.logicalId,
      ResourceType: res.resourceDiff.newResourceType,
      ResourceIdentifier: resourceMap.resourceMap[res.logicalId]
    }));
  }
  /**
   * Convert CloudFormation logical resource ID to CDK construct tree path
   *
   * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
   * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
   */
  describeResource(logicalId) {
    return this.stack.template?.Resources?.[logicalId]?.Metadata?.["aws:cdk:path"] ?? logicalId;
  }
  /**
   * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
   * @returns template with import resources only
   */
  removeNonImportResources() {
    return removeNonImportResources(this.stack);
  }
};
function fmtdict(xs) {
  return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(", ");
}
function addDefaultDeletionPolicy(resource) {
  if (resource.DeletionPolicy) {
    return resource;
  }
  return {
    ...resource,
    DeletionPolicy: "Retain"
  };
}
function removeNonImportResources(stack) {
  const template = stack.template;
  delete template.Resources.CDKMetadata;
  delete template.Outputs;
  return template;
}

// ../tmp-toolkit-helpers/src/api/resource-import/migrator.ts
var chalk15 = __toESM(require("chalk"));
var fs14 = __toESM(require("fs-extra"));
var ResourceMigrator = class {
  props;
  ioHelper;
  constructor(props) {
    this.props = props;
    this.ioHelper = props.ioHelper;
  }
  /**
   * Checks to see if a migrate.json file exists. If it does and the source is either `filepath` or
   * is in the same environment as the stack deployment, a new stack is created and the resources are
   * migrated to the stack using an IMPORT changeset. The normal deployment will resume after this is complete
   * to add back in any outputs and the CDKMetadata.
   */
  async tryMigrateResources(stacks, options) {
    const stack = stacks.stackArtifacts[0];
    const migrateDeployment = new ResourceImporter(stack, {
      deployments: this.props.deployments,
      ioHelper: this.ioHelper
    });
    const resourcesToImport = await this.tryGetResources(await migrateDeployment.resolveEnvironment());
    if (resourcesToImport) {
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(`${chalk15.bold(stack.displayName)}: creating stack for resource migration...`));
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(`${chalk15.bold(stack.displayName)}: importing resources into stack...`));
      await this.performResourceMigration(migrateDeployment, resourcesToImport, options);
      fs14.rmSync("migrate.json");
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_INFO.msg(`${chalk15.bold(stack.displayName)}: applying CDKMetadata and Outputs to stack (if applicable)...`));
    }
  }
  /**
   * Creates a new stack with just the resources to be migrated
   */
  async performResourceMigration(migrateDeployment, resourcesToImport, options) {
    const startDeployTime = (/* @__PURE__ */ new Date()).getTime();
    let elapsedDeployTime = 0;
    await migrateDeployment.importResourcesFromMigrate(resourcesToImport, {
      roleArn: options.roleArn,
      deploymentMethod: options.deploymentMethod,
      usePreviousParameters: true,
      rollback: options.rollback
    });
    elapsedDeployTime = (/* @__PURE__ */ new Date()).getTime() - startDeployTime;
    await this.ioHelper.notify(IO.CDK_TOOLKIT_I5002.msg(`'
\u2728  Resource migration time: ${formatTime(elapsedDeployTime)}s
'`, {
      duration: elapsedDeployTime
    }));
  }
  async tryGetResources(environment) {
    try {
      const migrateFile = fs14.readJsonSync("migrate.json", {
        encoding: "utf-8"
      });
      const sourceEnv = migrateFile.Source.split(":");
      if (sourceEnv[0] === "localfile" || sourceEnv[4] === environment.account && sourceEnv[3] === environment.region) {
        return migrateFile.Resources;
      }
    } catch (e) {
    }
    return void 0;
  }
};

// ../tmp-toolkit-helpers/src/api/rwlock.ts
var import_fs = require("fs");
var path12 = __toESM(require("path"));
var RWLock = class {
  constructor(directory) {
    this.directory = directory;
    this.pidString = `${process.pid}`;
    this.writerFile = path12.join(this.directory, "synth.lock");
  }
  pidString;
  writerFile;
  readCounter = 0;
  /**
   * Acquire a writer lock.
   *
   * No other readers or writers must exist for the given directory.
   */
  async acquireWrite() {
    await this.assertNoOtherWriters();
    const readers = await this._currentReaders();
    if (readers.length > 0) {
      throw new ToolkitError(`Other CLIs (PID=${readers}) are currently reading from ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
    }
    await writeFileAtomic(this.writerFile, this.pidString);
    let released = false;
    return {
      release: async () => {
        if (!released) {
          await deleteFile(this.writerFile);
          released = true;
        }
      },
      convertToReaderLock: async () => {
        const ret = await this.doAcquireRead();
        await deleteFile(this.writerFile);
        return ret;
      }
    };
  }
  /**
   * Acquire a read lock
   *
   * Will fail if there are any writers.
   */
  async acquireRead() {
    await this.assertNoOtherWriters();
    return this.doAcquireRead();
  }
  /**
   * Obtains the name fo a (new) `readerFile` to use. This includes a counter so
   * that if multiple threads of the same PID attempt to concurrently acquire
   * the same lock, they're guaranteed to use a different reader file name (only
   * one thread will ever execute JS code at once, guaranteeing the readCounter
   * is incremented "atomically" from the point of view of this PID.).
   */
  readerFile() {
    return path12.join(this.directory, `read.${this.pidString}.${++this.readCounter}.lock`);
  }
  /**
   * Do the actual acquiring of a read lock.
   */
  async doAcquireRead() {
    const readerFile = this.readerFile();
    await writeFileAtomic(readerFile, this.pidString);
    let released = false;
    return {
      release: async () => {
        if (!released) {
          await deleteFile(readerFile);
          released = true;
        }
      }
    };
  }
  async assertNoOtherWriters() {
    const writer = await this._currentWriter();
    if (writer) {
      throw new ToolkitError(`Another CLI (PID=${writer}) is currently synthing to ${this.directory}. Invoke the CLI in sequence, or use '--output' to synth into different directories.`);
    }
  }
  /**
   * Check the current writer (if any)
   *
   * Publicly accessible for testing purposes. Do not use.
   *
   * @internal
   */
  async _currentWriter() {
    const contents = await readFileIfExists(this.writerFile);
    if (!contents) {
      return void 0;
    }
    const pid = parseInt(contents, 10);
    if (!processExists(pid)) {
      await deleteFile(this.writerFile);
      return void 0;
    }
    return pid;
  }
  /**
   * Check the current readers (if any)
   *
   * Publicly accessible for testing purposes. Do not use.
   *
   * @internal
   */
  async _currentReaders() {
    const re = /^read\.([^.]+)\.[^.]+\.lock$/;
    const ret = new Array();
    let children;
    try {
      children = await import_fs.promises.readdir(this.directory, { encoding: "utf-8" });
    } catch (e) {
      if (e.code === "ENOENT") {
        return [];
      }
      throw e;
    }
    for (const fname of children) {
      const m = fname.match(re);
      if (m) {
        const pid = parseInt(m[1], 10);
        if (processExists(pid)) {
          ret.push(pid);
        } else {
          await deleteFile(path12.join(this.directory, fname));
        }
      }
    }
    return ret;
  }
};
async function readFileIfExists(filename) {
  try {
    return await import_fs.promises.readFile(filename, { encoding: "utf-8" });
  } catch (e) {
    if (e.code === "ENOENT") {
      return void 0;
    }
    throw e;
  }
}
var tmpCounter = 0;
async function writeFileAtomic(filename, contents) {
  await import_fs.promises.mkdir(path12.dirname(filename), { recursive: true });
  const tmpFile = `${filename}.${process.pid}_${++tmpCounter}`;
  await import_fs.promises.writeFile(tmpFile, contents, { encoding: "utf-8" });
  await import_fs.promises.rename(tmpFile, filename);
}
async function deleteFile(filename) {
  try {
    await import_fs.promises.unlink(filename);
  } catch (e) {
    if (e.code === "ENOENT") {
      return;
    }
    throw e;
  }
}
function processExists(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return false;
  }
}

// ../tmp-toolkit-helpers/src/api/work-graph/work-graph-types.ts
var DeploymentState = /* @__PURE__ */ ((DeploymentState2) => {
  DeploymentState2["PENDING"] = "pending";
  DeploymentState2["QUEUED"] = "queued";
  DeploymentState2["DEPLOYING"] = "deploying";
  DeploymentState2["COMPLETED"] = "completed";
  DeploymentState2["FAILED"] = "failed";
  DeploymentState2["SKIPPED"] = "skipped";
  return DeploymentState2;
})(DeploymentState || {});

// ../tmp-toolkit-helpers/src/api/work-graph/work-graph.ts
var WorkGraph = class {
  nodes;
  readyPool = [];
  lazyDependencies = /* @__PURE__ */ new Map();
  ioHelper;
  error;
  constructor(nodes, ioHelper) {
    this.nodes = { ...nodes };
    this.ioHelper = ioHelper;
  }
  addNodes(...nodes) {
    for (const node of nodes) {
      if (this.nodes[node.id]) {
        throw new ToolkitError(`Duplicate use of node id: ${node.id}`);
      }
      const ld = this.lazyDependencies.get(node.id);
      if (ld) {
        for (const x of ld) {
          node.dependencies.add(x);
        }
        this.lazyDependencies.delete(node.id);
      }
      this.nodes[node.id] = node;
    }
  }
  removeNode(nodeId) {
    const id = typeof nodeId === "string" ? nodeId : nodeId.id;
    const removedNode = this.nodes[id];
    this.lazyDependencies.delete(id);
    delete this.nodes[id];
    if (removedNode) {
      for (const node of Object.values(this.nodes)) {
        node.dependencies.delete(removedNode.id);
      }
    }
  }
  /**
   * Return all nodes of a given type
   */
  nodesOfType(type) {
    return Object.values(this.nodes).filter((n) => n.type === type);
  }
  /**
   * Return all nodes that depend on a given node
   */
  dependees(nodeId) {
    const id = typeof nodeId === "string" ? nodeId : nodeId.id;
    return Object.values(this.nodes).filter((n) => n.dependencies.has(id));
  }
  /**
   * Add a dependency, that may come before or after the nodes involved
   */
  addDependency(fromId, toId) {
    const node = this.nodes[fromId];
    if (node) {
      node.dependencies.add(toId);
      return;
    }
    let lazyDeps = this.lazyDependencies.get(fromId);
    if (!lazyDeps) {
      lazyDeps = [];
      this.lazyDependencies.set(fromId, lazyDeps);
    }
    lazyDeps.push(toId);
  }
  tryGetNode(id) {
    return this.nodes[id];
  }
  node(id) {
    const ret = this.nodes[id];
    if (!ret) {
      throw new ToolkitError(`No node with id ${id} among ${Object.keys(this.nodes)}`);
    }
    return ret;
  }
  absorb(graph) {
    this.addNodes(...Object.values(graph.nodes));
  }
  hasFailed() {
    return Object.values(this.nodes).some((n) => n.deploymentState === "failed" /* FAILED */);
  }
  doParallel(concurrency, actions) {
    return this.forAllArtifacts(concurrency, async (x) => {
      switch (x.type) {
        case "stack":
          await actions.deployStack(x);
          break;
        case "asset-build":
          await actions.buildAsset(x);
          break;
        case "asset-publish":
          await actions.publishAsset(x);
          break;
      }
    });
  }
  /**
   * Return the set of unblocked nodes
   */
  async ready() {
    await this.updateReadyPool();
    return this.readyPool;
  }
  forAllArtifacts(n, fn) {
    const graph = this;
    const max = typeof n === "number" ? {
      "asset-build": n,
      "asset-publish": n,
      "stack": n
    } : n;
    const totalMax = typeof n === "number" ? n : sum(Object.values(n));
    return new Promise((ok, fail) => {
      let active = {
        "asset-build": 0,
        "asset-publish": 0,
        "stack": 0
      };
      function totalActive() {
        return sum(Object.values(active));
      }
      start();
      function start() {
        graph.updateReadyPool().then(() => {
          for (let i = 0; i < graph.readyPool.length; ) {
            const node = graph.readyPool[i];
            if (active[node.type] < max[node.type] && totalActive() < totalMax) {
              graph.readyPool.splice(i, 1);
              startOne(node);
            } else {
              i += 1;
            }
          }
          if (totalActive() === 0) {
            if (graph.done()) {
              ok();
            }
            if (graph.hasFailed()) {
              fail(graph.error);
            }
          }
        }).catch((e) => {
          fail(e);
        });
      }
      function startOne(x) {
        x.deploymentState = "deploying" /* DEPLOYING */;
        active[x.type]++;
        void fn(x).finally(() => {
          active[x.type]--;
        }).then(() => {
          graph.deployed(x);
          start();
        }).catch((err) => {
          graph.failed(x, err);
          start();
        });
      }
    });
  }
  done() {
    return Object.values(this.nodes).every((n) => "completed" /* COMPLETED */ === n.deploymentState);
  }
  deployed(node) {
    node.deploymentState = "completed" /* COMPLETED */;
  }
  failed(node, error2) {
    this.error = error2;
    node.deploymentState = "failed" /* FAILED */;
    this.skipRest();
    this.readyPool.splice(0);
  }
  toString() {
    return [
      "digraph D {",
      ...Object.entries(this.nodes).flatMap(([id, node]) => renderNode(id, node)),
      "}"
    ].join("\n");
    function renderNode(id, node) {
      const ret = [];
      if (node.deploymentState === "completed" /* COMPLETED */) {
        ret.push(`  ${gv(id, { style: "filled", fillcolor: "yellow", comment: node.note })};`);
      } else {
        ret.push(`  ${gv(id, { comment: node.note })};`);
      }
      for (const dep of node.dependencies) {
        ret.push(`  ${gv(id)} -> ${gv(dep)};`);
      }
      return ret;
    }
  }
  /**
   * Ensure all dependencies actually exist. This protects against scenarios such as the following:
   * StackA depends on StackB, but StackB is not selected to deploy. The dependency is redundant
   * and will be dropped.
   * This assumes the manifest comes uncorrupted so we will not fail if a dependency is not found.
   */
  removeUnavailableDependencies() {
    for (const node of Object.values(this.nodes)) {
      const removeDeps = Array.from(node.dependencies).filter((dep) => this.nodes[dep] === void 0);
      removeDeps.forEach((d) => {
        node.dependencies.delete(d);
      });
    }
  }
  /**
   * Remove all asset publishing steps for assets that are already published, and then build
   * that aren't used anymore.
   *
   * Do this in parallel, because there may be a lot of assets in an application (seen in practice: >100 assets)
   */
  async removeUnnecessaryAssets(isUnnecessary) {
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg("Checking for previously published assets"));
    const publishes = this.nodesOfType("asset-publish");
    const classifiedNodes = await parallelPromises(
      8,
      publishes.map((assetNode) => async () => [assetNode, await isUnnecessary(assetNode)])
    );
    const alreadyPublished = classifiedNodes.filter(([_, unnecessary]) => unnecessary).map(([assetNode, _]) => assetNode);
    for (const assetNode of alreadyPublished) {
      this.removeNode(assetNode);
    }
    await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_DEBUG.msg(`${publishes.length} total assets, ${publishes.length - alreadyPublished.length} still need to be published`));
    const unusedBuilds = this.nodesOfType("asset-build").filter((build) => this.dependees(build).length === 0);
    for (const unusedBuild of unusedBuilds) {
      this.removeNode(unusedBuild);
    }
  }
  async updateReadyPool() {
    const activeCount = Object.values(this.nodes).filter((x) => x.deploymentState === "deploying" /* DEPLOYING */).length;
    const pendingCount = Object.values(this.nodes).filter((x) => x.deploymentState === "pending" /* PENDING */).length;
    const newlyReady = Object.values(this.nodes).filter((x) => x.deploymentState === "pending" /* PENDING */ && Array.from(x.dependencies).every((id) => this.node(id).deploymentState === "completed" /* COMPLETED */));
    for (const node of newlyReady) {
      node.deploymentState = "queued" /* QUEUED */;
      this.readyPool.push(node);
    }
    retainOnly(this.readyPool, (node) => node.deploymentState === "queued" /* QUEUED */);
    this.readyPool.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
    if (this.readyPool.length === 0 && activeCount === 0 && pendingCount > 0) {
      const cycle = this.findCycle() ?? ["No cycle found!"];
      await this.ioHelper.notify(IO.DEFAULT_TOOLKIT_TRACE.msg(`Cycle ${cycle.join(" -> ")} in graph ${this}`));
      throw new ToolkitError(`Unable to make progress anymore, dependency cycle between remaining artifacts: ${cycle.join(" -> ")} (run with -vv for full graph)`);
    }
  }
  skipRest() {
    for (const node of Object.values(this.nodes)) {
      if (["queued" /* QUEUED */, "pending" /* PENDING */].includes(node.deploymentState)) {
        node.deploymentState = "skipped" /* SKIPPED */;
      }
    }
  }
  /**
   * Find cycles in a graph
   *
   * Not the fastest, but effective and should be rare
   */
  findCycle() {
    const seen = /* @__PURE__ */ new Set();
    const self = this;
    for (const nodeId of Object.keys(this.nodes)) {
      const cycle = recurse(nodeId, [nodeId]);
      if (cycle) {
        return cycle;
      }
    }
    return void 0;
    function recurse(nodeId, path13) {
      if (seen.has(nodeId)) {
        return void 0;
      }
      try {
        for (const dep of self.nodes[nodeId].dependencies ?? []) {
          const index = path13.indexOf(dep);
          if (index > -1) {
            return [...path13.slice(index), dep];
          }
          const cycle = recurse(dep, [...path13, dep]);
          if (cycle) {
            return cycle;
          }
        }
        return void 0;
      } finally {
        seen.add(nodeId);
      }
    }
  }
  /**
   * Whether the `end` node is reachable from the `start` node, following the dependency arrows
   */
  reachable(start, end) {
    const seen = /* @__PURE__ */ new Set();
    const self = this;
    return recurse(start);
    function recurse(current) {
      if (seen.has(current)) {
        return false;
      }
      seen.add(current);
      if (current === end) {
        return true;
      }
      for (const dep of self.nodes[current].dependencies) {
        if (recurse(dep)) {
          return true;
        }
      }
      return false;
    }
  }
};
function sum(xs) {
  let ret = 0;
  for (const x of xs) {
    ret += x;
  }
  return ret;
}
function retainOnly(xs, pred) {
  xs.splice(0, xs.length, ...xs.filter(pred));
}
function gv(id, attrs) {
  const attrString = Object.entries(attrs ?? {}).flatMap(([k, v]) => v !== void 0 ? [`${k}="${v}"`] : []).join(",");
  return attrString ? `"${simplifyId(id)}" [${attrString}]` : `"${simplifyId(id)}"`;
}
function simplifyId(id) {
  return id.replace(/([0-9a-f]{6})[0-9a-f]{6,}/g, "$1");
}

// ../tmp-toolkit-helpers/src/api/work-graph/work-graph-builder.ts
var cxapi4 = __toESM(require("@aws-cdk/cx-api"));
var import_cdk_assets4 = require("cdk-assets");
var WorkGraphBuilder = class _WorkGraphBuilder {
  constructor(ioHelper, prebuildAssets, idPrefix = "") {
    this.prebuildAssets = prebuildAssets;
    this.idPrefix = idPrefix;
    this.graph = new WorkGraph({}, ioHelper);
    this.ioHelper = ioHelper;
  }
  /**
   * Default priorities for nodes
   *
   * Assets builds have higher priority than the other two operations, to make good on our promise that
   * '--prebuild-assets' will actually do assets before stacks (if it can). Unfortunately it is the
   * default :(
   *
   * But between stack dependencies and publish dependencies, stack dependencies go first
   */
  static PRIORITIES = {
    "asset-build": 10,
    "asset-publish": 0,
    "stack": 5
  };
  graph;
  ioHelper;
  addStack(artifact) {
    this.graph.addNodes({
      type: "stack",
      id: `${this.idPrefix}${artifact.id}`,
      dependencies: new Set(this.stackArtifactIds(onlyStacks(artifact.dependencies))),
      stack: artifact,
      deploymentState: "pending" /* PENDING */,
      priority: _WorkGraphBuilder.PRIORITIES.stack
    });
  }
  /**
   * Oof, see this parameter list
   */
  // eslint-disable-next-line max-len
  addAsset(parentStack, assetManifestArtifact, assetManifest, asset) {
    const assetId = asset.id.assetId;
    const buildId = `build-${assetId}-${contentHashAny([assetId, asset.genericSource]).substring(0, 10)}`;
    const publishId = `publish-${assetId}-${contentHashAny([assetId, asset.genericDestination]).substring(0, 10)}`;
    if (!this.graph.tryGetNode(buildId)) {
      const node = {
        type: "asset-build",
        id: buildId,
        note: asset.displayName(false),
        dependencies: /* @__PURE__ */ new Set([
          ...this.stackArtifactIds(assetManifestArtifact.dependencies),
          // If we disable prebuild, then assets inherit (stack) dependencies from their parent stack
          ...!this.prebuildAssets ? this.stackArtifactIds(onlyStacks(parentStack.dependencies)) : []
        ]),
        parentStack,
        assetManifestArtifact,
        assetManifest,
        asset,
        deploymentState: "pending" /* PENDING */,
        priority: _WorkGraphBuilder.PRIORITIES["asset-build"]
      };
      this.graph.addNodes(node);
    }
    const publishNode = this.graph.tryGetNode(publishId);
    if (!publishNode) {
      this.graph.addNodes({
        type: "asset-publish",
        id: publishId,
        note: asset.displayName(true),
        dependencies: /* @__PURE__ */ new Set([
          buildId
        ]),
        parentStack,
        assetManifestArtifact,
        assetManifest,
        asset,
        deploymentState: "pending" /* PENDING */,
        priority: _WorkGraphBuilder.PRIORITIES["asset-publish"]
      });
    }
    for (const inheritedDep of this.stackArtifactIds(onlyStacks(parentStack.dependencies))) {
      this.graph.addDependency(publishId, inheritedDep);
    }
    this.graph.addDependency(`${this.idPrefix}${parentStack.id}`, publishId);
  }
  build(artifacts) {
    const parentStacks = stacksFromAssets(artifacts);
    for (const artifact of artifacts) {
      if (cxapi4.CloudFormationStackArtifact.isCloudFormationStackArtifact(artifact)) {
        this.addStack(artifact);
      } else if (cxapi4.AssetManifestArtifact.isAssetManifestArtifact(artifact)) {
        const manifest = import_cdk_assets4.AssetManifest.fromFile(artifact.file);
        for (const entry of manifest.entries) {
          const parentStack = parentStacks.get(artifact);
          if (parentStack === void 0) {
            throw new ToolkitError("Found an asset manifest that is not associated with a stack");
          }
          this.addAsset(parentStack, artifact, manifest, entry);
        }
      } else if (cxapi4.NestedCloudAssemblyArtifact.isNestedCloudAssemblyArtifact(artifact)) {
        const assembly = new cxapi4.CloudAssembly(artifact.fullPath, { topoSort: false });
        const nestedGraph = new _WorkGraphBuilder(
          this.ioHelper,
          this.prebuildAssets,
          `${this.idPrefix}${artifact.id}.`
        ).build(assembly.artifacts);
        this.graph.absorb(nestedGraph);
      } else {
      }
    }
    this.graph.removeUnavailableDependencies();
    this.removeStackPublishCycles();
    return this.graph;
  }
  stackArtifactIds(deps) {
    return deps.flatMap((d) => cxapi4.CloudFormationStackArtifact.isCloudFormationStackArtifact(d) ? [this.stackArtifactId(d)] : []);
  }
  stackArtifactId(artifact) {
    if (!cxapi4.CloudFormationStackArtifact.isCloudFormationStackArtifact(artifact)) {
      throw new ToolkitError(`Can only call this on CloudFormationStackArtifact, got: ${artifact.constructor.name}`);
    }
    return `${this.idPrefix}${artifact.id}`;
  }
  /**
   * We may have accidentally introduced cycles in an attempt to make the messages printed to the
   * console not interfere with each other too much. Remove them again.
   */
  removeStackPublishCycles() {
    const publishSteps = this.graph.nodesOfType("asset-publish");
    for (const publishStep of publishSteps) {
      for (const dep of publishStep.dependencies) {
        if (this.graph.reachable(dep, publishStep.id)) {
          publishStep.dependencies.delete(dep);
        }
      }
    }
  }
};
function stacksFromAssets(artifacts) {
  const ret = /* @__PURE__ */ new Map();
  for (const stack of artifacts.filter((x) => cxapi4.CloudFormationStackArtifact.isCloudFormationStackArtifact(x))) {
    const assetArtifacts = stack.dependencies.filter((x) => cxapi4.AssetManifestArtifact.isAssetManifestArtifact(x));
    for (const art of assetArtifacts) {
      ret.set(art, stack);
    }
  }
  return ret;
}
function onlyStacks(artifacts) {
  return artifacts.filter((x) => cxapi4.CloudFormationStackArtifact.isCloudFormationStackArtifact(x));
}

// ../tmp-toolkit-helpers/src/api/tags.ts
function tagsForStack(stack) {
  return Object.entries(stack.tags).map(([Key, Value]) => ({ Key, Value }));
}

// ../tmp-toolkit-helpers/src/context-providers/index.ts
var context_providers_exports = {};
__export(context_providers_exports, {
  provideContextValues: () => provideContextValues,
  registerContextProvider: () => registerContextProvider,
  registerContextProviderFactory: () => registerContextProviderFactory,
  registerPluginContextProvider: () => registerPluginContextProvider
});
var cxschema4 = __toESM(require("@aws-cdk/cloud-assembly-schema"));
var cxapi5 = __toESM(require("@aws-cdk/cx-api"));

// ../tmp-toolkit-helpers/src/context-providers/ami.ts
var AmiContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const region = args.region;
    const account = args.account;
    await this.io.info(`Searching for AMI in ${account}:${region}`);
    await this.io.debug(`AMI search parameters: ${JSON.stringify(args)}`);
    const ec2 = (await initContextProviderSdk(this.aws, args)).ec2();
    const response = await ec2.describeImages({
      Owners: args.owners,
      Filters: Object.entries(args.filters).map(([key, values]) => ({
        Name: key,
        Values: values
      }))
    });
    const images = [...response.Images || []].filter((i) => i.ImageId !== void 0);
    if (images.length === 0) {
      throw new ContextProviderError("No AMI found that matched the search criteria");
    }
    images.sort(descending((i) => Date.parse(i.CreationDate || "1970")));
    await this.io.debug(`Selected image '${images[0].ImageId}' created at '${images[0].CreationDate}'`);
    return images[0].ImageId;
  }
};
function descending(valueOf) {
  return (a, b) => {
    return valueOf(b) - valueOf(a);
  };
}

// ../tmp-toolkit-helpers/src/context-providers/availability-zones.ts
var AZContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const region = args.region;
    const account = args.account;
    await this.io.debug(`Reading AZs for ${account}:${region}`);
    const ec2 = (await initContextProviderSdk(this.aws, args)).ec2();
    const response = await ec2.describeAvailabilityZones({});
    if (!response.AvailabilityZones) {
      return [];
    }
    const azs = response.AvailabilityZones.filter((zone) => zone.State === "available").map(
      (zone) => zone.ZoneName
    );
    return azs;
  }
};

// ../tmp-toolkit-helpers/src/context-providers/cc-api-provider.ts
var import_client_cloudcontrol2 = require("@aws-sdk/client-cloudcontrol");
var CcApiContextProviderPlugin = class {
  constructor(aws) {
    this.aws = aws;
  }
  /**
   * This returns a data object with the value from CloudControl API result.
   *
   * See the documentation in the Cloud Assembly Schema for the semantics of
   * each query parameter.
   */
  async getValue(args) {
    if (args.exactIdentifier && args.propertyMatch) {
      throw new ContextProviderError(`Provider protocol error: specify either exactIdentifier or propertyMatch, but not both (got ${JSON.stringify(args)})`);
    }
    if (args.ignoreErrorOnMissingContext && args.dummyValue === void 0) {
      throw new ContextProviderError(`Provider protocol error: if ignoreErrorOnMissingContext is set, a dummyValue must be supplied (got ${JSON.stringify(args)})`);
    }
    if (args.dummyValue !== void 0 && (!Array.isArray(args.dummyValue) || !args.dummyValue.every(isObject2))) {
      throw new ContextProviderError(`Provider protocol error: dummyValue must be an array of objects (got ${JSON.stringify(args.dummyValue)})`);
    }
    const cloudControl = (await initContextProviderSdk(this.aws, args)).cloudControl();
    try {
      let resources;
      if (args.exactIdentifier) {
        resources = await this.getResource(cloudControl, args.typeName, args.exactIdentifier);
      } else if (args.propertyMatch) {
        resources = await this.listResources(cloudControl, args.typeName, args.propertyMatch, args.expectedMatchCount);
      } else {
        throw new ContextProviderError(`Provider protocol error: neither exactIdentifier nor propertyMatch is specified in ${JSON.stringify(args)}.`);
      }
      return resources.map((r) => getResultObj(r.properties, r.identifier, args.propertiesToReturn));
    } catch (err) {
      if (err instanceof ZeroResourcesFoundError && args.ignoreErrorOnMissingContext) {
        return args.dummyValue;
      }
      throw err;
    }
  }
  /**
   * Calls getResource from CC API to get the resource.
   * See https://docs.aws.amazon.com/cli/latest/reference/cloudcontrol/get-resource.html
   *
   * Will always return exactly one resource, or fail.
   */
  async getResource(cc, typeName, exactIdentifier) {
    try {
      const result2 = await cc.getResource({
        TypeName: typeName,
        Identifier: exactIdentifier
      });
      if (!result2.ResourceDescription) {
        throw new ContextProviderError("Unexpected CloudControl API behavior: returned empty response");
      }
      return [foundResourceFromCcApi(result2.ResourceDescription)];
    } catch (err) {
      if (err instanceof import_client_cloudcontrol2.ResourceNotFoundException || err.name === "ResourceNotFoundException") {
        throw new ZeroResourcesFoundError(`No resource of type ${typeName} with identifier: ${exactIdentifier}`);
      }
      if (!(err instanceof ContextProviderError)) {
        throw new ContextProviderError(`Encountered CC API error while getting ${typeName} resource ${exactIdentifier}: ${err.message}`);
      }
      throw err;
    }
  }
  /**
   * Calls listResources from CC API to get the resources and apply args.propertyMatch to find the resources.
   * See https://docs.aws.amazon.com/cli/latest/reference/cloudcontrol/list-resources.html
   *
   * Will return 0 or more resources.
   *
   * Does not currently paginate through more than one result page.
   */
  async listResources(cc, typeName, propertyMatch, expectedMatchCount) {
    try {
      const result2 = await cc.listResources({
        TypeName: typeName
      });
      const found = (result2.ResourceDescriptions ?? []).map(foundResourceFromCcApi).filter((r) => {
        return Object.entries(propertyMatch).every(([propPath, expected]) => {
          const actual = findJsonValue(r.properties, propPath);
          return propertyMatchesFilter(actual, expected);
        });
      });
      if ((expectedMatchCount === "at-least-one" || expectedMatchCount === "exactly-one") && found.length === 0) {
        throw new ZeroResourcesFoundError(`Could not find any resources matching ${JSON.stringify(propertyMatch)}`);
      }
      if ((expectedMatchCount === "at-most-one" || expectedMatchCount === "exactly-one") && found.length > 1) {
        throw new ContextProviderError(`Found ${found.length} resources matching ${JSON.stringify(propertyMatch)}; please narrow the search criteria`);
      }
      return found;
    } catch (err) {
      if (!(err instanceof ContextProviderError) && !(err instanceof ZeroResourcesFoundError)) {
        throw new ContextProviderError(`Encountered CC API error while listing ${typeName} resources matching ${JSON.stringify(propertyMatch)}: ${err.message}`);
      }
      throw err;
    }
  }
};
function foundResourceFromCcApi(desc) {
  return {
    identifier: desc.Identifier ?? "*MISSING*",
    properties: JSON.parse(desc.Properties ?? "{}")
  };
}
function propertyMatchesFilter(actual, expected) {
  return expected === actual;
}
function isObject2(x) {
  return typeof x === "object" && x !== null && !Array.isArray(x);
}
var ZeroResourcesFoundError = class extends Error {
};

// ../tmp-toolkit-helpers/src/context-providers/endpoint-service-availability-zones.ts
var EndpointServiceAZContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const region = args.region;
    const account = args.account;
    const serviceName = args.serviceName;
    await this.io.debug(`Reading AZs for ${account}:${region}:${serviceName}`);
    const ec2 = (await initContextProviderSdk(this.aws, args)).ec2();
    const response = await ec2.describeVpcEndpointServices({
      ServiceNames: [serviceName]
    });
    if (!response.ServiceDetails || response.ServiceDetails.length === 0) {
      await this.io.debug(`Could not retrieve service details for ${account}:${region}:${serviceName}`);
      return [];
    }
    const azs = response.ServiceDetails[0].AvailabilityZones;
    await this.io.debug(`Endpoint service ${account}:${region}:${serviceName} is available in availability zones ${azs}`);
    return azs;
  }
};

// ../tmp-toolkit-helpers/src/context-providers/hosted-zones.ts
var HostedZoneContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const account = args.account;
    const region = args.region;
    if (!this.isHostedZoneQuery(args)) {
      throw new ContextProviderError(`HostedZoneProvider requires domainName property to be set in ${args}`);
    }
    const domainName = args.domainName;
    await this.io.debug(`Reading hosted zone ${account}:${region}:${domainName}`);
    const r53 = (await initContextProviderSdk(this.aws, args)).route53();
    const response = await r53.listHostedZonesByName({ DNSName: domainName });
    if (!response.HostedZones) {
      throw new ContextProviderError(`Hosted Zone not found in account ${account}, region ${region}: ${domainName}`);
    }
    const candidateZones = await this.filterZones(r53, response.HostedZones, args);
    if (candidateZones.length !== 1) {
      const filteProps = `dns:${domainName}, privateZone:${args.privateZone}, vpcId:${args.vpcId}`;
      throw new ContextProviderError(`Found zones: ${JSON.stringify(candidateZones)} for ${filteProps}, but wanted exactly 1 zone`);
    }
    return {
      Id: candidateZones[0].Id,
      Name: candidateZones[0].Name
    };
  }
  async filterZones(r53, zones, props) {
    let candidates = [];
    const domainName = props.domainName.endsWith(".") ? props.domainName : `${props.domainName}.`;
    await this.io.debug(`Found the following zones ${JSON.stringify(zones)}`);
    candidates = zones.filter((zone) => zone.Name === domainName);
    await this.io.debug(`Found the following matched name zones ${JSON.stringify(candidates)}`);
    if (props.privateZone) {
      candidates = candidates.filter((zone) => zone.Config && zone.Config.PrivateZone);
    } else {
      candidates = candidates.filter((zone) => !zone.Config || !zone.Config.PrivateZone);
    }
    if (props.vpcId) {
      const vpcZones = [];
      for (const zone of candidates) {
        const data = await r53.getHostedZone({ Id: zone.Id });
        if (!data.VPCs) {
          await this.io.debug(`Expected VPC for private zone but no VPC found ${zone.Id}`);
          continue;
        }
        if (data.VPCs.map((vpc) => vpc.VPCId).includes(props.vpcId)) {
          vpcZones.push(zone);
        }
      }
      return vpcZones;
    }
    return candidates;
  }
  isHostedZoneQuery(props) {
    return props.domainName !== void 0;
  }
};

// ../tmp-toolkit-helpers/src/context-providers/keys.ts
var KeyContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const kms = (await initContextProviderSdk(this.aws, args)).kms();
    const aliasListEntry = await this.findKey(kms, args);
    return this.readKeyProps(aliasListEntry, args);
  }
  // TODO: use paginator function
  async findKey(kms, args) {
    await this.io.debug(`Listing keys in ${args.account}:${args.region}`);
    let response;
    let nextMarker;
    do {
      response = await kms.listAliases({
        Marker: nextMarker
      });
      const aliases = response.Aliases || [];
      for (const alias of aliases) {
        if (alias.AliasName == args.aliasName) {
          return alias;
        }
      }
      nextMarker = response.NextMarker;
    } while (nextMarker);
    const suppressError = "ignoreErrorOnMissingContext" in args && args.ignoreErrorOnMissingContext;
    const hasDummyKeyId = "dummyValue" in args && typeof args.dummyValue === "object" && args.dummyValue !== null && "keyId" in args.dummyValue;
    if (suppressError && hasDummyKeyId) {
      const keyId = args.dummyValue.keyId;
      return { TargetKeyId: keyId };
    }
    throw new ContextProviderError(`Could not find any key with alias named ${args.aliasName}`);
  }
  async readKeyProps(alias, args) {
    if (!alias.TargetKeyId) {
      throw new ContextProviderError(`Could not find any key with alias named ${args.aliasName}`);
    }
    await this.io.debug(`Key found ${alias.TargetKeyId}`);
    return {
      keyId: alias.TargetKeyId
    };
  }
};

// ../tmp-toolkit-helpers/src/context-providers/load-balancers.ts
var import_cx_api8 = require("@aws-cdk/cx-api");
var LoadBalancerContextProviderPlugin = class {
  constructor(aws) {
    this.aws = aws;
  }
  async getValue(query) {
    if (!query.loadBalancerArn && !query.loadBalancerTags) {
      throw new ContextProviderError("The load balancer lookup query must specify either `loadBalancerArn` or `loadBalancerTags`");
    }
    const loadBalancer = await (await LoadBalancerProvider.getClient(this.aws, query)).getLoadBalancer();
    const ipAddressType = loadBalancer.IpAddressType === "ipv4" ? import_cx_api8.LoadBalancerIpAddressType.IPV4 : import_cx_api8.LoadBalancerIpAddressType.DUAL_STACK;
    return {
      loadBalancerArn: loadBalancer.LoadBalancerArn,
      loadBalancerCanonicalHostedZoneId: loadBalancer.CanonicalHostedZoneId,
      loadBalancerDnsName: loadBalancer.DNSName,
      vpcId: loadBalancer.VpcId,
      securityGroupIds: loadBalancer.SecurityGroups ?? [],
      ipAddressType
    };
  }
};
var LoadBalancerListenerContextProviderPlugin = class {
  constructor(aws) {
    this.aws = aws;
  }
  async getValue(query) {
    if (!query.listenerArn && !query.loadBalancerArn && !query.loadBalancerTags) {
      throw new ContextProviderError(
        "The load balancer listener query must specify at least one of: `listenerArn`, `loadBalancerArn` or `loadBalancerTags`"
      );
    }
    return (await LoadBalancerProvider.getClient(this.aws, query)).getListener();
  }
};
var LoadBalancerProvider = class _LoadBalancerProvider {
  constructor(client, filter, listener) {
    this.client = client;
    this.filter = filter;
    this.listener = listener;
  }
  static async getClient(aws, query) {
    const client = (await initContextProviderSdk(aws, query)).elbv2();
    try {
      const listener = query.listenerArn ? (
        // Assert we're sure there's at least one so it throws if not
        (await client.describeListeners({ ListenerArns: [query.listenerArn] })).Listeners[0]
      ) : void 0;
      return new _LoadBalancerProvider(
        client,
        { ...query, loadBalancerArn: listener?.LoadBalancerArn || query.loadBalancerArn },
        listener
      );
    } catch (err) {
      throw new ContextProviderError(`No load balancer listeners found matching arn ${query.listenerArn}`);
    }
  }
  async getLoadBalancer() {
    const loadBalancers = await this.getLoadBalancers();
    if (loadBalancers.length === 0) {
      throw new ContextProviderError(`No load balancers found matching ${JSON.stringify(this.filter)}`);
    }
    if (loadBalancers.length > 1) {
      throw new ContextProviderError(
        `Multiple load balancers found matching ${JSON.stringify(this.filter)} - please provide more specific criteria`
      );
    }
    return loadBalancers[0];
  }
  async getListener() {
    if (this.listener) {
      try {
        const loadBalancer = await this.getLoadBalancer();
        return {
          listenerArn: this.listener.ListenerArn,
          listenerPort: this.listener.Port,
          securityGroupIds: loadBalancer.SecurityGroups || []
        };
      } catch (err) {
        throw new ContextProviderError(`No associated load balancer found for listener arn ${this.filter.listenerArn}`);
      }
    }
    const loadBalancers = await this.getLoadBalancers();
    if (loadBalancers.length === 0) {
      throw new ContextProviderError(
        `No associated load balancers found for load balancer listener query ${JSON.stringify(this.filter)}`
      );
    }
    const listeners = (await this.getListenersForLoadBalancers(loadBalancers)).filter((listener) => {
      return (!this.filter.listenerPort || listener.Port === this.filter.listenerPort) && (!this.filter.listenerProtocol || listener.Protocol === this.filter.listenerProtocol);
    });
    if (listeners.length === 0) {
      throw new ContextProviderError(`No load balancer listeners found matching ${JSON.stringify(this.filter)}`);
    }
    if (listeners.length > 1) {
      throw new ContextProviderError(
        `Multiple load balancer listeners found matching ${JSON.stringify(this.filter)} - please provide more specific criteria`
      );
    }
    return {
      listenerArn: listeners[0].ListenerArn,
      listenerPort: listeners[0].Port,
      securityGroupIds: loadBalancers.find((lb) => listeners[0].LoadBalancerArn === lb.LoadBalancerArn)?.SecurityGroups || []
    };
  }
  async getLoadBalancers() {
    const loadBalancerArns = this.filter.loadBalancerArn ? [this.filter.loadBalancerArn] : void 0;
    const loadBalancers = (await this.client.paginateDescribeLoadBalancers({
      LoadBalancerArns: loadBalancerArns
    })).filter((lb) => lb.Type === this.filter.loadBalancerType);
    return this.filterByTags(loadBalancers);
  }
  async filterByTags(loadBalancers) {
    if (!this.filter.loadBalancerTags) {
      return loadBalancers;
    }
    return (await this.describeTags(loadBalancers.map((lb) => lb.LoadBalancerArn))).filter((tagDescription) => {
      return this.filter.loadBalancerTags.every((filter) => {
        return tagDescription.Tags?.some((tag) => filter.key === tag.Key && filter.value === tag.Value);
      });
    }).flatMap((tag) => loadBalancers.filter((loadBalancer) => tag.ResourceArn === loadBalancer.LoadBalancerArn));
  }
  /**
   * Returns tag descriptions associated with the resources. The API doesn't support
   * pagination, so this function breaks the resource list into chunks and issues
   * the appropriate requests.
   */
  async describeTags(resourceArns) {
    const chunkSize = 20;
    const tags = Array();
    for (let i = 0; i < resourceArns.length; i += chunkSize) {
      const chunk = resourceArns.slice(i, Math.min(i + chunkSize, resourceArns.length));
      const chunkTags = await this.client.describeTags({
        ResourceArns: chunk
      });
      tags.push(...chunkTags.TagDescriptions || []);
    }
    return tags;
  }
  async getListenersForLoadBalancers(loadBalancers) {
    const listeners = [];
    for (const loadBalancer of loadBalancers.map((lb) => lb.LoadBalancerArn)) {
      listeners.push(...await this.client.paginateDescribeListeners({ LoadBalancerArn: loadBalancer }));
    }
    return listeners;
  }
};

// ../tmp-toolkit-helpers/src/context-providers/security-groups.ts
var SecurityGroupContextProviderPlugin = class {
  constructor(aws) {
    this.aws = aws;
  }
  async getValue(args) {
    if (args.securityGroupId && args.securityGroupName) {
      throw new ContextProviderError(
        "'securityGroupId' and 'securityGroupName' can not be specified both when looking up a security group"
      );
    }
    if (!args.securityGroupId && !args.securityGroupName) {
      throw new ContextProviderError("'securityGroupId' or 'securityGroupName' must be specified to look up a security group");
    }
    const ec2 = (await initContextProviderSdk(this.aws, args)).ec2();
    const filters = [];
    if (args.vpcId) {
      filters.push({
        Name: "vpc-id",
        Values: [args.vpcId]
      });
    }
    if (args.securityGroupName) {
      filters.push({
        Name: "group-name",
        Values: [args.securityGroupName]
      });
    }
    const response = await ec2.describeSecurityGroups({
      GroupIds: args.securityGroupId ? [args.securityGroupId] : void 0,
      Filters: filters.length > 0 ? filters : void 0
    });
    const securityGroups = response.SecurityGroups ?? [];
    if (securityGroups.length === 0) {
      throw new ContextProviderError(`No security groups found matching ${JSON.stringify(args)}`);
    }
    if (securityGroups.length > 1) {
      throw new ContextProviderError(`More than one security groups found matching ${JSON.stringify(args)}`);
    }
    const [securityGroup] = securityGroups;
    return {
      securityGroupId: securityGroup.GroupId,
      allowAllOutbound: hasAllTrafficEgress(securityGroup)
    };
  }
};
function hasAllTrafficEgress(securityGroup) {
  let hasAllTrafficCidrV4 = false;
  let hasAllTrafficCidrV6 = false;
  for (const ipPermission of securityGroup.IpPermissionsEgress ?? []) {
    const isAllProtocols = ipPermission.IpProtocol === "-1";
    if (isAllProtocols && ipPermission.IpRanges?.some((m) => m.CidrIp === "0.0.0.0/0")) {
      hasAllTrafficCidrV4 = true;
    }
    if (isAllProtocols && ipPermission.Ipv6Ranges?.some((m) => m.CidrIpv6 === "::/0")) {
      hasAllTrafficCidrV6 = true;
    }
  }
  return hasAllTrafficCidrV4 && hasAllTrafficCidrV6;
}

// ../tmp-toolkit-helpers/src/context-providers/ssm-parameters.ts
var SSMContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const region = args.region;
    const account = args.account;
    if (!("parameterName" in args)) {
      throw new ContextProviderError("parameterName must be provided in props for SSMContextProviderPlugin");
    }
    const parameterName = args.parameterName;
    await this.io.debug(`Reading SSM parameter ${account}:${region}:${parameterName}`);
    const response = await this.getSsmParameterValue(args);
    const parameterNotFound = !response.Parameter || response.Parameter.Value === void 0;
    const suppressError = "ignoreErrorOnMissingContext" in args && args.ignoreErrorOnMissingContext;
    if (parameterNotFound && suppressError && "dummyValue" in args) {
      return args.dummyValue;
    }
    if (parameterNotFound) {
      throw new ContextProviderError(`SSM parameter not available in account ${account}, region ${region}: ${parameterName}`);
    }
    return response.Parameter.Value;
  }
  /**
   * Gets the value of an SSM Parameter, while not throwin if the parameter does not exist.
   * @param account       the account in which the SSM Parameter is expected to be.
   * @param region        the region in which the SSM Parameter is expected to be.
   * @param parameterName the name of the SSM Parameter
   * @param lookupRoleArn the ARN of the lookup role.
   *
   * @returns the result of the ``GetParameter`` operation.
   *
   * @throws Error if a service error (other than ``ParameterNotFound``) occurs.
   */
  async getSsmParameterValue(args) {
    const ssm = (await initContextProviderSdk(this.aws, args)).ssm();
    try {
      return await ssm.getParameter({ Name: args.parameterName });
    } catch (e) {
      if (e.name === "ParameterNotFound") {
        return { $metadata: {} };
      }
      throw e;
    }
  }
};

// ../tmp-toolkit-helpers/src/context-providers/vpcs.ts
var import_cx_api9 = require("@aws-cdk/cx-api");
var VpcNetworkContextProviderPlugin = class {
  constructor(aws, io) {
    this.aws = aws;
    this.io = io;
  }
  async getValue(args) {
    const ec2 = (await initContextProviderSdk(this.aws, args)).ec2();
    const vpcId = await this.findVpc(ec2, args);
    return this.readVpcProps(ec2, vpcId, args);
  }
  async findVpc(ec2, args) {
    const filters = Object.entries(args.filter).map(([tag, value]) => ({ Name: tag, Values: [value] }));
    await this.io.debug(`Listing VPCs in ${args.account}:${args.region}`);
    const response = await ec2.describeVpcs({ Filters: filters });
    const vpcs = response.Vpcs || [];
    if (vpcs.length === 0) {
      throw new ContextProviderError(`Could not find any VPCs matching ${JSON.stringify(args)}`);
    }
    if (vpcs.length > 1) {
      throw new ContextProviderError(`Found ${vpcs.length} VPCs matching ${JSON.stringify(args)}; please narrow the search criteria`);
    }
    return vpcs[0];
  }
  async readVpcProps(ec2, vpc, args) {
    const vpcId = vpc.VpcId;
    await this.io.debug(`Describing VPC ${vpcId}`);
    const filters = { Filters: [{ Name: "vpc-id", Values: [vpcId] }] };
    const subnetsResponse = await ec2.describeSubnets(filters);
    const listedSubnets = subnetsResponse.Subnets || [];
    const routeTablesResponse = await ec2.describeRouteTables(filters);
    const routeTables = new RouteTables(routeTablesResponse.RouteTables || []);
    const azs = Array.from(new Set(listedSubnets.map((s) => s.AvailabilityZone)));
    azs.sort();
    const subnets = listedSubnets.map((subnet) => {
      let type = getTag("aws-cdk:subnet-type", subnet.Tags);
      if (type === void 0 && subnet.MapPublicIpOnLaunch) {
        type = "Public" /* Public */;
      }
      if (type === void 0 && routeTables.hasRouteToIgw(subnet.SubnetId)) {
        type = "Public" /* Public */;
      }
      if (type === void 0 && routeTables.hasRouteToNatGateway(subnet.SubnetId)) {
        type = "Private" /* Private */;
      }
      if (type === void 0 && routeTables.hasRouteToTransitGateway(subnet.SubnetId)) {
        type = "Private" /* Private */;
      }
      if (type === void 0) {
        type = "Isolated" /* Isolated */;
      }
      if (!isValidSubnetType(type)) {
        throw new ContextProviderError(
          `Subnet ${subnet.SubnetArn} has invalid subnet type ${type} (must be ${"Public" /* Public */}, ${"Private" /* Private */} or ${"Isolated" /* Isolated */})`
        );
      }
      if (args.subnetGroupNameTag && !getTag(args.subnetGroupNameTag, subnet.Tags)) {
        throw new ContextProviderError(
          `Invalid subnetGroupNameTag: Subnet ${subnet.SubnetArn} does not have an associated tag with Key='${args.subnetGroupNameTag}'`
        );
      }
      const name = getTag(args.subnetGroupNameTag || "aws-cdk:subnet-name", subnet.Tags) || type;
      const routeTableId = routeTables.routeTableIdForSubnetId(subnet.SubnetId);
      if (!routeTableId) {
        throw new ContextProviderError(
          `Subnet ${subnet.SubnetArn} does not have an associated route table (and there is no "main" table)`
        );
      }
      return {
        az: subnet.AvailabilityZone,
        cidr: subnet.CidrBlock,
        type,
        name,
        subnetId: subnet.SubnetId,
        routeTableId
      };
    });
    let grouped;
    let assymetricSubnetGroups;
    if (args.returnAsymmetricSubnets) {
      grouped = { azs: [], groups: [] };
      assymetricSubnetGroups = groupAsymmetricSubnets(subnets);
    } else {
      grouped = groupSubnets(subnets);
      assymetricSubnetGroups = void 0;
    }
    const vpnGatewayResponse = args.returnVpnGateways ?? true ? await ec2.describeVpnGateways({
      Filters: [
        {
          Name: "attachment.vpc-id",
          Values: [vpcId]
        },
        {
          Name: "attachment.state",
          Values: ["attached"]
        },
        {
          Name: "state",
          Values: ["available"]
        }
      ]
    }) : void 0;
    const vpnGatewayId = vpnGatewayResponse?.VpnGateways?.length === 1 ? vpnGatewayResponse.VpnGateways[0].VpnGatewayId : void 0;
    return {
      vpcId,
      vpcCidrBlock: vpc.CidrBlock,
      ownerAccountId: vpc.OwnerId,
      availabilityZones: grouped.azs,
      isolatedSubnetIds: collapse(
        flatMap2(findGroups("Isolated" /* Isolated */, grouped), (group) => group.subnets.map((s) => s.subnetId))
      ),
      isolatedSubnetNames: collapse(
        flatMap2(findGroups("Isolated" /* Isolated */, grouped), (group) => group.name ? [group.name] : [])
      ),
      isolatedSubnetRouteTableIds: collapse(
        flatMap2(findGroups("Isolated" /* Isolated */, grouped), (group) => group.subnets.map((s) => s.routeTableId))
      ),
      privateSubnetIds: collapse(
        flatMap2(findGroups("Private" /* Private */, grouped), (group) => group.subnets.map((s) => s.subnetId))
      ),
      privateSubnetNames: collapse(
        flatMap2(findGroups("Private" /* Private */, grouped), (group) => group.name ? [group.name] : [])
      ),
      privateSubnetRouteTableIds: collapse(
        flatMap2(findGroups("Private" /* Private */, grouped), (group) => group.subnets.map((s) => s.routeTableId))
      ),
      publicSubnetIds: collapse(
        flatMap2(findGroups("Public" /* Public */, grouped), (group) => group.subnets.map((s) => s.subnetId))
      ),
      publicSubnetNames: collapse(
        flatMap2(findGroups("Public" /* Public */, grouped), (group) => group.name ? [group.name] : [])
      ),
      publicSubnetRouteTableIds: collapse(
        flatMap2(findGroups("Public" /* Public */, grouped), (group) => group.subnets.map((s) => s.routeTableId))
      ),
      vpnGatewayId,
      subnetGroups: assymetricSubnetGroups
    };
  }
};
var RouteTables = class {
  constructor(tables) {
    this.tables = tables;
    this.mainRouteTable = this.tables.find(
      (table) => !!table.Associations && table.Associations.some((assoc) => !!assoc.Main)
    );
  }
  mainRouteTable;
  routeTableIdForSubnetId(subnetId) {
    const table = this.tableForSubnet(subnetId);
    return table && table.RouteTableId || this.mainRouteTable && this.mainRouteTable.RouteTableId;
  }
  /**
   * Whether the given subnet has a route to a NAT Gateway
   */
  hasRouteToNatGateway(subnetId) {
    const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
    return !!table && !!table.Routes && table.Routes.some((route) => !!route.NatGatewayId && route.DestinationCidrBlock === "0.0.0.0/0");
  }
  /**
   * Whether the given subnet has a route to a Transit Gateway
   */
  hasRouteToTransitGateway(subnetId) {
    const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
    return !!table && !!table.Routes && table.Routes.some((route) => !!route.TransitGatewayId && route.DestinationCidrBlock === "0.0.0.0/0");
  }
  /**
   * Whether the given subnet has a route to an IGW
   */
  hasRouteToIgw(subnetId) {
    const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
    return !!table && !!table.Routes && table.Routes.some((route) => !!route.GatewayId && route.GatewayId.startsWith("igw-"));
  }
  tableForSubnet(subnetId) {
    return this.tables.find(
      (table) => !!table.Associations && table.Associations.some((assoc) => assoc.SubnetId === subnetId)
    );
  }
};
function getTag(name, tags) {
  for (const tag of tags || []) {
    if (tag.Key === name) {
      return tag.Value;
    }
  }
  return void 0;
}
function groupSubnets(subnets) {
  const grouping = {};
  for (const subnet of subnets) {
    const key = [subnet.type, subnet.name].toString();
    if (!(key in grouping)) {
      grouping[key] = [];
    }
    grouping[key].push(subnet);
  }
  const groups = Object.values(grouping).map((sns) => {
    sns.sort((a, b) => a.az.localeCompare(b.az));
    return {
      type: sns[0].type,
      name: sns[0].name,
      subnets: sns
    };
  });
  const azs = groups[0].subnets.map((s) => s.az);
  for (const group of groups) {
    const groupAZs = group.subnets.map((s) => s.az);
    if (!arraysEqual(groupAZs, azs)) {
      throw new ContextProviderError(`Not all subnets in VPC have the same AZs: ${groupAZs} vs ${azs}`);
    }
  }
  return { azs, groups };
}
function groupAsymmetricSubnets(subnets) {
  const grouping = {};
  for (const subnet of subnets) {
    const key = [subnet.type, subnet.name].toString();
    if (!(key in grouping)) {
      grouping[key] = [];
    }
    grouping[key].push(subnet);
  }
  return Object.values(grouping).map((subnetArray) => {
    subnetArray.sort((subnet1, subnet2) => subnet1.az.localeCompare(subnet2.az));
    return {
      name: subnetArray[0].name,
      type: subnetTypeToVpcSubnetType(subnetArray[0].type),
      subnets: subnetArray.map((subnet) => ({
        subnetId: subnet.subnetId,
        cidr: subnet.cidr,
        availabilityZone: subnet.az,
        routeTableId: subnet.routeTableId
      }))
    };
  });
}
function subnetTypeToVpcSubnetType(type) {
  switch (type) {
    case "Isolated" /* Isolated */:
      return import_cx_api9.VpcSubnetGroupType.ISOLATED;
    case "Private" /* Private */:
      return import_cx_api9.VpcSubnetGroupType.PRIVATE;
    case "Public" /* Public */:
      return import_cx_api9.VpcSubnetGroupType.PUBLIC;
  }
}
function isValidSubnetType(val) {
  return val === "Public" /* Public */ || val === "Private" /* Private */ || val === "Isolated" /* Isolated */;
}
function arraysEqual(as, bs) {
  if (as.length !== bs.length) {
    return false;
  }
  for (let i = 0; i < as.length; i++) {
    if (as[i] !== bs[i]) {
      return false;
    }
  }
  return true;
}
function findGroups(type, groups) {
  return groups.groups.filter((g) => g.type === type);
}
function flatMap2(xs, fn) {
  const ret = new Array();
  for (const x of xs) {
    ret.push(...fn(x));
  }
  return ret;
}
function collapse(xs) {
  if (xs.length > 0) {
    return xs;
  }
  return void 0;
}

// ../tmp-toolkit-helpers/src/context-providers/index.ts
var PLUGIN_PROVIDER_PREFIX = "plugin";
var ContextProviderMessages = class {
  ioHelper;
  providerName;
  constructor(ioHelper, providerName) {
    this.ioHelper = ioHelper;
    this.providerName = providerName;
  }
  async info(message2) {
    return this.ioHelper.notify(IO.CDK_ASSEMBLY_I0300.msg(message2, {
      provider: this.providerName
    }));
  }
  async debug(message2) {
    return this.ioHelper.notify(IO.CDK_ASSEMBLY_I0301.msg(message2, {
      provider: this.providerName
    }));
  }
};
async function provideContextValues(missingValues, context, sdk, pluginHost, ioHelper) {
  for (const missingContext of missingValues) {
    const key = missingContext.key;
    const providerName = missingContext.provider === cxschema4.ContextProvider.PLUGIN ? `${PLUGIN_PROVIDER_PREFIX}:${missingContext.props.pluginName}` : missingContext.provider;
    let factory;
    if (providerName.startsWith(`${PLUGIN_PROVIDER_PREFIX}:`)) {
      const plugin = pluginHost.contextProviderPlugins[providerName.substring(PLUGIN_PROVIDER_PREFIX.length + 1)];
      if (!plugin) {
        throw new ContextProviderError(`Unrecognized plugin context provider name: ${missingContext.provider}.`);
      }
      factory = () => plugin;
    } else {
      factory = availableContextProviders[providerName];
      if (!factory) {
        throw new ContextProviderError(`Unrecognized context provider name: ${missingContext.provider}. You might need to update the toolkit to match the version of the construct library.`);
      }
    }
    const provider = factory(sdk, new ContextProviderMessages(ioHelper, providerName));
    let value;
    try {
      const environment = missingContext.props.account && missingContext.props.region ? cxapi5.EnvironmentUtils.make(missingContext.props.account, missingContext.props.region) : void 0;
      const resolvedEnvironment = environment ? await sdk.resolveEnvironment(environment) : { account: "?", region: "?", name: "?" };
      const arns = await replaceEnvPlaceholders({
        lookupRoleArn: missingContext.props.lookupRoleArn
      }, resolvedEnvironment, sdk);
      value = await provider.getValue({ ...missingContext.props, lookupRoleArn: arns.lookupRoleArn });
    } catch (e) {
      value = { [cxapi5.PROVIDER_ERROR_KEY]: formatErrorMessage(e), [TRANSIENT_CONTEXT_KEY]: true };
    }
    context.set(key, value);
    await ioHelper.notify(IO.DEFAULT_ASSEMBLY_DEBUG.msg(`Setting "${key}" context to ${JSON.stringify(value)}`));
  }
}
function registerContextProvider(name, provider) {
  availableContextProviders[name] = () => provider;
}
function registerPluginContextProvider(name, provider) {
  registerContextProvider(`${PLUGIN_PROVIDER_PREFIX}:${name}`, provider);
}
function registerContextProviderFactory(name, provider) {
  availableContextProviders[name] = provider;
}
var availableContextProviders = {
  [cxschema4.ContextProvider.AVAILABILITY_ZONE_PROVIDER]: (s, io) => new AZContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.SSM_PARAMETER_PROVIDER]: (s, io) => new SSMContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.HOSTED_ZONE_PROVIDER]: (s, io) => new HostedZoneContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.VPC_PROVIDER]: (s, io) => new VpcNetworkContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.AMI_PROVIDER]: (s, io) => new AmiContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.ENDPOINT_SERVICE_AVAILABILITY_ZONE_PROVIDER]: (s, io) => new EndpointServiceAZContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.SECURITY_GROUP_PROVIDER]: (s) => new SecurityGroupContextProviderPlugin(s),
  [cxschema4.ContextProvider.LOAD_BALANCER_PROVIDER]: (s) => new LoadBalancerContextProviderPlugin(s),
  [cxschema4.ContextProvider.LOAD_BALANCER_LISTENER_PROVIDER]: (s) => new LoadBalancerListenerContextProviderPlugin(s),
  [cxschema4.ContextProvider.KEY_PROVIDER]: (s, io) => new KeyContextProviderPlugin(s, io),
  [cxschema4.ContextProvider.CC_API_PROVIDER]: (s) => new CcApiContextProviderPlugin(s)
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountAccessKeyCache,
  ActiveAssetCache,
  ActivityPrinterBase,
  AmbiguityError,
  AssemblyError,
  AssetManifestBuilder,
  AuthenticationError,
  AwsCliCompatible,
  BOOTSTRAP_VARIANT_PARAMETER,
  BOOTSTRAP_VERSION_OUTPUT,
  BOOTSTRAP_VERSION_RESOURCE,
  BUCKET_DOMAIN_NAME_OUTPUT,
  BUCKET_NAME_OUTPUT,
  BackgroundStackRefresh,
  BaseStackAssembly,
  Bootstrapper,
  CachedDataSource,
  CfnEvaluationException,
  CloudFormationStack,
  CloudWatchLogEventMonitor,
  Context,
  ContextProviderError,
  CredentialPlugins,
  CurrentActivityPrinter,
  DEFAULT_BOOTSTRAP_VARIANT,
  DEFAULT_TOOLKIT_STACK_NAME,
  DeploymentState,
  Deployments,
  DiffFormatter,
  ECR_ISOLATED_TAG,
  EcsHotswapProperties,
  EnvironmentAccess,
  EnvironmentResources,
  EnvironmentResourcesRegistry,
  EvaluateCloudFormationTemplate,
  ExpandStackSelection,
  ExtendedStackSelection,
  FilteredNotice,
  GarbageCollector,
  HistoryActivityPrinter,
  HotswapMode,
  HotswapPropertyOverrides,
  ICON,
  IO,
  ImageAsset,
  IoDefaultMessages,
  IoHelper,
  LazyListStackResources,
  LazyLookupExport,
  LookupExportError,
  Mode,
  NoBootstrapStackEnvironmentResources,
  Notices,
  NoticesFilter,
  ObjectAsset,
  PROJECT_CONTEXT,
  PluginHost,
  ProgressPrinter,
  ProxyAgentProvider,
  REPOSITORY_NAME_OUTPUT,
  RWLock,
  RequireApproval,
  ResourceImporter,
  ResourceLocation,
  ResourceMapping,
  ResourceMigrator,
  RollbackChoice,
  S3_ISOLATED_TAG,
  SDK,
  SPAN,
  SdkProvider,
  SdkToCliLogger,
  Settings,
  SpanMaker,
  StackActivityMonitor,
  StackCollection,
  StackEventPoller,
  StackProgressMonitor,
  StackSelectionStrategy,
  StackStatus,
  TESTING,
  TRANSIENT_CONTEXT_KEY,
  ToolkitError,
  ToolkitInfo,
  WebsiteNoticeDataSource,
  WorkGraph,
  WorkGraphBuilder,
  addMetadataAssetsToManifest,
  ambiguousMovements,
  asIoHelper,
  assertIsSuccessfulDeployStackResult,
  cached,
  cfnApi,
  classifyChanges,
  confirm,
  contextproviders,
  credentialsAboutToExpire,
  debug,
  defaultCliUserAgent,
  determineAllowCrossAccountAssetPublishing,
  error,
  findCloudWatchLogGroups,
  findResourceMovements,
  formatAmbiguousMappings,
  formatSdkLoggerContent,
  formatTypedMappings,
  getBootstrapStackInfo,
  guessExecutable,
  info,
  initContextProviderSdk,
  isContextProviderPlugin,
  isMessageRelevantForLevel,
  legacyBootstrapTemplate,
  loadCurrentTemplate,
  loadCurrentTemplateWithNestedStacks,
  loadTree,
  loadTreeFromDir,
  makeBodyParameter,
  makeRequestHandler,
  markTesting,
  nonHotswappableChange,
  nonHotswappableResource,
  prepareContext,
  prepareDefaultEnvironment,
  refreshStacks,
  removeNonImportResources,
  replaceEnvPlaceholders,
  resourceMappings,
  resourceMovements,
  result,
  setSdkTracing,
  some,
  spaceAvailableForContext,
  tagsForStack,
  trace,
  tryHotswapDeployment,
  warn
});
//# sourceMappingURL=shared-private.js.map
