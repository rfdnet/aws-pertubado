"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/api/shared-public.ts
var shared_public_exports = {};
__export(shared_public_exports, {
  AssemblyError: () => AssemblyError,
  AuthenticationError: () => AuthenticationError,
  ExpandStackSelection: () => ExpandStackSelection,
  NonHotswappableReason: () => NonHotswappableReason,
  PermissionChangeType: () => PermissionChangeType,
  PluginHost: () => PluginHost,
  StackSelectionStrategy: () => StackSelectionStrategy,
  ToolkitError: () => ToolkitError
});
module.exports = __toCommonJS(shared_public_exports);

// ../tmp-toolkit-helpers/src/api/toolkit-error.ts
var TOOLKIT_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ToolkitError");
var AUTHENTICATION_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AuthenticationError");
var ASSEMBLY_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.AssemblyError");
var CONTEXT_PROVIDER_ERROR_SYMBOL = Symbol.for("@aws-cdk/toolkit-lib.ContextProviderError");
var ToolkitError = class _ToolkitError extends Error {
  /**
   * Determines if a given error is an instance of ToolkitError.
   */
  static isToolkitError(x) {
    return x !== null && typeof x === "object" && TOOLKIT_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AuthenticationError.
   */
  static isAuthenticationError(x) {
    return this.isToolkitError(x) && AUTHENTICATION_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isAssemblyError(x) {
    return this.isToolkitError(x) && ASSEMBLY_ERROR_SYMBOL in x;
  }
  /**
   * Determines if a given error is an instance of AssemblyError.
   */
  static isContextProviderError(x) {
    return this.isToolkitError(x) && CONTEXT_PROVIDER_ERROR_SYMBOL in x;
  }
  /**
   * An AssemblyError with an original error as cause
   */
  static withCause(message2, error2) {
    return new _ToolkitError(message2, "toolkit", error2);
  }
  /**
   * The type of the error, defaults to "toolkit".
   */
  type;
  /**
   * Denotes the source of the error as the toolkit.
   */
  source;
  /**
   * The specific original cause of the error, if available
   */
  cause;
  constructor(message2, type = "toolkit", cause) {
    super(message2);
    Object.setPrototypeOf(this, _ToolkitError.prototype);
    Object.defineProperty(this, TOOLKIT_ERROR_SYMBOL, { value: true });
    this.name = new.target.name;
    this.type = type;
    this.source = "toolkit";
    this.cause = cause;
  }
};
var AuthenticationError = class _AuthenticationError extends ToolkitError {
  /**
   * Denotes the source of the error as user.
   */
  source = "user";
  constructor(message2) {
    super(message2, "authentication");
    Object.setPrototypeOf(this, _AuthenticationError.prototype);
    Object.defineProperty(this, AUTHENTICATION_ERROR_SYMBOL, { value: true });
  }
};
var AssemblyError = class _AssemblyError extends ToolkitError {
  /**
   * An AssemblyError with an original error as cause
   */
  static withCause(message2, error2) {
    return new _AssemblyError(message2, void 0, error2);
  }
  /**
   * An AssemblyError with a list of stacks as cause
   */
  static withStacks(message2, stacks) {
    return new _AssemblyError(message2, stacks);
  }
  /**
   * Denotes the source of the error as user.
   */
  source = "user";
  /**
   * The stacks that caused the error, if available
   *
   * The `messages` property of each `cxapi.CloudFormationStackArtifact` will contain the respective errors.
   * Absence indicates synthesis didn't fully complete.
   */
  stacks;
  constructor(message2, stacks, cause) {
    super(message2, "assembly", cause);
    Object.setPrototypeOf(this, _AssemblyError.prototype);
    Object.defineProperty(this, ASSEMBLY_ERROR_SYMBOL, { value: true });
    this.stacks = stacks;
  }
};

// ../tmp-toolkit-helpers/src/api/cloud-assembly/stack-selector.ts
var StackSelectionStrategy = /* @__PURE__ */ ((StackSelectionStrategy2) => {
  StackSelectionStrategy2["ALL_STACKS"] = "all-stacks";
  StackSelectionStrategy2["MAIN_ASSEMBLY"] = "main-assembly";
  StackSelectionStrategy2["ONLY_SINGLE"] = "only-single";
  StackSelectionStrategy2["PATTERN_MATCH"] = "pattern-match";
  StackSelectionStrategy2["PATTERN_MUST_MATCH"] = "pattern-must-match";
  StackSelectionStrategy2["PATTERN_MUST_MATCH_SINGLE"] = "pattern-must-match-single";
  return StackSelectionStrategy2;
})(StackSelectionStrategy || {});
var ExpandStackSelection = /* @__PURE__ */ ((ExpandStackSelection2) => {
  ExpandStackSelection2["NONE"] = "none";
  ExpandStackSelection2["UPSTREAM"] = "upstream";
  ExpandStackSelection2["DOWNSTREAM"] = "downstream";
  return ExpandStackSelection2;
})(ExpandStackSelection || {});

// ../tmp-toolkit-helpers/src/api/plugin/plugin.ts
var import_util2 = require("util");

// ../tmp-toolkit-helpers/src/api/plugin/context-provider-plugin.ts
function isContextProviderPlugin(x) {
  return typeof x === "object" && !!x && !!x.getValue;
}

// ../tmp-toolkit-helpers/src/api/io/private/span.ts
var util = __toESM(require("node:util"));
var uuid = __toESM(require("uuid"));

// ../tmp-toolkit-helpers/src/util/archive.ts
var glob = __toESM(require("glob"));
var archiver = require("archiver");

// ../tmp-toolkit-helpers/src/util/types.ts
var isArray = Array.isArray;

// ../tmp-toolkit-helpers/src/util/yaml-cfn.ts
var yaml = __toESM(require("yaml"));
var yaml_types = __toESM(require("yaml/types"));
function makeTagForCfnIntrinsic(intrinsicName, addFnPrefix) {
  return {
    identify(value) {
      return typeof value === "string";
    },
    tag: `!${intrinsicName}`,
    resolve: (_doc, cstNode) => {
      const ret = {};
      ret[addFnPrefix ? `Fn::${intrinsicName}` : intrinsicName] = // the +1 is to account for the ! the short form begins with
      parseYamlStrWithCfnTags(cstNode.toString().substring(intrinsicName.length + 1));
      return ret;
    }
  };
}
var shortForms = [
  "Base64",
  "Cidr",
  "FindInMap",
  "GetAZs",
  "ImportValue",
  "Join",
  "Sub",
  "Select",
  "Split",
  "Transform",
  "And",
  "Equals",
  "If",
  "Not",
  "Or",
  "GetAtt"
].map((name) => makeTagForCfnIntrinsic(name, true)).concat(
  makeTagForCfnIntrinsic("Ref", false),
  makeTagForCfnIntrinsic("Condition", false)
);
function parseYamlStrWithCfnTags(text) {
  return yaml.parse(text, {
    customTags: shortForms,
    schema: "core"
  });
}

// ../tmp-toolkit-helpers/src/util/string-manipulation.ts
function formatTime(num) {
  return roundPercentage(millisecondsToSeconds(num));
}
function roundPercentage(num) {
  return Math.round(100 * num) / 100;
}
function millisecondsToSeconds(num) {
  return num / 1e3;
}

// ../tmp-toolkit-helpers/src/util/version-range.ts
var semver = __toESM(require("semver"));

// ../tmp-toolkit-helpers/src/api/io/private/span.ts
var SpanMaker = class {
  definition;
  ioHelper;
  constructor(ioHelper, definition) {
    this.definition = definition;
    this.ioHelper = ioHelper;
  }
  async begin(a, b) {
    const spanId = uuid.v4();
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const notify = (msg) => {
      return this.ioHelper.notify(withSpanId(spanId, msg));
    };
    const startInput = parseArgs(a, b);
    const startMsg = startInput.message ?? `Starting ${this.definition.name} ...`;
    const startPayload = startInput.payload;
    await notify(this.definition.start.msg(
      startMsg,
      startPayload
    ));
    const timingMsgTemplate = "\n\u2728  %s time: %ds\n";
    const time = () => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - startTime;
      return {
        asMs: elapsedTime,
        asSec: formatTime(elapsedTime)
      };
    };
    return {
      elapsedTime: async () => {
        return time();
      },
      notify: async (msg) => {
        await notify(msg);
      },
      timing: async (maker, message2) => {
        const duration = time();
        const timingMsg = message2 ? message2 : util.format(timingMsgTemplate, this.definition.name, duration.asSec);
        await notify(maker.msg(timingMsg, {
          duration: duration.asMs
        }));
        return duration;
      },
      end: async (x, y) => {
        const duration = time();
        const endInput = parseArgs(x, y);
        const endMsg = endInput.message ?? util.format(timingMsgTemplate, this.definition.name, duration.asSec);
        const endPayload = endInput.payload;
        await notify(this.definition.end.msg(
          endMsg,
          {
            duration: duration.asMs,
            ...endPayload
          }
        ));
        return duration;
      }
    };
  }
};
function parseArgs(first, second) {
  const firstIsMessage = typeof first === "string";
  const message2 = firstIsMessage || second ? first : void 0;
  const payload = firstIsMessage || second ? second : first;
  return {
    message: message2,
    payload
  };
}
function withSpanId(span, message2) {
  return {
    ...message2,
    span
  };
}

// ../tmp-toolkit-helpers/src/api/io/private/io-helper.ts
var IoHelper = class _IoHelper {
  static fromIoHost(ioHost, action) {
    return new _IoHelper(ioHost, action);
  }
  ioHost;
  action;
  constructor(ioHost, action) {
    this.ioHost = ioHost;
    this.action = action;
  }
  /**
   * Forward a message to the IoHost, while injection the current action
   */
  notify(msg) {
    return this.ioHost.notify({
      ...msg,
      action: this.action
    });
  }
  /**
   * Forward a request to the IoHost, while injection the current action
   */
  requestResponse(msg) {
    return this.ioHost.requestResponse({
      ...msg,
      action: this.action
    });
  }
  /**
   * Create a new marker from a given registry entry
   */
  span(definition) {
    return new SpanMaker(this, definition);
  }
};

// ../tmp-toolkit-helpers/src/api/io/private/level-priority.ts
var levels = [
  "trace",
  "debug",
  "info",
  "warn",
  "result",
  "error"
];
var orderedLevels = Object.fromEntries(Object.entries(levels).map((a) => a.reverse()));

// ../tmp-toolkit-helpers/src/api/io/private/message-maker.ts
function message(level, details) {
  const maker = (text, data) => ({
    time: /* @__PURE__ */ new Date(),
    level,
    code: details.code,
    message: text,
    data
  });
  return {
    ...details,
    level,
    msg: maker,
    is: (m) => m.code === details.code
  };
}
var trace = (details) => message("trace", details);
var debug = (details) => message("debug", details);
var info = (details) => message("info", details);
var warn = (details) => message("warn", details);
var error = (details) => message("error", details);
var result = (details) => message("result", details);
function request(level, details) {
  const maker = (text, data) => ({
    time: /* @__PURE__ */ new Date(),
    level,
    code: details.code,
    message: text,
    data,
    defaultResponse: details.defaultResponse
  });
  return {
    ...details,
    level,
    req: maker
  };
}
var confirm = (details) => request("info", {
  ...details,
  defaultResponse: true
});

// ../tmp-toolkit-helpers/src/api/io/private/messages.ts
var IO = {
  // Defaults (0000)
  DEFAULT_TOOLKIT_INFO: info({
    code: "CDK_TOOLKIT_I0000",
    description: "Default info messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_DEBUG: debug({
    code: "CDK_TOOLKIT_I0000",
    description: "Default debug messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_WARN: warn({
    code: "CDK_TOOLKIT_W0000",
    description: "Default warning messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_ERROR: error({
    code: "CDK_TOOLKIT_E0000",
    description: "Default error messages emitted from the Toolkit"
  }),
  DEFAULT_TOOLKIT_TRACE: trace({
    code: "CDK_TOOLKIT_I0000",
    description: "Default trace messages emitted from the Toolkit"
  }),
  // warnings & errors
  CDK_TOOLKIT_W0100: warn({
    code: "CDK_TOOLKIT_W0100",
    description: "Credential plugin warnings"
  }),
  // 1: Synth (1xxx)
  CDK_TOOLKIT_I1000: info({
    code: "CDK_TOOLKIT_I1000",
    description: "Provides synthesis times.",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I1001: trace({
    code: "CDK_TOOLKIT_I1001",
    description: "Cloud Assembly synthesis is starting",
    interface: "StackSelectionDetails"
  }),
  CDK_TOOLKIT_I1901: result({
    code: "CDK_TOOLKIT_I1901",
    description: "Provides stack data",
    interface: "StackAndAssemblyData"
  }),
  CDK_TOOLKIT_I1902: result({
    code: "CDK_TOOLKIT_I1902",
    description: "Successfully deployed stacks",
    interface: "AssemblyData"
  }),
  // 2: List (2xxx)
  CDK_TOOLKIT_I2901: result({
    code: "CDK_TOOLKIT_I2901",
    description: "Provides details on the selected stacks and their dependencies",
    interface: "StackDetailsPayload"
  }),
  // 3: Import & Migrate
  CDK_TOOLKIT_E3900: error({
    code: "CDK_TOOLKIT_E3900",
    description: "Resource import failed",
    interface: "ErrorPayload"
  }),
  // 4: Diff (4xxx)
  CDK_TOOLKIT_I4000: trace({
    code: "CDK_TOOLKIT_I4000",
    description: "Diff stacks is starting",
    interface: "StackSelectionDetails"
  }),
  CDK_TOOLKIT_I4001: info({
    code: "CDK_TOOLKIT_I4001",
    description: "Output of the diff command",
    interface: "DiffResult"
  }),
  // 5: Deploy & Watch (5xxx)
  CDK_TOOLKIT_I5000: info({
    code: "CDK_TOOLKIT_I5000",
    description: "Provides deployment times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5001: info({
    code: "CDK_TOOLKIT_I5001",
    description: "Provides total time in deploy action, including synth and rollback",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5002: info({
    code: "CDK_TOOLKIT_I5002",
    description: "Provides time for resource migration",
    interface: "Duration"
  }),
  CDK_TOOLKIT_W5021: warn({
    code: "CDK_TOOLKIT_W5021",
    description: "Empty non-existent stack, deployment is skipped"
  }),
  CDK_TOOLKIT_W5022: warn({
    code: "CDK_TOOLKIT_W5022",
    description: "Empty existing stack, stack will be destroyed"
  }),
  CDK_TOOLKIT_I5031: info({
    code: "CDK_TOOLKIT_I5031",
    description: "Informs about any log groups that are traced as part of the deployment"
  }),
  CDK_TOOLKIT_I5032: debug({
    code: "CDK_TOOLKIT_I5032",
    description: "Start monitoring log groups",
    interface: "CloudWatchLogMonitorControlEvent"
  }),
  CDK_TOOLKIT_I5033: info({
    code: "CDK_TOOLKIT_I5033",
    description: "A log event received from Cloud Watch",
    interface: "CloudWatchLogEvent"
  }),
  CDK_TOOLKIT_I5034: debug({
    code: "CDK_TOOLKIT_I5034",
    description: "Stop monitoring log groups",
    interface: "CloudWatchLogMonitorControlEvent"
  }),
  CDK_TOOLKIT_E5035: error({
    code: "CDK_TOOLKIT_E5035",
    description: "A log monitoring error",
    interface: "ErrorPayload"
  }),
  CDK_TOOLKIT_I5050: confirm({
    code: "CDK_TOOLKIT_I5050",
    description: "Confirm rollback during deployment",
    interface: "ConfirmationRequest"
  }),
  CDK_TOOLKIT_I5060: confirm({
    code: "CDK_TOOLKIT_I5060",
    description: "Confirm deploy security sensitive changes",
    interface: "DeployConfirmationRequest"
  }),
  CDK_TOOLKIT_I5100: info({
    code: "CDK_TOOLKIT_I5100",
    description: "Stack deploy progress",
    interface: "StackDeployProgress"
  }),
  // Assets (52xx)
  CDK_TOOLKIT_I5210: trace({
    code: "CDK_TOOLKIT_I5210",
    description: "Started building a specific asset",
    interface: "BuildAsset"
  }),
  CDK_TOOLKIT_I5211: trace({
    code: "CDK_TOOLKIT_I5211",
    description: "Building the asset has completed",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I5220: trace({
    code: "CDK_TOOLKIT_I5220",
    description: "Started publishing a specific asset",
    interface: "PublishAsset"
  }),
  CDK_TOOLKIT_I5221: trace({
    code: "CDK_TOOLKIT_I5221",
    description: "Publishing the asset has completed",
    interface: "Duration"
  }),
  // Watch (53xx)
  CDK_TOOLKIT_I5310: debug({
    code: "CDK_TOOLKIT_I5310",
    description: "The computed settings used for file watching",
    interface: "WatchSettings"
  }),
  CDK_TOOLKIT_I5311: info({
    code: "CDK_TOOLKIT_I5311",
    description: "File watching started",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5312: info({
    code: "CDK_TOOLKIT_I5312",
    description: "File event detected, starting deployment",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5313: info({
    code: "CDK_TOOLKIT_I5313",
    description: "File event detected during active deployment, changes are queued",
    interface: "FileWatchEvent"
  }),
  CDK_TOOLKIT_I5314: info({
    code: "CDK_TOOLKIT_I5314",
    description: "Initial watch deployment started"
  }),
  CDK_TOOLKIT_I5315: info({
    code: "CDK_TOOLKIT_I5315",
    description: "Queued watch deployment started"
  }),
  // Hotswap (54xx)
  CDK_TOOLKIT_I5400: trace({
    code: "CDK_TOOLKIT_I5400",
    description: "Attempting a hotswap deployment",
    interface: "HotswapDeploymentAttempt"
  }),
  CDK_TOOLKIT_I5401: trace({
    code: "CDK_TOOLKIT_I5401",
    description: "Computed details for the hotswap deployment",
    interface: "HotswapDeploymentDetails"
  }),
  CDK_TOOLKIT_I5402: info({
    code: "CDK_TOOLKIT_I5402",
    description: "A hotswappable change is processed as part of a hotswap deployment",
    interface: "HotswappableChange"
  }),
  CDK_TOOLKIT_I5403: info({
    code: "CDK_TOOLKIT_I5403",
    description: "The hotswappable change has completed processing",
    interface: "HotswappableChange"
  }),
  CDK_TOOLKIT_I5410: info({
    code: "CDK_TOOLKIT_I5410",
    description: "Hotswap deployment has ended, a full deployment might still follow if needed",
    interface: "HotswapResult"
  }),
  // Stack Monitor (55xx)
  CDK_TOOLKIT_I5501: info({
    code: "CDK_TOOLKIT_I5501",
    description: "Stack Monitoring: Start monitoring of a single stack",
    interface: "StackMonitoringControlEvent"
  }),
  CDK_TOOLKIT_I5502: info({
    code: "CDK_TOOLKIT_I5502",
    description: "Stack Monitoring: Activity event for a single stack",
    interface: "StackActivity"
  }),
  CDK_TOOLKIT_I5503: info({
    code: "CDK_TOOLKIT_I5503",
    description: "Stack Monitoring: Finished monitoring of a single stack",
    interface: "StackMonitoringControlEvent"
  }),
  // Success (59xx)
  CDK_TOOLKIT_I5900: result({
    code: "CDK_TOOLKIT_I5900",
    description: "Deployment results on success",
    interface: "SuccessfulDeployStackResult"
  }),
  CDK_TOOLKIT_I5901: info({
    code: "CDK_TOOLKIT_I5901",
    description: "Generic deployment success messages"
  }),
  CDK_TOOLKIT_W5400: warn({
    code: "CDK_TOOLKIT_W5400",
    description: "Hotswap disclosure message"
  }),
  CDK_TOOLKIT_E5001: error({
    code: "CDK_TOOLKIT_E5001",
    description: "No stacks found"
  }),
  CDK_TOOLKIT_E5500: error({
    code: "CDK_TOOLKIT_E5500",
    description: "Stack Monitoring error",
    interface: "ErrorPayload"
  }),
  // 6: Rollback (6xxx)
  CDK_TOOLKIT_I6000: info({
    code: "CDK_TOOLKIT_I6000",
    description: "Provides rollback times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I6100: info({
    code: "CDK_TOOLKIT_I6100",
    description: "Stack rollback progress",
    interface: "StackRollbackProgress"
  }),
  CDK_TOOLKIT_E6001: error({
    code: "CDK_TOOLKIT_E6001",
    description: "No stacks found"
  }),
  CDK_TOOLKIT_E6900: error({
    code: "CDK_TOOLKIT_E6900",
    description: "Rollback failed",
    interface: "ErrorPayload"
  }),
  // 7: Destroy (7xxx)
  CDK_TOOLKIT_I7000: info({
    code: "CDK_TOOLKIT_I7000",
    description: "Provides destroy times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I7001: trace({
    code: "CDK_TOOLKIT_I7001",
    description: "Provides destroy time for a single stack",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I7010: confirm({
    code: "CDK_TOOLKIT_I7010",
    description: "Confirm destroy stacks",
    interface: "ConfirmationRequest"
  }),
  CDK_TOOLKIT_I7100: info({
    code: "CDK_TOOLKIT_I7100",
    description: "Stack destroy progress",
    interface: "StackDestroyProgress"
  }),
  CDK_TOOLKIT_I7101: trace({
    code: "CDK_TOOLKIT_I7101",
    description: "Start stack destroying",
    interface: "StackDestroy"
  }),
  CDK_TOOLKIT_I7900: result({
    code: "CDK_TOOLKIT_I7900",
    description: "Stack deletion succeeded",
    interface: "cxapi.CloudFormationStackArtifact"
  }),
  CDK_TOOLKIT_E7010: error({
    code: "CDK_TOOLKIT_E7010",
    description: "Action was aborted due to negative confirmation of request"
  }),
  CDK_TOOLKIT_E7900: error({
    code: "CDK_TOOLKIT_E7900",
    description: "Stack deletion failed",
    interface: "ErrorPayload"
  }),
  // 8. Refactor (8xxx)
  CDK_TOOLKIT_I8900: result({
    code: "CDK_TOOLKIT_I8900",
    description: "Refactor result",
    interface: "RefactorResult"
  }),
  CDK_TOOLKIT_W8010: warn({
    code: "CDK_TOOLKIT_W8010",
    description: "Refactor execution not yet supported"
  }),
  // 9: Bootstrap (9xxx)
  CDK_TOOLKIT_I9000: info({
    code: "CDK_TOOLKIT_I9000",
    description: "Provides bootstrap times",
    interface: "Duration"
  }),
  CDK_TOOLKIT_I9100: info({
    code: "CDK_TOOLKIT_I9100",
    description: "Bootstrap progress",
    interface: "BootstrapEnvironmentProgress"
  }),
  CDK_TOOLKIT_I9900: result({
    code: "CDK_TOOLKIT_I9900",
    description: "Bootstrap results on success",
    interface: "cxapi.Environment"
  }),
  CDK_TOOLKIT_E9900: error({
    code: "CDK_TOOLKIT_E9900",
    description: "Bootstrap failed",
    interface: "ErrorPayload"
  }),
  // Notices
  CDK_TOOLKIT_I0100: info({
    code: "CDK_TOOLKIT_I0100",
    description: "Notices decoration (the header or footer of a list of notices)"
  }),
  CDK_TOOLKIT_W0101: warn({
    code: "CDK_TOOLKIT_W0101",
    description: "A notice that is marked as a warning"
  }),
  CDK_TOOLKIT_E0101: error({
    code: "CDK_TOOLKIT_E0101",
    description: "A notice that is marked as an error"
  }),
  CDK_TOOLKIT_I0101: info({
    code: "CDK_TOOLKIT_I0101",
    description: "A notice that is marked as informational"
  }),
  // Assembly codes
  DEFAULT_ASSEMBLY_TRACE: trace({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default trace messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_DEBUG: debug({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default debug messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_INFO: info({
    code: "CDK_ASSEMBLY_I0000",
    description: "Default info messages emitted from Cloud Assembly operations"
  }),
  DEFAULT_ASSEMBLY_WARN: warn({
    code: "CDK_ASSEMBLY_W0000",
    description: "Default warning messages emitted from Cloud Assembly operations"
  }),
  CDK_ASSEMBLY_I0010: debug({
    code: "CDK_ASSEMBLY_I0010",
    description: "Generic environment preparation debug messages"
  }),
  CDK_ASSEMBLY_W0010: warn({
    code: "CDK_ASSEMBLY_W0010",
    description: "Emitted if the found framework version does not support context overflow"
  }),
  CDK_ASSEMBLY_I0042: debug({
    code: "CDK_ASSEMBLY_I0042",
    description: "Writing updated context",
    interface: "UpdatedContext"
  }),
  CDK_ASSEMBLY_I0240: debug({
    code: "CDK_ASSEMBLY_I0240",
    description: "Context lookup was stopped as no further progress was made. ",
    interface: "MissingContext"
  }),
  CDK_ASSEMBLY_I0241: debug({
    code: "CDK_ASSEMBLY_I0241",
    description: "Fetching missing context. This is an iterative message that may appear multiple times with different missing keys.",
    interface: "MissingContext"
  }),
  CDK_ASSEMBLY_I1000: debug({
    code: "CDK_ASSEMBLY_I1000",
    description: "Cloud assembly output starts"
  }),
  CDK_ASSEMBLY_I1001: info({
    code: "CDK_ASSEMBLY_I1001",
    description: "Output lines emitted by the cloud assembly to stdout"
  }),
  CDK_ASSEMBLY_E1002: error({
    code: "CDK_ASSEMBLY_E1002",
    description: "Output lines emitted by the cloud assembly to stderr"
  }),
  CDK_ASSEMBLY_I1003: info({
    code: "CDK_ASSEMBLY_I1003",
    description: "Cloud assembly output finished"
  }),
  CDK_ASSEMBLY_E1111: error({
    code: "CDK_ASSEMBLY_E1111",
    description: "Incompatible CDK CLI version. Upgrade needed.",
    interface: "ErrorPayload"
  }),
  CDK_ASSEMBLY_I0150: debug({
    code: "CDK_ASSEMBLY_I0150",
    description: "Indicates the use of a pre-synthesized cloud assembly directory"
  }),
  CDK_ASSEMBLY_I0300: info({
    code: "CDK_ASSEMBLY_I0300",
    description: "An info message emitted by a Context Provider",
    interface: "ContextProviderMessageSource"
  }),
  CDK_ASSEMBLY_I0301: debug({
    code: "CDK_ASSEMBLY_I0301",
    description: "A debug message emitted by a Context Provider",
    interface: "ContextProviderMessageSource"
  }),
  // Assembly Annotations
  CDK_ASSEMBLY_I9999: info({
    code: "CDK_ASSEMBLY_I9999",
    description: "Annotations emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  CDK_ASSEMBLY_W9999: warn({
    code: "CDK_ASSEMBLY_W9999",
    description: "Warnings emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  CDK_ASSEMBLY_E9999: error({
    code: "CDK_ASSEMBLY_E9999",
    description: "Errors emitted by the cloud assembly",
    interface: "cxapi.SynthesisMessage"
  }),
  // SDK codes
  DEFAULT_SDK_TRACE: trace({
    code: "CDK_SDK_I0000",
    description: "An SDK trace message."
  }),
  DEFAULT_SDK_DEBUG: debug({
    code: "CDK_SDK_I0000",
    description: "An SDK debug message."
  }),
  DEFAULT_SDK_WARN: warn({
    code: "CDK_SDK_W0000",
    description: "An SDK warning message."
  }),
  CDK_SDK_I0100: trace({
    code: "CDK_SDK_I0100",
    description: "An SDK trace. SDK traces are emitted as traces to the IoHost, but contain the original SDK logging level.",
    interface: "SdkTrace"
  })
};
var SPAN = {
  SYNTH_ASSEMBLY: {
    name: "Synthesis",
    start: IO.CDK_TOOLKIT_I1001,
    end: IO.CDK_TOOLKIT_I1000
  },
  DEPLOY_STACK: {
    name: "Deployment",
    start: IO.CDK_TOOLKIT_I5100,
    end: IO.CDK_TOOLKIT_I5001
  },
  ROLLBACK_STACK: {
    name: "Rollback",
    start: IO.CDK_TOOLKIT_I6100,
    end: IO.CDK_TOOLKIT_I6000
  },
  DIFF_STACK: {
    name: "Diff",
    start: IO.CDK_TOOLKIT_I4000,
    end: IO.CDK_TOOLKIT_I4001
  },
  DESTROY_STACK: {
    name: "Destroy",
    start: IO.CDK_TOOLKIT_I7100,
    end: IO.CDK_TOOLKIT_I7001
  },
  DESTROY_ACTION: {
    name: "Destroy",
    start: IO.CDK_TOOLKIT_I7101,
    end: IO.CDK_TOOLKIT_I7000
  },
  BOOTSTRAP_SINGLE: {
    name: "Bootstrap",
    start: IO.CDK_TOOLKIT_I9100,
    end: IO.CDK_TOOLKIT_I9000
  },
  BUILD_ASSET: {
    name: "Build Asset",
    start: IO.CDK_TOOLKIT_I5210,
    end: IO.CDK_TOOLKIT_I5211
  },
  PUBLISH_ASSET: {
    name: "Publish Asset",
    start: IO.CDK_TOOLKIT_I5220,
    end: IO.CDK_TOOLKIT_I5221
  },
  HOTSWAP: {
    name: "hotswap-deployment",
    start: IO.CDK_TOOLKIT_I5400,
    end: IO.CDK_TOOLKIT_I5410
  }
};

// ../tmp-toolkit-helpers/src/api/io/private/io-default-messages.ts
var util2 = __toESM(require("util"));
var IoDefaultMessages = class {
  constructor(ioHelper) {
    this.ioHelper = ioHelper;
  }
  notify(msg) {
    return this.ioHelper.notify(msg);
  }
  requestResponse(msg) {
    return this.ioHelper.requestResponse(msg);
  }
  error(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_ERROR, input, ...args);
  }
  warn(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_WARN, input, ...args);
  }
  warning(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_WARN, input, ...args);
  }
  info(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_INFO, input, ...args);
  }
  debug(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_DEBUG, input, ...args);
  }
  trace(input, ...args) {
    this.emitMessage(IO.DEFAULT_TOOLKIT_TRACE, input, ...args);
  }
  result(input, ...args) {
    const message2 = args.length > 0 ? util2.format(input, ...args) : input;
    void this.ioHelper.notify({
      time: /* @__PURE__ */ new Date(),
      code: IO.DEFAULT_TOOLKIT_INFO.code,
      level: "result",
      message: message2,
      data: void 0
    });
  }
  emitMessage(maker, input, ...args) {
    const message2 = args.length > 0 ? util2.format(input, ...args) : input;
    void this.ioHelper.notify(maker.msg(message2));
  }
};

// ../tmp-toolkit-helpers/src/api/plugin/plugin.ts
var PluginHost = class {
  /**
   * Access the currently registered CredentialProviderSources. New sources can
   * be registered using the +registerCredentialProviderSource+ method.
   */
  credentialProviderSources = new Array();
  contextProviderPlugins = {};
  ioHost;
  alreadyLoaded = /* @__PURE__ */ new Set();
  /**
   * Loads a plug-in into this PluginHost.
   *
   * Will use `require.resolve()` to get the most accurate representation of what
   * code will get loaded in error messages. As such, it will not work in
   * unit tests with Jest virtual modules becauase of <https://github.com/jestjs/jest/issues/9543>.
   *
   * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
   * @param ioHost the I/O host to use for printing progress information
   */
  load(moduleSpec, ioHost) {
    try {
      const resolved = require.resolve(moduleSpec);
      if (ioHost) {
        new IoDefaultMessages(IoHelper.fromIoHost(ioHost, "init")).debug(`Loading plug-in: ${resolved} from ${moduleSpec}`);
      }
      return this._doLoad(resolved);
    } catch (e) {
      throw new ToolkitError(`Unable to resolve plug-in: Cannot find module '${moduleSpec}': ${e}`);
    }
  }
  /**
   * Do the loading given an already-resolved module name
   *
   * @internal
   */
  _doLoad(resolved) {
    try {
      if (this.alreadyLoaded.has(resolved)) {
        return;
      }
      const plugin = require(resolved);
      if (!isPlugin(plugin)) {
        throw new ToolkitError(`Module ${resolved} is not a valid plug-in, or has an unsupported version.`);
      }
      if (plugin.init) {
        plugin.init(this);
      }
      this.alreadyLoaded.add(resolved);
    } catch (e) {
      throw ToolkitError.withCause(`Unable to load plug-in '${resolved}'`, e);
    }
    function isPlugin(x) {
      return x != null && x.version === "1";
    }
  }
  /**
   * Allows plug-ins to register new CredentialProviderSources.
   *
   * @param source a new CredentialProviderSource to register.
   */
  registerCredentialProviderSource(source) {
    this.credentialProviderSources.push(source);
  }
  /**
   * (EXPERIMENTAL) Allow plugins to register context providers
   *
   * Context providers are objects with the following method:
   *
   * ```ts
   *   getValue(args: {[key: string]: any}): Promise<any>;
   * ```
   *
   * Currently, they cannot reuse the CDK's authentication mechanisms, so they
   * must be prepared to either not make AWS calls or use their own source of
   * AWS credentials.
   *
   * This feature is experimental, and only intended to be used internally at Amazon
   * as a trial.
   *
   * After registering with 'my-plugin-name', the provider must be addressed as follows:
   *
   * ```ts
   * const value = ContextProvider.getValue(this, {
   *   providerName: 'plugin',
   *   props: {
   *     pluginName: 'my-plugin-name',
   *     myParameter1: 'xyz',
   *   },
   *   includeEnvironment: true | false,
   *   dummyValue: 'what-to-return-on-the-first-pass',
   * })
   * ```
   *
   * @experimental
   */
  registerContextProviderAlpha(pluginProviderName, provider) {
    if (!isContextProviderPlugin(provider)) {
      throw new ToolkitError(`Object you gave me does not look like a ContextProviderPlugin: ${(0, import_util2.inspect)(provider)}`);
    }
    this.contextProviderPlugins[pluginProviderName] = provider;
  }
};

// ../tmp-toolkit-helpers/src/payloads/diff.ts
var PermissionChangeType = /* @__PURE__ */ ((PermissionChangeType2) => {
  PermissionChangeType2["NONE"] = "none";
  PermissionChangeType2["BROADENING"] = "broadening";
  PermissionChangeType2["NON_BROADENING"] = "non-broadening";
  return PermissionChangeType2;
})(PermissionChangeType || {});

// ../tmp-toolkit-helpers/src/payloads/hotswap.ts
var NonHotswappableReason = /* @__PURE__ */ ((NonHotswappableReason2) => {
  NonHotswappableReason2["TAGS"] = "tags";
  NonHotswappableReason2["PROPERTIES"] = "properties";
  NonHotswappableReason2["OUTPUT"] = "output";
  NonHotswappableReason2["DEPENDENCY_UNSUPPORTED"] = "dependency-unsupported";
  NonHotswappableReason2["RESOURCE_UNSUPPORTED"] = "resource-unsupported";
  NonHotswappableReason2["RESOURCE_CREATION"] = "resource-creation";
  NonHotswappableReason2["RESOURCE_DELETION"] = "resource-deletion";
  NonHotswappableReason2["RESOURCE_TYPE_CHANGED"] = "resource-type-changed";
  NonHotswappableReason2["NESTED_STACK_CREATION"] = "nested-stack-creation";
  return NonHotswappableReason2;
})(NonHotswappableReason || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AssemblyError,
  AuthenticationError,
  ExpandStackSelection,
  NonHotswappableReason,
  PermissionChangeType,
  PluginHost,
  StackSelectionStrategy,
  ToolkitError
});
//# sourceMappingURL=shared-public.js.map
