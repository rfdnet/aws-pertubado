"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionEnvironment = void 0;
exports.assemblyFromDirectory = assemblyFromDirectory;
require("../../../private/dispose-polyfill");
const os = require("node:os");
const path = require("node:path");
const node_util_1 = require("node:util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const semver_1 = require("semver");
const shared_private_1 = require("../../../api/shared-private");
const shared_private_2 = require("../../../api/shared-private");
const util_1 = require("../../../private/util");
const private_1 = require("../../io/private");
const shared_public_1 = require("../../shared-public");
class ExecutionEnvironment {
    outdir;
    outDirIsTemporary;
    /**
     * Create an ExecutionEnvironment
     *
     * An ExecutionEnvironment holds a writer lock on the given directory which will
     * be cleaned up when the object is disposed.
     *
     * A temporary directory will be created if none is supplied, which will be cleaned
     * up when this object is disposed.
     *
     * If `markSuccessful()` is called, the writer lock is converted to a reader lock
     * and temporary directories will not be cleaned up anymore.
     */
    static async create(services, props = {}) {
        let tempDir = false;
        let dir = props.outdir;
        if (!dir) {
            tempDir = true;
            dir = fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));
        }
        const lock = await new shared_private_1.RWLock(dir).acquireWrite();
        return new ExecutionEnvironment(services, dir, tempDir, lock);
    }
    ioHelper;
    sdkProvider;
    debugFn;
    lock;
    shouldClean;
    constructor(services, outdir, outDirIsTemporary, lock) {
        this.outdir = outdir;
        this.outDirIsTemporary = outDirIsTemporary;
        this.ioHelper = services.ioHelper;
        this.sdkProvider = services.sdkProvider;
        this.debugFn = (msg) => this.ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg(msg));
        this.lock = lock;
        this.shouldClean = outDirIsTemporary;
    }
    async [Symbol.asyncDispose]() {
        await this.lock?.release();
        if (this.shouldClean) {
            await fs.rm(this.outdir, { recursive: true, force: true });
        }
    }
    /**
     * Mark the execution as successful, which stops the writer lock from being released upon disposal
     */
    async markSuccessful() {
        if (!this.lock) {
            throw new TypeError('Cannot mark successful more than once');
        }
        const readLock = await this.lock.convertToReaderLock();
        this.lock = undefined;
        this.shouldClean = false;
        return { readLock };
    }
    /**
     * Begin an execution in this environment
     *
     * This will acquire a write lock on the given environment. The write lock
     * will be released automatically when the return object is disposed, unless it
     * is converted to a reader lock.
     */
    async beginExecution() {
        const lock = await new shared_private_1.RWLock(this.outdir).acquireWrite();
        let converted = false;
        return {
            async writeToReadLock() {
                converted = true;
                return lock.convertToReaderLock();
            },
            [Symbol.asyncDispose]: async () => {
                // Release if not converted
                if (!converted) {
                    await lock.release();
                }
            },
        };
    }
    /**
     * Guess the executable from the command-line argument
     *
     * Only do this if the file is NOT marked as executable. If it is,
     * we'll defer to the shebang inside the file itself.
     *
     * If we're on Windows, we ALWAYS take the handler, since it's hard to
     * verify if registry associations have or have not been set up for this
     * file type, so we'll assume the worst and take control.
     */
    guessExecutable(app) {
        return (0, shared_private_2.guessExecutable)(app, this.debugFn);
    }
    /**
     * If we don't have region/account defined in context, we fall back to the default SDK behavior
     * where region is retrieved from ~/.aws/config and account is based on default credentials provider
     * chain and then STS is queried.
     *
     * This is done opportunistically: for example, if we can't access STS for some reason or the region
     * is not configured, the context value will be 'null' and there could failures down the line. In
     * some cases, synthesis does not require region/account information at all, so that might be perfectly
     * fine in certain scenarios.
     */
    async defaultEnvVars() {
        const debugFn = (msg) => this.ioHelper.notify(private_1.IO.CDK_ASSEMBLY_I0010.msg(msg));
        const env = await (0, shared_private_2.prepareDefaultEnvironment)(this.sdkProvider, debugFn);
        env[cxapi.OUTDIR_ENV] = this.outdir;
        await debugFn((0, node_util_1.format)('outdir:', this.outdir));
        // CLI version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, util_1.versionNumber)();
        await debugFn((0, node_util_1.format)('env:', env));
        return env;
    }
    /**
     * Run code from a different working directory
     */
    async changeDir(block, workingDir) {
        const originalWorkingDir = process.cwd();
        try {
            if (workingDir) {
                process.chdir(workingDir);
            }
            return await block();
        }
        finally {
            if (workingDir) {
                process.chdir(originalWorkingDir);
            }
        }
    }
    /**
     * Run code with additional environment variables
     */
    async withEnv(env = {}, block) {
        const originalEnv = process.env;
        try {
            process.env = {
                ...originalEnv,
                ...env,
            };
            return await block();
        }
        finally {
            process.env = originalEnv;
        }
    }
    /**
     * Run code with context setup inside the environment
     */
    async withContext(inputContext, env, synthOpts = {}, block) {
        const context = await (0, shared_private_2.prepareContext)(synthOptsDefaults(synthOpts), inputContext, env, this.debugFn);
        let contextOverflowLocation = null;
        try {
            const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
            const [smallContext, overflow] = (0, util_1.splitBySize)(context, (0, shared_private_2.spaceAvailableForContext)(env, envVariableSizeLimit));
            // Store the safe part in the environment variable
            env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
            // If there was any overflow, write it to a temporary file
            if (Object.keys(overflow ?? {}).length > 0) {
                const contextDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cdk-context'));
                contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
                fs.writeJSONSync(contextOverflowLocation, overflow);
                env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
            }
            // call the block code with new environment
            return await block(env, context);
        }
        finally {
            if (contextOverflowLocation) {
                fs.removeSync(path.dirname(contextOverflowLocation));
            }
        }
    }
}
exports.ExecutionEnvironment = ExecutionEnvironment;
/**
 * Checks if a given assembly supports context overflow, warn otherwise.
 *
 * @param assembly the assembly to check
 */
async function checkContextOverflowSupport(assembly, ioHelper) {
    const traceFn = (msg) => ioHelper.notify(private_1.IO.DEFAULT_ASSEMBLY_TRACE.msg(msg));
    const tree = await (0, shared_private_1.loadTree)(assembly, traceFn);
    const frameworkDoesNotSupportContextOverflow = (0, shared_private_1.some)(tree, node => {
        const fqn = node.constructInfo?.fqn;
        const version = node.constructInfo?.version;
        return (fqn === 'aws-cdk-lib.App' && version != null && (0, semver_1.lte)(version, '2.38.0')) // v2
            || fqn === '@aws-cdk/core.App'; // v1
    });
    // We're dealing with an old version of the framework here. It is unaware of the temporary
    // file, which means that it will ignore the context overflow.
    if (frameworkDoesNotSupportContextOverflow) {
        await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_W0010.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
    }
}
/**
 * Safely create an assembly from a cloud assembly directory
 */
async function assemblyFromDirectory(assemblyDir, ioHelper, loadOptions = {}) {
    try {
        const assembly = new cxapi.CloudAssembly(assemblyDir, {
            skipVersionCheck: !(loadOptions.checkVersion ?? true),
            skipEnumCheck: !(loadOptions.checkEnums ?? true),
            // We sort as we deploy
            topoSort: false,
        });
        await checkContextOverflowSupport(assembly, ioHelper);
        return assembly;
    }
    catch (err) {
        if (err.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            const message = 'This AWS CDK Toolkit is not compatible with the AWS CDK library used by your application. Please upgrade to the latest version.';
            await ioHelper.notify(private_1.IO.CDK_ASSEMBLY_E1111.msg(message, { error: err }));
            throw new shared_public_1.ToolkitError(`${message}\n(${err.message}`);
        }
        throw err;
    }
}
function synthOptsDefaults(synthOpts = {}) {
    return new shared_private_1.Settings({
        debug: false,
        pathMetadata: true,
        versionReporting: true,
        assetMetadata: true,
        assetStaging: true,
        ...synthOpts,
    }, true);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcGFyZS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcmVwYXJlLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFxUEEsc0RBb0JDO0FBelFELDZDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLHlDQUFtQztBQUNuQywyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQixtQ0FBNkI7QUFDN0IsZ0VBQWlKO0FBQ2pKLGdFQUFpSjtBQUNqSixnREFBbUU7QUFFbkUsOENBQXNDO0FBQ3RDLHVEQUFtRDtBQU1uRCxNQUFhLG9CQUFvQjtJQWlDYjtJQUNBO0lBakNsQjs7Ozs7Ozs7Ozs7T0FXRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQXlCLEVBQUUsUUFBNkIsRUFBRTtRQUNuRixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUN2QixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDVCxPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ2YsR0FBRyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDM0UsQ0FBQztRQUVELE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSx1QkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2xELE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRWdCLFFBQVEsQ0FBVztJQUNuQixXQUFXLENBQWM7SUFDekIsT0FBTyxDQUFpQztJQUNqRCxJQUFJLENBQXlCO0lBQzdCLFdBQVcs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QUFDO1FBQ3hELENBQUM7UUFDRCxNQUFNLEdBQUcsQ0FBQztJQUNaLENBQUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxZQUE2QixFQUFFO0lBQ3hELE9BQU8sSUFBSSx5QkFBUSxDQUFDO1FBQ2xCLEtBQUssRUFBRSxLQUFLO1FBQ1osWUFBWSxFQUFFLElBQUk7UUFDbEIsZ0JBQWdCLEVBQUUsSUFBSTtRQUN0QixhQUFhLEVBQUUsSUFBSTtRQUNuQixZQUFZLEVBQUUsSUFBSTtRQUNsQixHQUFHLFNBQVM7S0FDYixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ1gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vLi4vLi4vcHJpdmF0ZS9kaXNwb3NlLXBvbHlmaWxsJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ25vZGU6b3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgbHRlIH0gZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IHR5cGUgSVJlYWRMb2NrLCB0eXBlIElXcml0ZUxvY2ssIHR5cGUgU2RrUHJvdmlkZXIsIHR5cGUgSW9IZWxwZXIsIGxvYWRUcmVlLCBzb21lLCBTZXR0aW5ncywgUldMb2NrIH0gZnJvbSAnLi4vLi4vLi4vYXBpL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7IHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQgYXMgb2xkUHJlcGFyZSwgcHJlcGFyZUNvbnRleHQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dCwgZ3Vlc3NFeGVjdXRhYmxlIH0gZnJvbSAnLi4vLi4vLi4vYXBpL3NoYXJlZC1wcml2YXRlJztcbmltcG9ydCB7IHNwbGl0QnlTaXplLCB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vcHJpdmF0ZS91dGlsJztcbmltcG9ydCB0eXBlIHsgVG9vbGtpdFNlcnZpY2VzIH0gZnJvbSAnLi4vLi4vLi4vdG9vbGtpdC9wcml2YXRlJztcbmltcG9ydCB7IElPIH0gZnJvbSAnLi4vLi4vaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQtcHVibGljJztcbmltcG9ydCB0eXBlIHsgQXBwU3ludGhPcHRpb25zLCBMb2FkQXNzZW1ibHlPcHRpb25zIH0gZnJvbSAnLi4vc291cmNlLWJ1aWxkZXInO1xuXG50eXBlIEVudiA9IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG50eXBlIENvbnRleHQgPSB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uRW52aXJvbm1lbnQgaW1wbGVtZW50cyBBc3luY0Rpc3Bvc2FibGUge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIEV4ZWN1dGlvbkVudmlyb25tZW50XG4gICAqXG4gICAqIEFuIEV4ZWN1dGlvbkVudmlyb25tZW50IGhvbGRzIGEgd3JpdGVyIGxvY2sgb24gdGhlIGdpdmVuIGRpcmVjdG9yeSB3aGljaCB3aWxsXG4gICAqIGJlIGNsZWFuZWQgdXAgd2hlbiB0aGUgb2JqZWN0IGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBBIHRlbXBvcmFyeSBkaXJlY3Rvcnkgd2lsbCBiZSBjcmVhdGVkIGlmIG5vbmUgaXMgc3VwcGxpZWQsIHdoaWNoIHdpbGwgYmUgY2xlYW5lZFxuICAgKiB1cCB3aGVuIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBJZiBgbWFya1N1Y2Nlc3NmdWwoKWAgaXMgY2FsbGVkLCB0aGUgd3JpdGVyIGxvY2sgaXMgY29udmVydGVkIHRvIGEgcmVhZGVyIGxvY2tcbiAgICogYW5kIHRlbXBvcmFyeSBkaXJlY3RvcmllcyB3aWxsIG5vdCBiZSBjbGVhbmVkIHVwIGFueW1vcmUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWF0ZShzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzLCBwcm9wczogeyBvdXRkaXI/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgbGV0IHRlbXBEaXIgPSBmYWxzZTtcbiAgICBsZXQgZGlyID0gcHJvcHMub3V0ZGlyO1xuICAgIGlmICghZGlyKSB7XG4gICAgICB0ZW1wRGlyID0gdHJ1ZTtcbiAgICAgIGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihmcy5yZWFscGF0aFN5bmMob3MudG1wZGlyKCkpLCAnY2RrLm91dCcpKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NrID0gYXdhaXQgbmV3IFJXTG9jayhkaXIpLmFjcXVpcmVXcml0ZSgpO1xuICAgIHJldHVybiBuZXcgRXhlY3V0aW9uRW52aXJvbm1lbnQoc2VydmljZXMsIGRpciwgdGVtcERpciwgbG9jayk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGlvSGVscGVyOiBJb0hlbHBlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVidWdGbjogKG1zZzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIGxvY2s6IElXcml0ZUxvY2sgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgc2hvdWxkQ2xlYW46IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBzZXJ2aWNlczogVG9vbGtpdFNlcnZpY2VzLFxuICAgIHB1YmxpYyByZWFkb25seSBvdXRkaXI6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgb3V0RGlySXNUZW1wb3Jhcnk6IGJvb2xlYW4sXG4gICAgbG9jazogSVdyaXRlTG9jayxcbiAgKSB7XG4gICAgdGhpcy5pb0hlbHBlciA9IHNlcnZpY2VzLmlvSGVscGVyO1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBzZXJ2aWNlcy5zZGtQcm92aWRlcjtcbiAgICB0aGlzLmRlYnVnRm4gPSAobXNnOiBzdHJpbmcpID0+IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfQVNTRU1CTFlfREVCVUcubXNnKG1zZykpO1xuICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgdGhpcy5zaG91bGRDbGVhbiA9IG91dERpcklzVGVtcG9yYXJ5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICBhd2FpdCB0aGlzLmxvY2s/LnJlbGVhc2UoKTtcblxuICAgIGlmICh0aGlzLnNob3VsZENsZWFuKSB7XG4gICAgICBhd2FpdCBmcy5ybSh0aGlzLm91dGRpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBleGVjdXRpb24gYXMgc3VjY2Vzc2Z1bCwgd2hpY2ggc3RvcHMgdGhlIHdyaXRlciBsb2NrIGZyb20gYmVpbmcgcmVsZWFzZWQgdXBvbiBkaXNwb3NhbFxuICAgKi9cbiAgcHVibGljIGFzeW5jIG1hcmtTdWNjZXNzZnVsKCkge1xuICAgIGlmICghdGhpcy5sb2NrKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgbWFyayBzdWNjZXNzZnVsIG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRMb2NrID0gYXdhaXQgdGhpcy5sb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKTtcbiAgICB0aGlzLmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaG91bGRDbGVhbiA9IGZhbHNlO1xuICAgIHJldHVybiB7IHJlYWRMb2NrIH07XG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gYW4gZXhlY3V0aW9uIGluIHRoaXMgZW52aXJvbm1lbnRcbiAgICpcbiAgICogVGhpcyB3aWxsIGFjcXVpcmUgYSB3cml0ZSBsb2NrIG9uIHRoZSBnaXZlbiBlbnZpcm9ubWVudC4gVGhlIHdyaXRlIGxvY2tcbiAgICogd2lsbCBiZSByZWxlYXNlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJldHVybiBvYmplY3QgaXMgZGlzcG9zZWQsIHVubGVzcyBpdFxuICAgKiBpcyBjb252ZXJ0ZWQgdG8gYSByZWFkZXIgbG9jay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBiZWdpbkV4ZWN1dGlvbigpOiBQcm9taXNlPHsgd3JpdGVUb1JlYWRMb2NrKCk6IFByb21pc2U8SVJlYWRMb2NrPiB9ICYgQXN5bmNEaXNwb3NhYmxlPiB7XG4gICAgY29uc3QgbG9jayA9IGF3YWl0IG5ldyBSV0xvY2sodGhpcy5vdXRkaXIpLmFjcXVpcmVXcml0ZSgpO1xuXG4gICAgbGV0IGNvbnZlcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyB3cml0ZVRvUmVhZExvY2soKSB7XG4gICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsb2NrLmNvbnZlcnRUb1JlYWRlckxvY2soKTtcbiAgICAgIH0sXG4gICAgICBbU3ltYm9sLmFzeW5jRGlzcG9zZV06IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gUmVsZWFzZSBpZiBub3QgY29udmVydGVkXG4gICAgICAgIGlmICghY29udmVydGVkKSB7XG4gICAgICAgICAgYXdhaXQgbG9jay5yZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHdWVzcyB0aGUgZXhlY3V0YWJsZSBmcm9tIHRoZSBjb21tYW5kLWxpbmUgYXJndW1lbnRcbiAgICpcbiAgICogT25seSBkbyB0aGlzIGlmIHRoZSBmaWxlIGlzIE5PVCBtYXJrZWQgYXMgZXhlY3V0YWJsZS4gSWYgaXQgaXMsXG4gICAqIHdlJ2xsIGRlZmVyIHRvIHRoZSBzaGViYW5nIGluc2lkZSB0aGUgZmlsZSBpdHNlbGYuXG4gICAqXG4gICAqIElmIHdlJ3JlIG9uIFdpbmRvd3MsIHdlIEFMV0FZUyB0YWtlIHRoZSBoYW5kbGVyLCBzaW5jZSBpdCdzIGhhcmQgdG9cbiAgICogdmVyaWZ5IGlmIHJlZ2lzdHJ5IGFzc29jaWF0aW9ucyBoYXZlIG9yIGhhdmUgbm90IGJlZW4gc2V0IHVwIGZvciB0aGlzXG4gICAqIGZpbGUgdHlwZSwgc28gd2UnbGwgYXNzdW1lIHRoZSB3b3JzdCBhbmQgdGFrZSBjb250cm9sLlxuICAgKi9cbiAgcHVibGljIGd1ZXNzRXhlY3V0YWJsZShhcHA6IHN0cmluZykge1xuICAgIHJldHVybiBndWVzc0V4ZWN1dGFibGUoYXBwLCB0aGlzLmRlYnVnRm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGRvbid0IGhhdmUgcmVnaW9uL2FjY291bnQgZGVmaW5lZCBpbiBjb250ZXh0LCB3ZSBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgU0RLIGJlaGF2aW9yXG4gICAqIHdoZXJlIHJlZ2lvbiBpcyByZXRyaWV2ZWQgZnJvbSB+Ly5hd3MvY29uZmlnIGFuZCBhY2NvdW50IGlzIGJhc2VkIG9uIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXJcbiAgICogY2hhaW4gYW5kIHRoZW4gU1RTIGlzIHF1ZXJpZWQuXG4gICAqXG4gICAqIFRoaXMgaXMgZG9uZSBvcHBvcnR1bmlzdGljYWxseTogZm9yIGV4YW1wbGUsIGlmIHdlIGNhbid0IGFjY2VzcyBTVFMgZm9yIHNvbWUgcmVhc29uIG9yIHRoZSByZWdpb25cbiAgICogaXMgbm90IGNvbmZpZ3VyZWQsIHRoZSBjb250ZXh0IHZhbHVlIHdpbGwgYmUgJ251bGwnIGFuZCB0aGVyZSBjb3VsZCBmYWlsdXJlcyBkb3duIHRoZSBsaW5lLiBJblxuICAgKiBzb21lIGNhc2VzLCBzeW50aGVzaXMgZG9lcyBub3QgcmVxdWlyZSByZWdpb24vYWNjb3VudCBpbmZvcm1hdGlvbiBhdCBhbGwsIHNvIHRoYXQgbWlnaHQgYmUgcGVyZmVjdGx5XG4gICAqIGZpbmUgaW4gY2VydGFpbiBzY2VuYXJpb3MuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVmYXVsdEVudlZhcnMoKTogUHJvbWlzZTxFbnY+IHtcbiAgICBjb25zdCBkZWJ1Z0ZuID0gKG1zZzogc3RyaW5nKSA9PiB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfSTAwMTAubXNnKG1zZykpO1xuICAgIGNvbnN0IGVudiA9IGF3YWl0IG9sZFByZXBhcmUodGhpcy5zZGtQcm92aWRlciwgZGVidWdGbik7XG5cbiAgICBlbnZbY3hhcGkuT1VURElSX0VOVl0gPSB0aGlzLm91dGRpcjtcbiAgICBhd2FpdCBkZWJ1Z0ZuKGZvcm1hdCgnb3V0ZGlyOicsIHRoaXMub3V0ZGlyKSk7XG5cbiAgICAvLyBDTEkgdmVyc2lvbiBpbmZvcm1hdGlvblxuICAgIGVudltjeGFwaS5DTElfQVNNX1ZFUlNJT05fRU5WXSA9IGN4c2NoZW1hLk1hbmlmZXN0LnZlcnNpb24oKTtcbiAgICBlbnZbY3hhcGkuQ0xJX1ZFUlNJT05fRU5WXSA9IHZlcnNpb25OdW1iZXIoKTtcblxuICAgIGF3YWl0IGRlYnVnRm4oZm9ybWF0KCdlbnY6JywgZW52KSk7XG4gICAgcmV0dXJuIGVudjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gY29kZSBmcm9tIGEgZGlmZmVyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY2hhbmdlRGlyPFQ+KGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+LCB3b3JraW5nRGlyPzogc3RyaW5nKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxXb3JraW5nRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHdvcmtpbmdEaXIpIHtcbiAgICAgICAgcHJvY2Vzcy5jaGRpcih3b3JraW5nRGlyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IGJsb2NrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh3b3JraW5nRGlyKSB7XG4gICAgICAgIHByb2Nlc3MuY2hkaXIob3JpZ2luYWxXb3JraW5nRGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVuIGNvZGUgd2l0aCBhZGRpdGlvbmFsIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHdpdGhFbnY8VD4oZW52OiBFbnYgPSB7fSwgYmxvY2s6ICgpID0+IFByb21pc2U8VD4pIHtcbiAgICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuICAgIHRyeSB7XG4gICAgICBwcm9jZXNzLmVudiA9IHtcbiAgICAgICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgICAgIC4uLmVudixcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhd2FpdCBibG9jaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gY29kZSB3aXRoIGNvbnRleHQgc2V0dXAgaW5zaWRlIHRoZSBlbnZpcm9ubWVudFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHdpdGhDb250ZXh0PFQ+KFxuICAgIGlucHV0Q29udGV4dDogQ29udGV4dCxcbiAgICBlbnY6IEVudixcbiAgICBzeW50aE9wdHM6IEFwcFN5bnRoT3B0aW9ucyA9IHt9LFxuICAgIGJsb2NrOiAoZW52OiBFbnYsIGNvbnRleHQ6IENvbnRleHQpID0+IFByb21pc2U8VD4sXG4gICkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBwcmVwYXJlQ29udGV4dChzeW50aE9wdHNEZWZhdWx0cyhzeW50aE9wdHMpLCBpbnB1dENvbnRleHQsIGVudiwgdGhpcy5kZWJ1Z0ZuKTtcbiAgICBsZXQgY29udGV4dE92ZXJmbG93TG9jYXRpb24gPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVudlZhcmlhYmxlU2l6ZUxpbWl0ID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyA/IDMyNzYwIDogMTMxMDcyO1xuICAgICAgY29uc3QgW3NtYWxsQ29udGV4dCwgb3ZlcmZsb3ddID0gc3BsaXRCeVNpemUoY29udGV4dCwgc3BhY2VBdmFpbGFibGVGb3JDb250ZXh0KGVudiwgZW52VmFyaWFibGVTaXplTGltaXQpKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIHNhZmUgcGFydCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgIGVudltjeGFwaS5DT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShzbWFsbENvbnRleHQpO1xuXG4gICAgICAvLyBJZiB0aGVyZSB3YXMgYW55IG92ZXJmbG93LCB3cml0ZSBpdCB0byBhIHRlbXBvcmFyeSBmaWxlXG4gICAgICBpZiAoT2JqZWN0LmtleXMob3ZlcmZsb3cgPz8ge30pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgY29udGV4dERpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgICAgICBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiA9IHBhdGguam9pbihjb250ZXh0RGlyLCAnY29udGV4dC1vdmVyZmxvdy5qc29uJyk7XG4gICAgICAgIGZzLndyaXRlSlNPTlN5bmMoY29udGV4dE92ZXJmbG93TG9jYXRpb24sIG92ZXJmbG93KTtcbiAgICAgICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIHRoZSBibG9jayBjb2RlIHdpdGggbmV3IGVudmlyb25tZW50XG4gICAgICByZXR1cm4gYXdhaXQgYmxvY2soZW52LCBjb250ZXh0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uKSB7XG4gICAgICAgIGZzLnJlbW92ZVN5bmMocGF0aC5kaXJuYW1lKGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYXNzZW1ibHkgc3VwcG9ydHMgY29udGV4dCBvdmVyZmxvdywgd2FybiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGFzc2VtYmx5IHRoZSBhc3NlbWJseSB0byBjaGVja1xuICovXG5hc3luYyBmdW5jdGlvbiBjaGVja0NvbnRleHRPdmVyZmxvd1N1cHBvcnQoYXNzZW1ibHk6IGN4YXBpLkNsb3VkQXNzZW1ibHksIGlvSGVscGVyOiBJb0hlbHBlcik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB0cmFjZUZuID0gKG1zZzogc3RyaW5nKSA9PiBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9BU1NFTUJMWV9UUkFDRS5tc2cobXNnKSk7XG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBsb2FkVHJlZShhc3NlbWJseSwgdHJhY2VGbik7XG4gIGNvbnN0IGZyYW1ld29ya0RvZXNOb3RTdXBwb3J0Q29udGV4dE92ZXJmbG93ID0gc29tZSh0cmVlLCBub2RlID0+IHtcbiAgICBjb25zdCBmcW4gPSBub2RlLmNvbnN0cnVjdEluZm8/LmZxbjtcbiAgICBjb25zdCB2ZXJzaW9uID0gbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uO1xuICAgIHJldHVybiAoZnFuID09PSAnYXdzLWNkay1saWIuQXBwJyAmJiB2ZXJzaW9uICE9IG51bGwgJiYgbHRlKHZlcnNpb24sICcyLjM4LjAnKSkgLy8gdjJcbiAgICB8fCBmcW4gPT09ICdAYXdzLWNkay9jb3JlLkFwcCc7IC8vIHYxXG4gIH0pO1xuXG4gIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZnJhbWV3b3JrIGhlcmUuIEl0IGlzIHVuYXdhcmUgb2YgdGhlIHRlbXBvcmFyeVxuICAvLyBmaWxlLCB3aGljaCBtZWFucyB0aGF0IGl0IHdpbGwgaWdub3JlIHRoZSBjb250ZXh0IG92ZXJmbG93LlxuICBpZiAoZnJhbWV3b3JrRG9lc05vdFN1cHBvcnRDb250ZXh0T3ZlcmZsb3cpIHtcbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uQ0RLX0FTU0VNQkxZX1cwMDEwLm1zZygnUGFydCBvZiB0aGUgY29udGV4dCBjb3VsZCBub3QgYmUgc2VudCB0byB0aGUgYXBwbGljYXRpb24uIFBsZWFzZSB1cGRhdGUgdGhlIEFXUyBDREsgbGlicmFyeSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJykpO1xuICB9XG59XG5cbi8qKlxuICogU2FmZWx5IGNyZWF0ZSBhbiBhc3NlbWJseSBmcm9tIGEgY2xvdWQgYXNzZW1ibHkgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NlbWJseUZyb21EaXJlY3RvcnkoYXNzZW1ibHlEaXI6IHN0cmluZywgaW9IZWxwZXI6IElvSGVscGVyLCBsb2FkT3B0aW9uczogTG9hZEFzc2VtYmx5T3B0aW9ucyA9IHt9KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseShhc3NlbWJseURpciwge1xuICAgICAgc2tpcFZlcnNpb25DaGVjazogIShsb2FkT3B0aW9ucy5jaGVja1ZlcnNpb24gPz8gdHJ1ZSksXG4gICAgICBza2lwRW51bUNoZWNrOiAhKGxvYWRPcHRpb25zLmNoZWNrRW51bXMgPz8gdHJ1ZSksXG4gICAgICAvLyBXZSBzb3J0IGFzIHdlIGRlcGxveVxuICAgICAgdG9wb1NvcnQ6IGZhbHNlLFxuICAgIH0pO1xuICAgIGF3YWl0IGNoZWNrQ29udGV4dE92ZXJmbG93U3VwcG9ydChhc3NlbWJseSwgaW9IZWxwZXIpO1xuICAgIHJldHVybiBhc3NlbWJseTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoY3hzY2hlbWEuVkVSU0lPTl9NSVNNQVRDSCkpIHtcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIENMSSB2ZXJzaW9uIGlzIHRvbyBvbGQuXG4gICAgICAvLyB3ZSBpbnN0cnVjdCB0aGUgdXNlciB0byB1cGdyYWRlLlxuICAgICAgY29uc3QgbWVzc2FnZSA9ICdUaGlzIEFXUyBDREsgVG9vbGtpdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBBV1MgQ0RLIGxpYnJhcnkgdXNlZCBieSB5b3VyIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBncmFkZSB0byB0aGUgbGF0ZXN0IHZlcnNpb24uJztcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5DREtfQVNTRU1CTFlfRTExMTEubXNnKG1lc3NhZ2UsIHsgZXJyb3I6IGVyciB9KSk7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21lc3NhZ2V9XFxuKCR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW50aE9wdHNEZWZhdWx0cyhzeW50aE9wdHM6IEFwcFN5bnRoT3B0aW9ucyA9IHt9KTogU2V0dGluZ3Mge1xuICByZXR1cm4gbmV3IFNldHRpbmdzKHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgcGF0aE1ldGFkYXRhOiB0cnVlLFxuICAgIHZlcnNpb25SZXBvcnRpbmc6IHRydWUsXG4gICAgYXNzZXRNZXRhZGF0YTogdHJ1ZSxcbiAgICBhc3NldFN0YWdpbmc6IHRydWUsXG4gICAgLi4uc3ludGhPcHRzLFxuICB9LCB0cnVlKTtcbn1cbiJdfQ==