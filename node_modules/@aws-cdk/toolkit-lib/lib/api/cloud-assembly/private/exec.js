"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execInChildProcess = execInChildProcess;
const child_process = require("node:child_process");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const split = require("split2");
const shared_public_1 = require("../../shared-public");
/**
 * Execute a command and args in a child process
 */
async function execInChildProcess(commandAndArgs, options = {}) {
    return new Promise((ok, fail) => {
        // We use a slightly lower-level interface to:
        //
        // - Pass arguments in an array instead of a string, to get around a
        //   number of quoting issues introduced by the intermediate shell layer
        //   (which would be different between Linux and Windows).
        //
        // - We have to capture any output to stdout and stderr sp we can pass it on to the IoHost
        //   To ensure messages get to the user fast, we will emit every full line we receive.
        const proc = child_process.spawn(commandAndArgs, {
            stdio: ['ignore', 'pipe', 'pipe'],
            detached: false,
            shell: true,
            cwd: options.cwd,
            env: {
                ...process.env,
                ...(options.extraEnv ?? {}),
            },
        });
        const eventPublisher = options.eventPublisher ?? ((type, line) => {
            switch (type) {
                case 'data_stdout':
                    process.stdout.write(line);
                    return;
                case 'data_stderr':
                    process.stderr.write(line);
                    return;
                case 'open':
                case 'close':
                    return;
            }
        });
        proc.stdout.pipe(split()).on('data', (line) => eventPublisher('data_stdout', line));
        proc.stderr.pipe(split()).on('data', (line) => eventPublisher('data_stderr', line));
        proc.on('error', fail);
        proc.on('exit', code => {
            if (code === 0) {
                return ok();
            }
            else {
                return fail(new shared_public_1.ToolkitError(`Subprocess exited with error ${code}`));
            }
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFnQkEsZ0RBK0NDO0FBL0RELG9EQUFvRDtBQUNwRCxpRUFBaUU7QUFDakUsZ0NBQWlDO0FBQ2pDLHVEQUFtRDtBQVVuRDs7R0FFRztBQUNJLEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxjQUFzQixFQUFFLFVBQXVCLEVBQUU7SUFDeEYsT0FBTyxJQUFJLE9BQU8sQ0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUNwQyw4Q0FBOEM7UUFDOUMsRUFBRTtRQUNGLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsMERBQTBEO1FBQzFELEVBQUU7UUFDRiwwRkFBMEY7UUFDMUYsc0ZBQXNGO1FBQ3RGLE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFO1lBQy9DLEtBQUssRUFBRSxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO1lBQ2pDLFFBQVEsRUFBRSxLQUFLO1lBQ2YsS0FBSyxFQUFFLElBQUk7WUFDWCxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUc7WUFDaEIsR0FBRyxFQUFFO2dCQUNILEdBQUcsT0FBTyxDQUFDLEdBQUc7Z0JBQ2QsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDO2FBQzVCO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsTUFBTSxjQUFjLEdBQW1CLE9BQU8sQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRTtZQUMvRSxRQUFRLElBQUksRUFBRSxDQUFDO2dCQUNiLEtBQUssYUFBYTtvQkFDaEIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzNCLE9BQU87Z0JBQ1QsS0FBSyxhQUFhO29CQUNoQixPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDM0IsT0FBTztnQkFDVCxLQUFLLE1BQU0sQ0FBQztnQkFDWixLQUFLLE9BQU87b0JBQ1YsT0FBTztZQUNYLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXBGLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXZCLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFO1lBQ3JCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUNmLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDZCxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sT0FBTyxJQUFJLENBQUMsSUFBSSw0QkFBWSxDQUFDLGdDQUFnQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDeEUsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmltcG9ydCBzcGxpdCA9IHJlcXVpcmUoJ3NwbGl0MicpO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkLXB1YmxpYyc7XG5cbnR5cGUgRXZlbnRQdWJsaXNoZXIgPSAoZXZlbnQ6ICdvcGVuJyB8ICdkYXRhX3N0ZG91dCcgfCAnZGF0YV9zdGRlcnInIHwgJ2Nsb3NlJywgbGluZTogc3RyaW5nKSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgRXhlY09wdGlvbnMge1xuICBldmVudFB1Ymxpc2hlcj86IEV2ZW50UHVibGlzaGVyO1xuICBleHRyYUVudj86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG4gIGN3ZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY29tbWFuZCBhbmQgYXJncyBpbiBhIGNoaWxkIHByb2Nlc3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWNJbkNoaWxkUHJvY2Vzcyhjb21tYW5kQW5kQXJnczogc3RyaW5nLCBvcHRpb25zOiBFeGVjT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigob2ssIGZhaWwpID0+IHtcbiAgICAvLyBXZSB1c2UgYSBzbGlnaHRseSBsb3dlci1sZXZlbCBpbnRlcmZhY2UgdG86XG4gICAgLy9cbiAgICAvLyAtIFBhc3MgYXJndW1lbnRzIGluIGFuIGFycmF5IGluc3RlYWQgb2YgYSBzdHJpbmcsIHRvIGdldCBhcm91bmQgYVxuICAgIC8vICAgbnVtYmVyIG9mIHF1b3RpbmcgaXNzdWVzIGludHJvZHVjZWQgYnkgdGhlIGludGVybWVkaWF0ZSBzaGVsbCBsYXllclxuICAgIC8vICAgKHdoaWNoIHdvdWxkIGJlIGRpZmZlcmVudCBiZXR3ZWVuIExpbnV4IGFuZCBXaW5kb3dzKS5cbiAgICAvL1xuICAgIC8vIC0gV2UgaGF2ZSB0byBjYXB0dXJlIGFueSBvdXRwdXQgdG8gc3Rkb3V0IGFuZCBzdGRlcnIgc3Agd2UgY2FuIHBhc3MgaXQgb24gdG8gdGhlIElvSG9zdFxuICAgIC8vICAgVG8gZW5zdXJlIG1lc3NhZ2VzIGdldCB0byB0aGUgdXNlciBmYXN0LCB3ZSB3aWxsIGVtaXQgZXZlcnkgZnVsbCBsaW5lIHdlIHJlY2VpdmUuXG4gICAgY29uc3QgcHJvYyA9IGNoaWxkX3Byb2Nlc3Muc3Bhd24oY29tbWFuZEFuZEFyZ3MsIHtcbiAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgICAgIGRldGFjaGVkOiBmYWxzZSxcbiAgICAgIHNoZWxsOiB0cnVlLFxuICAgICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgICAgIGVudjoge1xuICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgLi4uKG9wdGlvbnMuZXh0cmFFbnYgPz8ge30pLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGV2ZW50UHVibGlzaGVyOiBFdmVudFB1Ymxpc2hlciA9IG9wdGlvbnMuZXZlbnRQdWJsaXNoZXIgPz8gKCh0eXBlLCBsaW5lKSA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGF0YV9zdGRvdXQnOlxuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGxpbmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnZGF0YV9zdGRlcnInOlxuICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGxpbmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvYy5zdGRvdXQucGlwZShzcGxpdCgpKS5vbignZGF0YScsIChsaW5lKSA9PiBldmVudFB1Ymxpc2hlcignZGF0YV9zdGRvdXQnLCBsaW5lKSk7XG4gICAgcHJvYy5zdGRlcnIucGlwZShzcGxpdCgpKS5vbignZGF0YScsIChsaW5lKSA9PiBldmVudFB1Ymxpc2hlcignZGF0YV9zdGRlcnInLCBsaW5lKSk7XG5cbiAgICBwcm9jLm9uKCdlcnJvcicsIGZhaWwpO1xuXG4gICAgcHJvYy5vbignZXhpdCcsIGNvZGUgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG9rKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbChuZXcgVG9vbGtpdEVycm9yKGBTdWJwcm9jZXNzIGV4aXRlZCB3aXRoIGVycm9yICR7Y29kZX1gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuIl19